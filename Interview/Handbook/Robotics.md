<!--
 * @Author: JohnJeep
 * @Date: 2025-11-17 09:21:18
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-11-17 09:21:25
 * @Description: 机器人面试
 * Copyright (c) 2025 by John Jeep, All Rights Reserved. 
-->



### ROS底层DDS是怎样实现的？



### 有没有遇见，传输数据时，DDS延迟或吞吐量达不到要求的情况？具体场景传什么数据？测下来延迟有多少？

DDS的延迟和吞吐量瓶颈通常源于以下几个原因：

1. 不当的QoS配置：这是最常见的原因。例如，对高频传感器数据使用 RELIABLE 模式，会带来巨大的确认开销。
2. 序列化/反序列化开销：将ROS     2消息结构转换为DDS可传输的字节流（和反向转换）需要CPU时间。消息结构越复杂，开销越大。
3. 底层传输选择：DDS未能正确选择最高效的传输方式（例如，本该用共享内存却走了UDP环路）。
4. 网络状况：网络拥堵、高丢包率会触发重传机制，显著增加延迟。
5. DDS实现本身的开销：不同的DDS供应商在实现细节上（如线程模型、内存管理）有差异，可能导致性能瓶颈。

 

### ROS 通信库本身有什么问题？

> 在实际开发中遇到了性能或稳定性问题。

1. **默认的 QoS 配置不是最优的。**

   ROS 2 为不同通信模式（如话题、服务、动作）提供了默认的 QoS 配置。

2. **序列化/反序列化机制（CDR:Common Data     Representation）增加 CPU的开销。**

   **减少序列化的措施：**

   1. 启用零拷贝传输(Zero-Copy Transports)，进程之间用共享内存，绕过序列化/反序列化过程。

   1. 进程内(Intra-Process)通信。同一个进程中，使用rclcpp::NodeOptions来启用 intra-process communication。

      当发布者和订阅者在同一个进程中时，ROS 2可以绕过DDS的序列化、网络传输和反序列化整个流程，直接在内存中传递消息对象的指针。


3. **多进程通信延迟。**

   在同一台机器上，ROS 2 节点默认使用环回网络接口进行通信，与跨主机的网络通信一致，会引入额外的网络开销，导致进程间通信有延迟。可通过零拷贝和共享内存（ intra-process）传输解决。

4. DDS 本身（Fast DDS）运行时可能占用较多的内存和 CPU 资源，尤其是在创建大量主题和参与者时，在资源受限的嵌入式系统是一个挑战。

5. **节点发现问题。**

   DDS 使用基于 UDP 的发现协议来自动发现网络中的其他节点。在某些网络配置下（如多网卡、防火墙规则严格、VPN 环境），发现过程可能会失败或延迟很高，导致节点无法正常建立连接。

6. 接口易用性。ROS 2 的通信接口为了兼容 DDS 做出了一些牺牲。
   1. 服务调用必须指定超时。在 ROS 1 中，服务调用可以无限期等待。而在 ROS 2 中，由于底层 DDS      的限制，每个服务调用都必须设置一个明确的超时时间，这增加了代码的复杂性。
   2. “历史深度(history depth)”概念：DDS      引入了“历史深度”的概念来管理队列缓存。配置不当可能导致数据丢失（对于“KEEP_LAST”策略）或内存耗尽（对于“KEEP_ALL”策略）。



### DDS 有一个基于本地间通信的共享内存，有用过吗？是怎么配置的？



### 你用 Topic 发出来的数据，你是怎么减少序列化与反序列化的？



### topic 中有没遇见数据传输量很大的数据？是什么样的数据类型？



### 应用层注册一个回调函数，从发布到订阅，再触发回调，处理业务，整个流程ROS2 库底层是怎样实现的？



### service 底层是怎么调用的？
