<!--
 * @Author: JohnJeep
 * @Date: 2020-08-10 23:31:12
 * @UpdateTime: 2021-09-07 08:32
 * @UpdateTime: 2025-11-07 14:37
 * @UpdateTime: 2025-11-16 17:37
 * @UpdateTime: 2025-11-18 12:36
 * @UpdateTime: 2025-11-20 10:30
 * @LastEditTime: 2026-01-03 15:56:03
 * @LastEditors: JohnJeep
 * @Description: C/C++ 面试常见的问题
-->

- [1. new/malloc](#1-newmalloc)
- [2. vector](#2-vector)
  - [2.1.  vector 是怎么扩容的？](#21--vector-是怎么扩容的)
  - [2.2. 为什么频繁 push\_back 可能导致性能抖动？](#22-为什么频繁-push_back-可能导致性能抖动)
  - [2.3. 如果要存储大量小对象，有没有更好的方式？](#23-如果要存储大量小对象有没有更好的方式)
  - [2.4.  Vector 的内存管理方式是怎么做的？内存怎么回收？不析构vector对象，回收部分内存？](#24--vector-的内存管理方式是怎么做的内存怎么回收不析构vector对象回收部分内存)
  - [2.5. vector清空用哪些函数](#25-vector清空用哪些函数)
- [3. 虚函数](#3-虚函数)
  - [3.1.  虚函数表的实现原理？是什么东西？什么时候生成的？在内存上是怎么表现的？](#31--虚函数表的实现原理是什么东西什么时候生成的在内存上是怎么表现的)
  - [3.2. 解释下什么是虚指针？虚指针与虚函数表之间的关系是什么？](#32-解释下什么是虚指针虚指针与虚函数表之间的关系是什么)
  - [3.3. 一个类什么时候会有虚函数表？一个类有多少张表？](#33-一个类什么时候会有虚函数表一个类有多少张表)
  - [3.4. 普通函数、虚函数、纯虚函数的区别是什么？](#34-普通函数虚函数纯虚函数的区别是什么)
  - [3.5. 可不可以更改虚函数表的内容？](#35-可不可以更改虚函数表的内容)
  - [3.6. 解释下你对多态的理解](#36-解释下你对多态的理解)
  - [3.7. C++的虚函数指针是什么？多重继承虚函数表指针有几张？](#37-c的虚函数指针是什么多重继承虚函数表指针有几张)
  - [3.8. 用sizeof求类中用虚函数实现的方法和char \*p定义的变量时， 整个类的大小？](#38-用sizeof求类中用虚函数实现的方法和char-p定义的变量时-整个类的大小)
- [4. 解释下 深拷贝、浅拷贝的区别](#4-解释下-深拷贝浅拷贝的区别)
- [5. 构造函数能定义为虚函数吗](#5-构造函数能定义为虚函数吗)
- [6. 为什么析构函数要为虚函数(请深层次剖析，说底层的原因)](#6-为什么析构函数要为虚函数请深层次剖析说底层的原因)
- [7. 简单讲解一下右值引用是用来做什么事情的？](#7-简单讲解一下右值引用是用来做什么事情的)
- [8. 解释下 overload、override 的区别](#8-解释下-overloadoverride-的区别)
- [9. 智能指针](#9-智能指针)
  - [9.1. 都有哪些智能指针？作用分别是什么？分别要解决什么问题？](#91-都有哪些智能指针作用分别是什么分别要解决什么问题)
  - [9.2.  简单介绍下智能指针是怎样实现的？](#92--简单介绍下智能指针是怎样实现的)
  - [9.3.  shared\_ptr 是怎样解决内存泄漏的？](#93--shared_ptr-是怎样解决内存泄漏的)
  - [9.4.  shared\_ptr 引用计数什么时候会增加？什么时候会减少？](#94--shared_ptr-引用计数什么时候会增加什么时候会减少)
  - [9.5.  引用计数本身表示的是什么？](#95--引用计数本身表示的是什么)
  - [9.6.  weak\_ptr 是怎么解决 share\_ptr 循环引用的问题？](#96--weak_ptr-是怎么解决-share_ptr-循环引用的问题)
  - [9.7. 简单介绍下 weak\_ptr 使用的场景？](#97-简单介绍下-weak_ptr-使用的场景)
  - [9.8.  怎么判断 weak\_ptr 所关联的对象已经失效了？](#98--怎么判断-weak_ptr-所关联的对象已经失效了)
- [10. lambda](#10-lambda)
  - [10.1. std::function 可以赋值给函数指针吗？](#101-stdfunction-可以赋值给函数指针吗)
  - [10.2. 匿名函数有哪些？lambda 表达式的用法。](#102-匿名函数有哪些lambda-表达式的用法)
  - [10.3. lambda 中捕获的是指针，如何处理？](#103-lambda-中捕获的是指针如何处理)
- [11. 多线程](#11-多线程)
  - [11.1. 项目中有没有碰见死锁的问题？是如何解决的？](#111-项目中有没有碰见死锁的问题是如何解决的)
  - [11.2. 多个线程之间是如何通信的？](#112-多个线程之间是如何通信的)
  - [11.3. 什么是自旋锁？用来做什么的？](#113-什么是自旋锁用来做什么的)
- [12. 讲一讲对extern、extern "C"的理解。](#12-讲一讲对externextern-c的理解)
- [13. Ｃ++与c互相调用问题](#13-ｃ与c互相调用问题)
- [14. static关键字干嘛的，哪些场景用](#14-static关键字干嘛的哪些场景用)
- [15. 说一下，一个函数在堆栈中是如何放置的，static变量，全局变量是放置在哪里？](#15-说一下一个函数在堆栈中是如何放置的static变量全局变量是放置在哪里)
- [16. 讲一下sizeof()与strlen()的区别。](#16-讲一下sizeof与strlen的区别)
- [17. strcpy 和 memcpy 用法](#17-strcpy-和-memcpy-用法)
  - [17.1. 讲一下strcpy与memcpy的区别，讲一下strncpy与memcpy的区别。](#171-讲一下strcpy与memcpy的区别讲一下strncpy与memcpy的区别)
  - [17.2. strncpy使用的注意事项](#172-strncpy使用的注意事项)
  - [17.3. 手写memcpy](#173-手写memcpy)
  - [17.4. 手写strcpy或strncpy](#174-手写strcpy或strncpy)
- [18. Struct 关键字](#18-struct-关键字)
  - [18.1. struct结构体字节对齐？底层操作？](#181-struct结构体字节对齐底层操作)
  - [18.2. 两个结构体类型的变量是否可以用memcmp函数比较](#182-两个结构体类型的变量是否可以用memcmp函数比较)
  - [18.3. 如何比较两个结构体是否相等](#183-如何比较两个结构体是否相等)
  - [18.4. struct与class关键字区别](#184-struct与class关键字区别)
  - [18.5. C语言中，空结构体的大小是多少？](#185-c语言中空结构体的大小是多少)
  - [18.6. C++中空类的大小为 1byte的原因](#186-c中空类的大小为-1byte的原因)
- [19. 函数重载底层是怎样实现的？](#19-函数重载底层是怎样实现的)
- [20. const关键字怎么用？哪些场景用](#20-const关键字怎么用哪些场景用)
- [21. 类中const的用法，如何初始化？函数中加const，const修饰的是什么？](#21-类中const的用法如何初始化函数中加constconst修饰的是什么)
- [22. 常量指针和指针常量,分别怎么声明，怎么用？](#22-常量指针和指针常量分别怎么声明怎么用)
- [23. C/C++中函数传递指针和传递引用的本质区别是什么呢？](#23-cc中函数传递指针和传递引用的本质区别是什么呢)
- [24. 构造函数可以是虚函数吗？](#24-构造函数可以是虚函数吗)
- [25. 析构函数可以是虚函数吗？什么时候用到？](#25-析构函数可以是虚函数吗什么时候用到)
- [26. map](#26-map)
  - [26.1. map底层实现红黑树和平衡二叉树的区别](#261-map底层实现红黑树和平衡二叉树的区别)
  - [26.2. 如何给无序的map排序？](#262-如何给无序的map排序)
  - [26.3. map和unordered\_map的区别？](#263-map和unordered_map的区别)
  - [26.4. map插入有哪几种方法，insert方法的返回值](#264-map插入有哪几种方法insert方法的返回值)
- [27. 类中的列表初始化和函数体中初始化有什么区别？](#27-类中的列表初始化和函数体中初始化有什么区别)
- [28. 类的空指针调用成员函数会出现什么情况？怎么处理？](#28-类的空指针调用成员函数会出现什么情况怎么处理)
- [29. 局部变量和全局变量的区别？](#29-局部变量和全局变量的区别)
- [30. 全局变量未初始化时为什么随机值？](#30-全局变量未初始化时为什么随机值)
- [31. 内存问题](#31-内存问题)
  - [31.1. 如何快速定位一个大型c++项目的内存泄漏问题？](#311-如何快速定位一个大型c项目的内存泄漏问题)
  - [31.2. 内存溢出解决](#312-内存溢出解决)
  - [31.3. 缓冲溢出报警及解决](#313-缓冲溢出报警及解决)
- [32. main 函数理解](#32-main-函数理解)
  - [32.1. main函数执行前会做些什么工作？](#321-main函数执行前会做些什么工作)
  - [32.2. main函数返回值意义及获取方式](#322-main函数返回值意义及获取方式)
- [33. 解释下define与inline函数的区别？](#33-解释下define与inline函数的区别)

# 1. new/malloc

常见提问
1.  <font color="#ff33cc">**c++ 中使用new关键字，在代码层面和内核层面分别做些什么事情？**</font>
2. 讲解下new和malloc的区别
3.  new申请的内存，free可以释放吗？


# 2. vector

## 2.1.  <font color="#ff33cc">vector 是怎么扩容的？</font>

增长策略：GCC/Clang: 通常2倍增长，MSVC: 1.5倍增长

1）采用动态数组实现的。先为数组开辟较小的空间，然后往数组里面添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL中 vector 每次扩容时，新的容量都是前一次的两倍），再把之前的数据复制到新的数组中，再把之前的内存释放。

2）实际应用中采用vector比list、deque容器的效率高。因为不必为每个新添的元素分配容器，在内存中预留了额外的存储区（连续的内存块存储元素），用于存放新添的元素。

3）大小：size=_Mylast - _Myfirst；
    容量：capacity=_Myend - _Myfirst；
size表示vector中已有元素的个数，capacity表示vector最多可存储的元素的个数；
• 为什么是两倍或1.5倍？
    

根据不同的编译器，vector自动扩充的容量也不同，GCC编译器一般设置为 2 倍，VS编译器中一般采用的为1.5 倍
    § 使用这个扩容因子是时间复杂度和空间复杂度最优的结果。例如：迭代次数为n，扩容因子为m，使用push_back()运算花费的总时间为：m^1 + m^2 + ... m^(log_m(n))
       

因此每次扩容需要花费的时间为 m/(m-1) 是一个常量，扩容因子为m 太大或太小都影响内存的分配和时间的花费，最理想的因子为 m = 1.5，STL库中一般为 2
参  



## 2.2. 为什么频繁 push_back 可能导致性能抖动？

频繁 push_back 可能导致性能抖动的原因是因为 vector 在扩容时需要重新分配内存并复制已有元素到新内存中，这个过程是耗时的。\
当 vector 的容量不足以容纳新元素时，push_back 会触发扩容操作，导致以下步骤：
1. 分配一块新的更大的内存空间。
2. 将原有元素从旧内存复制到新内存。
3. 释放旧内存。
4. 将新元素添加到新内存中。
5. 更新 vector 的内部指针。
6. 更新容量和大小。

如果频繁发生扩容，可能会导致性能抖动，因为每次扩容都需要进行上述步骤，这会增加 CPU 的负担和内存的分配开销。\
为了避免这种情况，可以预先使用 reserve() 方法为 vector 分配足够的内存空间，减少扩容的次数，从而提高性能稳定性。\
此外，频繁的内存分配和释放也可能导致内存碎片化，从而进一步影响性能。


## 2.3. 如果要存储大量小对象，有没有更好的方式？

对于大量小对象，使用 vector 可能会导致频繁的内存分配和释放，从而影响性能。\
可以考虑以下几种方式来优化存储小对象的性能：
1. **使用对象池（Object Pool）**：预先分配一块内存区域，存储小对象的实例，避免频繁的内存分配和释放。对象池可以重用已释放的对象，减少内存碎片化。
2. **使用 std::deque**：deque 是双端队列，支持在两端高效地添加和删除元素。相比 vector，deque 在频繁插入和删除小对象时性能更好，因为它不需要像 vector 那样频繁地扩容和移动元素。
3. **使用 std::list**：如果需要频繁地在中间插入和删除小对象，可以使用双向链表（std::list）。它允许在任意位置高效地插入和删除元素，但会增加内存开销，因为每个元素都需要额外的指针来维护链表结构。
4. **使用栈分配**：如果小对象的生命周期较短，可以考虑在栈上分配它们，而不是在堆上动态分配。这样可以避免内存分配和释放的开销。
5. **使用 std::array 或 std::vector 的预分配**：如果知道小对象的数量，可以使用 std::array 或 std::vector 的 reserve() 方法预先分配足够的内存空间，减少扩容的次数。
6. **使用内存池（Memory Pool）**：类似于对象池，但更通用，可以用于管理任意类型的对象。内存池可以预先分配一大块内存，然后按需分配小块内存给小对象，减少内存碎片化和分配开销。
7. **使用自定义分配器**：可以实现一个自定义的内存分配器，专门用于分配小对象的内存。这样可以更好地控制内存分配和释放的策略，提高性能。
8. **使用 std::vector 的 shrink_to_fit() 方法**：在不需要小对象时，可以调用 `shrink_to_fit()` 方法来释放未使用的内存，减少内存占用。
9. **使用 std::vector 的 reserve() 方法**：在添加小对象之前，使用 reserve() 方法预先分配足够的内存空间，减少扩容的次数，提高性能。
10. **使用 std::vector 的 emplace_back() 方法**：如果小对象是可移动的，可以使用 `emplace_back()` 方法直接在 vector 中构造对象，避免不必要的拷贝操作，提高性能。
11. **使用 std::vector 的 move semantics**：如果小对象是可移动的，可以使用 `std::move()` 将对象从一个 vector 移动到另一个 vector，避免不必要的拷贝操作，提高性能。


## 2.4.  <font color="#ff33cc">Vector 的内存管理方式是怎么做的？内存怎么回收？不析构vector对象，回收部分内存？</font>

Vector 的内存管理方式主要依赖于动态内存分配和析构函数。
1. **内存分配**：当 vector 的容量不足以容纳新元素时，vector 会自动扩容。扩容时，vector 会分配一块新的内存区域，并将原有元素复制到新内存中。这个过程通常是通过调用 `new` 操作符来实现的。
2. **内存回收**：当 vector 对象被销毁时，vector 的析构函数会被调用。析构函数会释放 vector 内部使用的内存区域，通常是通过调用 `delete` 操作符来实现的。\
3. **不析构 vector 对象的内存回收**：如果不显式地析构 vector 对象，vector 的内存不会被释放。这可能导致内存泄漏，因为 vector 内部分配的内存仍然存在于堆中。\
4. **部分内存回收**：如果 vector 对象被销毁，但其中的元素没有被析构（例如，元素是指针类型），那么这些指针指向的内存仍然存在于堆中。这可能导致内存泄漏，因为这些指针所指向的内存不会被自动释放。为了避免这种情况，应该在 vector 的析构函数中显式地释放这些指针所指向的内存。
5. **内存管理策略**：C++ STL 中的 vector 使用 RAII（资源获取即初始化）原则来管理内存。即在对象的生命周期内自动管理资源的分配和释放。当 vector 对象超出作用域时，析构函数会被自动调用，从而释放内存。
6. **内存池**：在一些高性能应用中，可以使用内存池来管理 vector 的内存分配和释放。内存池可以预先分配一大块内存，然后按需分配小块内存给 vector，从而减少频繁的内存分配和释放操作，提高性能。
7.   



## 2.5. vector清空用哪些函数

vector 清空可以使用以下函数：
1. **clear()**：清空 vector 中的所有元素，但不释放内存。调用 `clear()` 后，vector 的大小变为 0，但容量保持不变。
   ```cpp
   std::vector<int> vec = {1, 2, 3};
   vec.clear(); // vec 现在为空，但容量未改变
   ```
2. **resize(0)**：将 vector 的大小调整为 0，等同于清空 vector。调用 `resize(0)` 后，vector 的大小变为 0，但容量保持不变。
   ```cpp
    std::vector<int> vec = {1, 2, 3};
    vec.resize(0); // vec 现在为空，但容量未改变
    ```
3. **swap()**：将 vector 与一个空的临时 vector 交换，从而清空原 vector。调用 `swap()` 后，原 vector 变为空，且容量被释放。
    ```cpp
    std::vector<int> vec = {1, 2, 3};
    std::vector<int>().swap(vec); // vec 现在为空，容量被释放
    ```
4. **使用 `std::vector::erase()`**：可以通过 `erase()` 方法删除特定范围的元素，从而清空 vector。例如，`vec.erase(vec.begin(), vec.end())` 可以清空整个 vector，但这不会改变容量。
   ```cpp
   std::vector<int> vec = {1, 2, 3};
   vec.erase(vec.begin(), vec.end()); // vec 现在为空，但容量未改变
   ```
5. **使用 `std::vector::assign()`**：可以使用 `assign()` 方法将 vector 重新赋值为空，从而清空 vector。调用 `assign(0, T())` 可以清空 vector，但这不会改变容量。
   ```cpp
    std::vector<int> vec = {1, 2, 3};
    vec.assign(0, 0); // vec 现在为空，但容量未改变
    ```


## 2.6. 讲一下迭代器生效的原因

迭代器生效的原因是因为迭代器是对容器元素的抽象表示，它提供了一种统一的方式来访问和操作容器中的元素。迭代器可以在不同类型的容器（如 vector、list、set 等）上工作，而不需要关心容器的具体实现细节。
迭代器的生效主要体现在以下几个方面：
1. **统一接口**：迭代器提供了一组统一的操作接口，如 `begin()`、`end()`、`++`、`*` 等，使得对容器元素的访问和操作变得一致和简洁。
2. **抽象化**：迭代器将容器的内部实现细节隐藏起来，用户只需要关心如何使用迭代器来访问元素，而不需要了解容器的具体存储结构。
3. **灵活性**：迭代器可以在不同类型的容器上工作，使得算法和操作可以在不同容器之间复用，提高了代码的灵活性和可重用性。
4. **支持多种操作**：迭代器支持多种操作，如遍历、插入、删除等，使得对容器元素的操作更加方便和高效。
5. **与算法结合**：迭代器可以与 STL 算法（如 `std::sort`、`std::find` 等）结合使用，使得对容器元素的操作更加高效和简洁。STL 算法通常接受迭代器作为参数，从而实现对容器元素的操作。
6. **支持不同类型的容器**：迭代器可以适用于不同类型的容器，如顺序容器（vector、deque）、关联容器（set、map）等，使得对容器元素的访问和操作变得更加灵活和通用。
7. **支持不同类型的迭代器**：STL 提供了多种类型的迭代器，如输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器等，满足不同场景下的需求。这些迭代器具有不同的特性和操作能力，使得对容器元素的访问和操作更加灵活和高效。
8. **支持范围-based for 循环**：C++11 引入了范围-based for 循环，使得使用迭代器遍历容器变得更加简洁和直观。范围-based for 循环可以直接使用容器对象，而不需要显式地获取迭代器。
   ```cpp
   std::vector<int> vec = {1, 2, 3};
   for (int x : vec) {
       std::cout << x << " "; // 输出 1 2 3
   }
   ```
9. **支持自定义迭代器**：用户可以根据需要自定义迭代器，以满足特定的访问和操作需求。自定义迭代器可以继承自 STL 提供的迭代器基类，并实现所需的操作接口，从而与 STL 算法和容器兼容。
10. **支持迭代器适配器**：STL 提供了一些迭代器适配器，如 `std::reverse_iterator`、`std::back_insert_iterator` 等，可以对现有的迭代器进行包装和转换，从而实现更灵活的访问和操作方式。



# 3. 虚函数

## 3.1.  <font color="#ff33cc">虚函数表的实现原理？是什么东西？什么时候生成的？在内存上是怎么表现的？</font>



## 3.2. 解释下什么是虚指针？虚指针与虚函数表之间的关系是什么？



## 3.3. 一个类什么时候会有虚函数表？一个类有多少张表？



## 3.4. 普通函数、虚函数、纯虚函数的区别是什么？



## 3.5. 可不可以更改虚函数表的内容？



## 3.6. 解释下你对多态的理解

• 多态实现的三要素：继承、虚函数、父类对象指向子类对象。

• 虚函数表vptr

C++编译器提前布局了一个VPTR指针

• C++编译器使用函数指针做函数参数



## 3.7. C++的虚函数指针是什么？多重继承虚函数表指针有几张？



## 3.8. 用sizeof求类中用虚函数实现的方法和char *p定义的变量时， 整个类的大小？

虚函数中有vpr指针，计算大小时，整个类的大小为 vpr指针大小加上 char 指针的大小，指针的大小只与计算机的位宽有关。



# 4. 解释下 深拷贝、浅拷贝的区别



# 5. 构造函数能定义为虚函数吗



# 6. 为什么析构函数要为虚函数(请深层次剖析，说底层的原因)





# 7. 简单讲解一下右值引用是用来做什么事情的？

std::move()

# 8. 解释下 overload、override 的区别



# 9. 智能指针

## 9.1. 都有哪些智能指针？作用分别是什么？分别要解决什么问题？



## 9.2.  <font color="#ff33cc">简单介绍下智能指针是怎样实现的？</font>



## 9.3.  <font color="#ff33cc">shared_ptr 是怎样解决内存泄漏的？</font>



## 9.4.  <font color="#ff33cc">shared_ptr 引用计数什么时候会增加？什么时候会减少？</font>

创建、拷贝、拷贝赋值对象时，引用计数增加。

使用移动构造（std::move）时，引用计数不会增加，因为移动操作会将资源从一个shared_ptr转移到另一个shared_ptr，原来的shared_ptr变为空，新的shared_ptr接管资源，引用计数不变。

 离开作用域时，所有 shared_ptr 销毁，引用计数递减；也可以现实的使用 reset 操作，减少引用计数。

## 9.5.  <font color="#ff33cc">引用计数本身表示的是什么？</font>

引用计数本质上是一个共享的计数器，所有指向同一对象的 `shared_ptr` 实例都共享这个计数器。



## 9.6.  <font color="#ff33cc">weak_ptr 是怎么解决 share_ptr 循环引用的问题？</font>

1. 不增加引用计数，避免形成引用环
2. 观察者模式：只观察对象，不拥有对象
3. 安全访问：通过 lock() 获取临时的 shared_ptr
4. 自动感知：能检测到所指对象是否已被销毁

## 9.7. 简单介绍下 weak_ptr 使用的场景？



## 9.8.  <font color="#ff33cc">怎么判断 weak_ptr 所关联的对象已经失效了？</font>





# 10. lambda

## 10.1. std::function 可以赋值给函数指针吗？



## 10.2. 匿名函数有哪些？lambda 表达式的用法。



## 10.3. lambda 中捕获的是指针，如何处理？



# 11. 多线程

## 11.1. <font color="#ff33cc">项目中有没有碰见死锁的问题？是如何解决的？</font>



## 11.2. 多个线程之间是如何通信的？



## 11.3. 什么是自旋锁？用来做什么的？



# 12. 讲一讲对extern、extern "C"的理解。

    • C/C++中使用extern声明的变量或函数，它们的作用域是全局的，告诉编译器使用该关键字声明的变量可以在本模块或其他模块中使用。只是声明了变量，但是并没有定义该变量。
    • extern "C" 的作用是为了能够正确在 C++ 代码中调用 C 语言代码。 加上 extern C 后指示编译器按 C 编译器编译这部分代码。使用它的本质的原因是 C++ 函数重载，C++ 中函数重载在编译后生成的不止是函数名，会带上参数类型，会改变函数的名称，而 C 编译器编译函数时不会带上函数的参数类型，函数的名称没有变。
    • 在混合编程中，如果我们不进行任何处理，而相互调用的话，在链接会出现找不到符号链接的情况。
    • extern "C"是C++的特性，是一种链接约定，通过它可以实现兼容C与C++之间的相互调用，即对调用函数能够达成一致的意见，使用统一的命名规则，使得实现方提供的接口和调用方需要的接口经按照指定规则编译后，得到的都是一致的函数符号命名。

# 13. Ｃ++与c互相调用问题

C++中调用 C 函数：使用 extern "C" 关键字
• C如何调用C++函数：需要使用预处理宏和extern "C" 关键字

```cpp
#ifdef __cplusplus
extern "C"
{
#endif
    ……..
    ……..
#ifdef __cplusplus
}
#endif
```

# 14. static关键字干嘛的，哪些场景用

• 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。其它的文件中可以调用该函数和变量。加了static关键字后，相当于做一个隐藏的作用，只对当前调用的文件有效。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

• static修饰的变量在函数体内定义时，表明它的申请的内存是驻留在全局区，直到程序运行结束。但是它作用域仍为局部作用域，只能在函数体内使用定义的该变量，不能在函数体外使用。因此可以得出一个结论：把局部变量改变为static变量后改变了它的生存期。把全局变量改变为static变量后是改变了它的作用域， 限制了它的使用范围，仅仅只在拥有该变量的文件中使用，不能在其它的文件中调用。
    
    
# 15. 说一下，一个函数在堆栈中是如何放置的，static变量，全局变量是放置在哪里？

内存四区：代码区、全局区（没有初始化.bss  初始化.data）、堆区、栈区
    



# 16. 讲一下sizeof()与strlen()的区别。



# 17. strcpy 和 memcpy 用法



## 17.1. 讲一下strcpy与memcpy的区别，讲一下strncpy与memcpy的区别。





## 17.2. strncpy使用的注意事项

    • 是字符串之间进行拷贝的函数，不能用于复杂数据的结构类型。
    • src和dest所指内存区域不可以重叠，且dest必须有足够的空间来容纳src的字符长度+'\0'
    • strcpy只是复制字符串，但不限制复制的数量，很容易造成缓冲溢出。strncpy要安全一些。
    •  memcpy能够选择一段字符输出，strcpy复制全部的字符串。
    •  执行完strncpy()后，会覆盖原先dest字符数组中的数据。

## 17.3. 手写memcpy



## 17.4. 手写strcpy或strncpy



# 18. Struct 关键字

## 18.1. struct结构体字节对齐？底层操作？

https://blog.csdn.net/zhanghow/article/details/55262988



## 18.2. 两个结构体类型的变量是否可以用memcmp函数比较

不能，memcmp是按照字节为单位进行比较的。由于结构体中有字节对齐的原因，导致结构体中会填充一些随机的数来保证字节对齐，因此两个结构体中的数据是不相等的。
    

## 18.3. 如何比较两个结构体是否相等

C：用指针地址比较，形如 `a==b`

C++：memcmp()函数逐个字节进行比较的，而struct存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较，需要重载==操作运算符。



## 18.4. struct与class关键字区别

    • 默认继承权限。如果不明确指定，class的继承按照private继承处理，struct的继承按照public继承处理；
    • 成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
    ```
    struct A
    {
        int i;          // 成员变量默认属性为public
        string s;       // string 类中成员变量的默认属性为private 
    };
    ```
    • class关键字可以用于定义模板参数，就像typename，但关键字struct不用于定义模板参数。
    • 在C语言中，struct体现的是一种数据类型的思想，不能定义函数，否则编译器会报错，在面向过程的编程中，数据和数据的操作是分开的。在C++中class体现的是面向对象封装的思想，数据和数据的操作在一起。
    • C++中struct可以定义函数，但是C语言中struct只可以定义函数指针。
    • C语言中sizeof( struct )，会计算定义的函数指针大小；C++中sizeof( struct ) 和 sizeof( class )都不会计算函数的大小，只会计算成员变量的大小。

## 18.5. C语言中，空结构体的大小是多少？

C语言中，空结构体的大小是0（编译器不一样，结果可能是1或0），而C++中空结构体（属于空类）的大小为 1。

## 18.6. C++中空类的大小为 1byte的原因

空类中没有函数和数据成员，可以被实例化。一个类能被实例化，编译器就要给他分配空间，来指示类实例化的地址，通常编译器分配为 1 个字节（char类型），这样分配同时也保证了 空类占用的空间最小。

C++的编译器不能接受两个对象实例化后的地址完全一样，即重名的情况，就给空类加了个 1 byte 的占位符，让每个对象都有一个独一无二的内存地址。                                             

当空类被用作基类时，编译器会做"空基类优化"(EBO)，这时候子类就不会再额外占用这1字节了。

```cpp
class Base {};
class Derived : public Base {
    int data;
};
// Derived的大小就是4字节（int的大小），而不是5字节
```



查看工具

1. Pahole
2. Compiler Explorer: https://godbolt.org/



# 19. 函数重载底层是怎样实现的？

• 特点：函数名称相同时，根据函数参数的类型、个数不同而发生函数重载，函数的返回值不能作为判断函数重载的标准。
• 底层实现
    § C++编译器在编译时，根据函数传入的参数列表进行重命名，改成便于区分的，避免了函数在调用时出现的二义性。在汇编代码中可以观察到函数名相同参数不同的函数，被改写成不同的函数名，即每个函数实现了自己的汇编代码。
    § C++利用name mangling(命名倾轧)技术，来改变函数名，区分参数不同的同名函数。
    § Name Mangling 是一种在编译过程中，将函数、变量的名称重新改编的机制。在 C++重载、namespace等操作符下，函数可以有同样的名字，编译器为了区分各个不同地方的函数，将各个函数通过编译器内定的算法，将函数改成唯一的名称。



# 20. const关键字怎么用？哪些场景用



# 21. 类中const的用法，如何初始化？函数中加const，const修饰的是什么？



# 22. 常量指针和指针常量,分别怎么声明，怎么用？



# 23. C/C++中函数传递指针和传递引用的本质区别是什么呢？

• 指针本质存放的是一个变量地址，它可以改变，包括指针指向的地址、指针指向地址的数据都可以改变。

• 引用是一个别名，必须在一开始就要被初始化，引用的对象在其整个生命周期中是不能被改变的。在C++中，指针和引用经常用于函数的参数传递。

• 编译器的角度：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

• 相同点：都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

• 不同点：指针是一个实体，而引用仅是个别名；
    

引用只能在定义时被初始化一次，之后不可变；指针可变。
    

引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）
    

引用不能为空，指针可以为空；
    

 “sizeof （引用）”得到的是所指向的变量(对象)的大小，而“sizeof （指针）”得到的是指针本身的大小；
    

 指针和引用的自增(++)运算意义不一样；
    

 引用是类型安全的，而指针不是 ，引用比指针多了类型检查。

来自 <https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html> 

地址就是一种指针，而指针是地址的另一种形式，两者之间是互通的。
reference就是一种漂亮的pointer。





# 24. 构造函数可以是虚函数吗？

不可以。
构造对象的时候，必须知道对象的实际类型。而虚函数行为是在运行期间确定实际类型的，在构造对象的时，对象还没有构造成功，编译器无法知道对象的实际类型是该类本身还是其派生类。

虚函数的运行依赖于虚函数指针，而虚函数指针在构造函数中进程初始化，让它指向正确的虚函数表，而在对象构造期间，虚函数指针还未构造完成。

参考： https://www.zhihu.com/question/66905859/answer/887885656





# 25. 析构函数可以是虚函数吗？什么时候用到？

可以；当用一个基类的指针删除子类的对象时，子类的析构函数都会被调用。

（1）如果父类的析构函数不加virtual关键字 
    当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 

（2）如果父类的析构函数加virtual关键字 
    当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。
只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。



# 26. map

## 26.1. map底层实现红黑树和平衡二叉树的区别

## 26.2. 如何给无序的map排序？



## 26.3. map和unordered_map的区别？

    •  C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)。
    •  unordered_set是基于哈希表。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。
    • 解决哈希函数中冲突的方法：开发地址法、再散列法、链地址法(也称拉链法)
    
    • C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。
    •  在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为桶），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。 原型中的Key代表要存储的类型，而hash<Key>也就是你的hash函数，equal_to<Key>用来判断两个元素是否相等，allocator<Key>是内存的分配策略。
    来自 <https://blog.csdn.net/Dream_you_to_life/article/details/46785741?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase%3E> 

## 26.4. map插入有哪几种方法，insert方法的返回值

```cpp
// 四种map容器的插入方法
map<int, string> mp;
mp.insert(pair<int, string>(101, "赵云"));                   // 法一
mp.insert(make_pair<int, string>(102, "关羽"));              // 法二
mp.insert(map<int, string>::value_type(103, "曹操"));        // 发三
mp[104] = "张飞";   

返回值是pair数据对象
```



# 27. 类中的列表初始化和函数体中初始化有什么区别？

    • 函数体内初始化：先调用构造函数，再调用赋值运算，会带来额外的开销，效率比较低。
    • 列表初始化：直接调用构造函数，不会调用赋值函数，列表初始化先于函数体执行。



# 28. 类的空指针调用成员函数会出现什么情况？怎么处理？

    • 类的成员函数中调用了this 指针时，出现段错误；若没有调用this指针，则不会报错，
    • 当成员函数为静态函数时，可以调用成员函数。因为静态成员函数中没有this指针，静态成员独立于任何的对象。



# 29. 局部变量和全局变量的区别？



# 30. 全局变量未初始化时为什么随机值？



# 31. 内存问题

## 31.1. 如何快速定位一个大型c++项目的内存泄漏问题？

1）查看日志log

2）Linux采用valgrind

3）Windows下采用visual studio在debug在调用 _CrtDumpMemoryLeaks() 函数
通过wrap malloc/free + backtrace + addr2line，你就可以定位到内存泄漏了。

来自 <https://daydaynews.cc/zh-hans/technology/204786.html> 



## 31.2. 内存溢出解决

• 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

• 内存泄露 memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

• memory leak会最终会导致out of memory！
内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 

•  按照发生的方式来分类，内存泄漏可以分为4类： 

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 
4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 
  从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 

检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
 § 检查代码中是否有死循环或递归调用。
 § 检查是否有大循环重复产生新对象实体。
 § 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

## 31.3. 缓冲溢出报警及解决



# 32. main 函数理解

## 32.1. main函数执行前会做些什么工作？



## 32.2. main函数返回值意义及获取方式

C/C++中，应将main函数写成 int main() { return 0;},返回值是int类型；而不应该写成void main(){}; 函数没有返回值，有些编译器器可能会报错。如果返回0，则代表程序正常退出，返回其它数字的含义则由系统决定，通常，返回非零代表程序异常退出。



# 33. 解释下define与inline函数的区别？

