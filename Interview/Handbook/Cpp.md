<!--
 * @Author: JohnJeep
 * @Date: 2021-04-08 21:37:12
 * @LastEditTime: 2025-11-17 09:15:22
 * @LastEditors: JohnJeep
 * @Description: In User Settings Edit
-->
2020年8月10日   23:31
C/C++面试常见的问题
<!-- TOC -->

- [1. new和malloc的区别](#1-new和malloc的区别)
- [2. 讲一讲对extern、extern "C"的理解。](#2-讲一讲对externextern-c的理解)
- [3. Ｃ++与c互相调用问题](#3-ｃ与c互相调用问题)
- [4. static关键字干嘛的，哪些场景用](#4-static关键字干嘛的哪些场景用)
- [5. 说一下，一个函数在堆栈中是如何放置的，static变量，全局变量是放置在哪里？](#5-说一下一个函数在堆栈中是如何放置的static变量全局变量是放置在哪里)
- [6. 讲一下sizeof()与strlen()的区别。](#6-讲一下sizeof与strlen的区别)
- [7. 讲一下对malloc和new的理解。](#7-讲一下对malloc和new的理解)
- [8. 讲一下strcpy与memcpy的区别，讲一下strncpy与memcpy的区别。](#8-讲一下strcpy与memcpy的区别讲一下strncpy与memcpy的区别)
- [9. strncpy使用的注意事项](#9-strncpy使用的注意事项)
- [10. 手写memcpy](#10-手写memcpy)
- [11. 手 写strcpy或strncpy](#11-手-写strcpy或strncpy)
- [12. struct结构体字节对齐？底层操作？ https://blog.csdn.net/zhanghow/article/details/55262988](#12-struct结构体字节对齐底层操作-httpsblogcsdnnetzhanghowarticledetails55262988)
- [13. 两个结构体类型的变量是否可以用memcmp函数比较](#13-两个结构体类型的变量是否可以用memcmp函数比较)
- [14. struct与class关键字区别](#14-struct与class关键字区别)
- [15. C语言中，空结构体的大小是多少？](#15-c语言中空结构体的大小是多少)
- [16. C++中空类的大小为 1byte的原因：](#16-c中空类的大小为-1byte的原因)
- [17. 函数重载底层是怎样实现的？](#17-函数重载底层是怎样实现的)
- [18. 介绍一下智能指针？](#18-介绍一下智能指针)
- [19. 拷贝构造函数，讲一下？](#19-拷贝构造函数讲一下)
- [20. const关键字怎么用？哪些场景用](#20-const关键字怎么用哪些场景用)
- [21. 常量指针和指针常量,分别怎么声明，怎么用？](#21-常量指针和指针常量分别怎么声明怎么用)
- [22. 讲一下对多态的理解。](#22-讲一下对多态的理解)
- [23. 虚函数实现机制](#23-虚函数实现机制)
- [24. 构造函数可以是虚函数吗？](#24-构造函数可以是虚函数吗)
- [25. 构造函数中能使用虚函数吗？](#25-构造函数中能使用虚函数吗)
- [26. 析构函数可以是虚函数吗？什么时候用到？](#26-析构函数可以是虚函数吗什么时候用到)
- [27. new申请的内存，free可以释放吗？](#27-new申请的内存free可以释放吗)
- [28. 类中const的用法，如何初始化？函数中加const，const修饰的是什么？](#28-类中const的用法如何初始化函数中加constconst修饰的是什么)
- [29. map底层实现红黑树和平衡二叉树的区别](#29-map底层实现红黑树和平衡二叉树的区别)
- [30. map和unordered\_map的区别？](#30-map和unordered_map的区别)
- [31. map插入有哪几种方法，insert方法的返回值](#31-map插入有哪几种方法insert方法的返回值)
- [32. 类中的列表初始化和函数体中初始化有什么区别？](#32-类中的列表初始化和函数体中初始化有什么区别)
- [33. 类的空指针调用成员函数会出现什么情况？怎么处理？](#33-类的空指针调用成员函数会出现什么情况怎么处理)
- [34. 局部变量和全局变量的区别？](#34-局部变量和全局变量的区别)
- [35. 全局变量未初始化时为什么随机值？](#35-全局变量未初始化时为什么随机值)
- [36. C++的虚函数指针是什么？多重继承虚函数表指针有几张？](#36-c的虚函数指针是什么多重继承虚函数表指针有几张)
- [37. 编程实现string类](#37-编程实现string类)
- [38. 用sizeof求类中用虚函数实现的方法和char \*p定义的变量时， 整个类的大小？](#38-用sizeof求类中用虚函数实现的方法和char-p定义的变量时-整个类的大小)
- [39. stl的vector的实现原理是什么，自动扩容的时候扩大多少倍？](#39-stl的vector的实现原理是什么自动扩容的时候扩大多少倍)
- [40. stl的map的实现原理是什么，如何给无序的map排序？](#40-stl的map的实现原理是什么如何给无序的map排序)
- [41. 如何快速定位一个大型c++项目的内存泄漏问题？](#41-如何快速定位一个大型c项目的内存泄漏问题)
- [42. 内存溢出解决](#42-内存溢出解决)
- [43. 缓冲溢出报警及解决](#43-缓冲溢出报警及解决)
- [44. 如何比较两个结构体是否相等](#44-如何比较两个结构体是否相等)
- [45. main函数执行前会做些什么工作？](#45-main函数执行前会做些什么工作)
- [46. main函数返回值意义及获取方式](#46-main函数返回值意义及获取方式)
- [47. C/C++中函数传递指针和传递引用的本质区别是什么呢？](#47-cc中函数传递指针和传递引用的本质区别是什么呢)
- [48. 讲一下迭代器生效的原因](#48-讲一下迭代器生效的原因)
- [49. define与inline函数的](#49-define与inline函数的)
- [50. C++11的特性](#50-c11的特性)
  - [50.1. auto 关键字](#501-auto-关键字)
  - [50.2. for-each 循环](#502-for-each-循环)
  - [50.3. 右值及移动构造函数](#503-右值及移动构造函数)
  - [50.4. std::forward](#504-stdforward)
  - [50.5. std::move](#505-stdmove)
  - [50.6. stl 容器新增的emplace\_back() 方法](#506-stl-容器新增的emplace_back-方法)
  - [50.7. std::thread 库](#507-stdthread-库)
  - [50.8. std::chrono 库](#508-stdchrono-库)
  - [50.9. 智能指针系列（std::shared\_ptr/std::unique\_ptr/std::weak\_ptr）(智能指针的实现原理一定要知道)](#509-智能指针系列stdshared_ptrstdunique_ptrstdweak_ptr智能指针的实现原理一定要知道)
  - [50.10. 线程库 std::thread 、线程同步技术库std::mutex/std::condition\_variable/std::lock\_guard 等](#5010-线程库-stdthread-线程同步技术库stdmutexstdcondition_variablestdlock_guard-等)
  - [50.11. lamda表达式](#5011-lamda表达式)
  - [50.12. std::bind/std::function 库](#5012-stdbindstdfunction-库)
  - [50.13. 一些关键字的用法(override、final、delete)](#5013-一些关键字的用法overridefinaldelete)
  - [50.14. hash算法的实现与Hash冲突](#5014-hash算法的实现与hash冲突)

<!-- /TOC -->
# 1. new和malloc的区别
malloc()函数
	• malloc的全称是memory allocation，中文叫动态内存分配。
	• 原型：extern void *malloc(unsigned int num_bytes);
	• 说明：分配长度为num_bytes字节的内存块。如果分配成功则返回指向被分配内存的指针，分配失败返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。
	• void *malloc(int size);
		○ 说明：malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void* 类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。
		○ 备注：void* 表示未确定类型的指针，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者...）

free()函数
	• 函数原型 void free(void *FirstByte)：
	•  该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。

1.4注意事项
	• 1）申请了内存空间后，必须检查是否分配成功。
	• 2）当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。
	• 3）这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。
	• 4）虽然malloc()函数的类型是(void *),任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。

malloc()到底从哪里得到了内存空间？
	• 答案：从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

 new运算符
2.1 C++中，用new和delete动态创建和释放数组或单个对象。动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。
int *pi=new int; 这个new表达式在堆区中分配创建了一个整型对象，并返回此对象的地址，并用该地址初始化指针pi 。

2.2 动态创建对象的初始化
	动态创建的对象可以用初始化变量的方式初始化。
	int *pi=new int(100); //指针pi所指向的对象初始化为100
	string *ps=new string(10,’9’);
	如果不提供显示初始化，对于类类型，用该类的默认构造函数初始化；而内置类型的对象则无初始化。
	也可以对动态创建的对象做值初始化：
	int *pi=new int( );//初始化为0
	int *pi=new int;//pi 指向一个没有初始化的int
	string *ps=new string( );//初始化为空字符串 （对于提供了默认构造函数的类类型，没有必要对其对象进行值初始化）

2.3 撤销动态创建的对象
	delete表达式释放指针指向的地址空间。
	delete pi ;// 释放单个对象
	delete [ ]pi;//释放数组
	如果指针指向的不是new分配的内存地址，则使用delete是不合法的。

2.4 在delete之后，重设指针的值
	delete p; //执行完该语句后，p变成了不确定的指针，在很多机器上，尽管p值没有明确定义，但仍然存放了它之前所指对象的地址，然后p所指向的内存已经被释放了，所以p不再有效。此时，该指针变成了悬垂指针（悬垂指针指向曾经存放对象的内存，但该对象已经不存在了）。悬垂指针往往导致程序错误，而且很难检测出来。一旦删除了指针所指的对象，立即将指针置为0，这样就非常清楚的指明指针不再指向任何对象。（零值指针：int *ip=0;）

2.5 区分零值指针和NULL指针
	零值指针，是值是0的指针，可以是任何一种指针类型，可以是通用变体类型void*也可以是char*，int*等等。
	空指针，其实空指针只是一种编程概念，就如一个容器可能有空和非空两种基本状态，而在非空时可能里面存储了一个数值是0，因此空指针是人为认为的指针不提供任何地址讯息。
参考：http://www.cnblogs.com/fly1988happy/archive/2012/04/16/2452021.html

2.6 new分配失败时，返回什么？
1993年前，c++一直要求在内存分配失败时operator   new要返回0，现在则是要求operator   new抛出std::bad_alloc异常。很多c++程序是在编译器开始支持新规范前写的。c++标准委员会不想放弃那些已有的遵循返回0规范的代码，所以他们提供了另外形式的operator   new(以及operator   new[])以继续提供返回0功能。这些形式被称为“无抛出”，因为他们没用过一个throw，而是在使用new的入口点采用了nothrow对象:
class   widget   {   ...   };
widget   *pw1   =   new   widget;//   分配失败抛出std::bad_alloc  
if   (pw1   ==   0)   ... //   这个检查一定失败
widget   *pw2   =   new   (nothrow)   widget;   //   若分配失败返回0
if   (pw2   ==   0)   ... //   这个检查可能会成功

3. malloc和new的区别
3.1 new 返回指定类型的指针，并且可以自动计算所需要大小。
	1) int *p;
	p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);
	或：
	int* parr;
	parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;
2) malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。 
	int* p;
	p = (int *) malloc (sizeof(int)*128);//分配128个（可根据实际需要替换该数值）整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中 
	double *pd=(double *) malloc (sizeof(double)*12);//分配12个double型存储单元，并将首地址存储到指针变量pd中
3.2 malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。除了分配及最后释放的方法不一样以外，通过malloc或new得到指针，在其它操作上保持一致。

4.有了malloc/free为什么还要new/delete？
	1) malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
	2) 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
	因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
	我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。
	3) 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
	如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。
来自 <https://www.cnblogs.com/fly1988happy/archive/2012/04/26/2470542.html> 



# 2. 讲一讲对extern、extern "C"的理解。
    • C/C++中使用extern声明的变量或函数，它们的作用域是全局的，告诉编译器使用该关键字声明的变量可以在本模块或其他模块中使用。只是声明了变量，但是并没有定义该变量。
    • extern "C" 的作用是为了能够正确在 C++ 代码中调用 C 语言代码。 加上 extern C 后指示编译器按 C 编译器编译这部分代码。使用它的本质的原因是 C++ 函数重载，C++ 中函数重载在编译后生成的不止是函数名，会带上参数类型，会改变函数的名称，而 C 编译器编译函数时不会带上函数的参数类型，函数的名称没有变。
    • 在混合编程中，如果我们不进行任何处理，而相互调用的话，在链接会出现找不到符号链接的情况。
    • extern "C"是C++的特性，是一种链接约定，通过它可以实现兼容C与C++之间的相互调用，即对调用函数能够达成一致的意见，使用统一的命名规则，使得实现方提供的接口和调用方需要的接口经按照指定规则编译后，得到的都是一致的函数符号命名。
    
# 3. Ｃ++与c互相调用问题
• C++中调用C函数：使用 extern "C" 关键字
• C如何调用C++函数：需要使用预处理宏和extern "C" 关键字
```cpp
    #ifdef __cplusplus
    extern "C"
    {
    #endif
    ……..
    ……..
    #ifdef __cplusplus
    }
    #endif
```

# 4. static关键字干嘛的，哪些场景用
• 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。其它的文件中可以调用该函数和变量。加了static关键字后，相当于做一个隐藏的作用，只对当前调用的文件有效。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

• static修饰的变量在函数体内定义时，表明它的申请的内存是驻留在全局区，直到程序运行结束。但是它作用域仍为局部作用域，只能在函数体内使用定义的该变量，不能在函数体外使用。因此可以得出一个结论：把局部变量改变为static变量后改变了它的生存期。把全局变量改变为static变量后是改变了它的作用域， 限制了它的使用范围，仅仅只在拥有该变量的文件中使用，不能在其它的文件中调用。
    
    
# 5. 说一下，一个函数在堆栈中是如何放置的，static变量，全局变量是放置在哪里？
内存四区：代码区、全局区（没有初始化.bss  初始化.data）、堆区、栈区
    
# 6. 讲一下sizeof()与strlen()的区别。 

# 7. 讲一下对malloc和new的理解。

# 8. 讲一下strcpy与memcpy的区别，讲一下strncpy与memcpy的区别。 

# 9. strncpy使用的注意事项
    • 是字符串之间进行拷贝的函数，不能用于复杂数据的结构类型。
    • src和dest所指内存区域不可以重叠，且dest必须有足够的空间来容纳src的字符长度+'\0'
    • strcpy只是复制字符串，但不限制复制的数量，很容易造成缓冲溢出。strncpy要安全一些。
    •  memcpy能够选择一段字符输出，strcpy复制全部的字符串。
    •  执行完strncpy()后，会覆盖原先dest字符数组中的数据。
    
# 10. 手写memcpy

# 11. 手 写strcpy或strncpy

# 12. struct结构体字节对齐？底层操作？ https://blog.csdn.net/zhanghow/article/details/55262988

# 13. 两个结构体类型的变量是否可以用memcmp函数比较 
    • 不能，memcmp是按照字节为单位进行比较的。由于结构体中有字节对齐的原因，导致结构体中会填充一些随机的数来保证字节对齐，因此两个结构体中的数据是不相等的。
    
# 14. struct与class关键字区别
    • 默认继承权限。如果不明确指定，class的继承按照private继承处理，struct的继承按照public继承处理；
    • 成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
    ```
    struct A
    {
        int i;          // 成员变量默认属性为public
        string s;       // string 类中成员变量的默认属性为private 
    };
    ```
    • class关键字可以用于定义模板参数，就像typename，但关键字struct不用于定义模板参数。
    • 在C语言中，struct体现的是一种数据类型的思想，不能定义函数，否则编译器会报错，在面向过程的编程中，数据和数据的操作是分开的。在C++中class体现的是面向对象封装的思想，数据和数据的操作在一起。
    • C++中struct可以定义函数，但是C语言中struct只可以定义函数指针。
    • C语言中sizeof( struct )，会计算定义的函数指针大小；C++中sizeof( struct ) 和 sizeof( class )都不会计算函数的大小，只会计算成员变量的大小。
    
# 15. C语言中，空结构体的大小是多少？
C语言中，空结构体的大小是0（编译器不一样，结果可能是1或0），而C++中空结构体（属于空类）的大小为1。

# 16. C++中空类的大小为 1byte的原因：
    • 空类中没有函数和数据成员，但可以实例化类；一个类能被实例化，编译器就要给他分配空间，来指示类实例化的地址，通常编译器分配为 1 个字节（char类型），这样分配同时也保证了 空类占用的空间最小。
    
# 17. 函数重载底层是怎样实现的？
    • 特点：函数名称相同时，根据函数参数的类型、个数不同而发生函数重载，函数的返回值不能作为判断函数重载的标准。
    • 底层实现
        § C++编译器在编译时，根据函数传入的参数列表进行重命名，改成便于区分的，避免了函数在调用时出现的二义性。在汇编代码中可以观察到函数名相同参数不同的函数，被改写成不同的函数名，即每个函数实现了自己的汇编代码。
        § C++利用name mangling(命名倾轧)技术，来改变函数名，区分参数不同的同名函数。
        § Name Mangling 是一种在编译过程中，将函数、变量的名称重新改编的机制。在 C++重载、namespace等操作符下，函数可以有同样的名字，编译器为了区分各个不同地方的函数，将各个函数通过编译器内定的算法，将函数改成唯一的名称。

# 18. 介绍一下智能指针？
    • shared_ptr
    • weak_ptr
    • unique_ptr
    • auto_ptr
    

# 19. 拷贝构造函数，讲一下？

# 20. const关键字怎么用？哪些场景用 

# 21. 常量指针和指针常量,分别怎么声明，怎么用？ 

# 22. 讲一下对多态的理解。
    • 多态实现的三要素：继承、虚函数、父类对象指向子类对象。
    • 虚函数表vptr

# 23. 虚函数实现机制
    • C++编译器提前布局了一个VPTR指针
    • C++编译器使用函数指针做函数参数
    
# 24. 构造函数可以是虚函数吗？
    • 不可以。
    • 构造对象的时候，必须知道对象的实际类型。而虚函数行为是在运行期间确定实际类型的，在构造对象的时，对象还没有构造成功，编译器无法知道对象的实际类型是该类本身还是其派生类。
    • 虚函数的运行依赖于虚函数指针，而虚函数指针在构造函数中进程初始化，让它指向正确的虚函数表，而在对象构造期间，虚函数指针还未构造完成。
    参考： https://www.zhihu.com/question/66905859/answer/887885656
    
# 25. 构造函数中能使用虚函数吗？ 
答：能用，但一般不这样用。因为在子类继承父类时，子类会先调用父类的构造函数，若构造函数中有虚函数，调用时父类的对象不会下降至子类的对象，子类中调用的对象还是隶属于父类的对象。换句话说，在构造函数中调用虚函数时，虚函数不在是虚函数了。

# 26. 析构函数可以是虚函数吗？什么时候用到？

可以；当用一个基类的指针删除子类的对象时，子类的析构函数都会被调用。
（1）如果父类的析构函数不加virtual关键字 
    当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 
（2）如果父类的析构函数加virtual关键字 
    当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。
只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。

# 27. new申请的内存，free可以释放吗？

# 28. 类中const的用法，如何初始化？函数中加const，const修饰的是什么？

# 29. map底层实现红黑树和平衡二叉树的区别

# 30. map和unordered_map的区别？
    •  C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)。
    •  unordered_set是基于哈希表。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。
    • 解决哈希函数中冲突的方法：开发地址法、再散列法、链地址法(也称拉链法)
    
    • C++ 11中对unordered_set描述大体如下：无序集合容器（unordered_set）是一个存储唯一(unique，即无重复）的关联容器（Associative container），容器中的元素无特别的秩序关系，该容器允许基于值的快速元素检索，同时也支持正向迭代。
    •  在一个unordered_set内部，元素不会按任何顺序排序，而是通过元素值的hash值将元素分组放置到各个槽(Bucker，也可以译为桶），这样就能通过元素值快速访问各个对应的元素（均摊耗时为O（1））。 原型中的Key代表要存储的类型，而hash<Key>也就是你的hash函数，equal_to<Key>用来判断两个元素是否相等，allocator<Key>是内存的分配策略。
    来自 <https://blog.csdn.net/Dream_you_to_life/article/details/46785741?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase%3E> 

# 31. map插入有哪几种方法，insert方法的返回值
    • 4种；
      // 四种map容器的插入方法
      map<int, string> mp;
      mp.insert(pair<int, string>(101, "赵云"));                   // 法一
      mp.insert(make_pair<int, string>(102, "关羽"));              // 法二
      mp.insert(map<int, string>::value_type(103, "曹操"));        // 发三
      mp[104] = "张飞";   
    • 返回值是pair数据对象
    
# 32. 类中的列表初始化和函数体中初始化有什么区别？
    • 函数体内初始化：先调用构造函数，再调用赋值运算，会带来额外的开销，效率比较低。
    • 列表初始化：直接调用构造函数，不会调用赋值函数，列表初始化先于函数体执行。

# 33. 类的空指针调用成员函数会出现什么情况？怎么处理？
    • 类的成员函数中调用了this 指针时，出现段错误；若没有调用this指针，则不会报错，
    • 当成员函数为静态函数时，可以调用成员函数。因为静态成员函数中没有this指针，静态成员独立于任何的对象。

# 34. 局部变量和全局变量的区别？

# 35. 全局变量未初始化时为什么随机值？

# 36. C++的虚函数指针是什么？多重继承虚函数表指针有几张？

# 37. 编程实现string类

# 38. 用sizeof求类中用虚函数实现的方法和char *p定义的变量时， 整个类的大小？
    • 虚函数中有vpr指针，计算大小时，整个类的大小为 vpr指针大小加上 char 指针的大小，指针的大小只与计算机的位宽有关。
# 39. stl的vector的实现原理是什么，自动扩容的时候扩大多少倍？
    1）采用动态数组实现的。先为数组开辟较小的空间，然后往数组里面添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL中 vector 每次扩容时，新的容量都是前一次的两倍），再把之前的数据复制到新的数组中，再把之前的内存释放。
    2）实际应用中采用vector比list、deque容器的效率高。因为不必为每个新添的元素分配容器，在内存中预留了额外的存储区（连续的内存块存储元素），用于存放新添的元素。
    3）大小：size=_Mylast - _Myfirst；
        容量：capacity=_Myend - _Myfirst；
    size表示vector中已有元素的个数，capacity表示vector最多可存储的元素的个数；
    • 为什么是两倍或1.5倍？
        § 根据不同的编译器，vector自动扩充的容量也不同，GCC编译器一般设置为 2 倍，VS编译器中一般采用的为1.5 倍
        § 使用这个扩容因子是时间复杂度和空间复杂度最优的结果。例如：迭代次数为n，扩容因子为m，使用push_back()运算花费的总时间为：m^1 + m^2 + ... m^(log_m(n))
                        
        因此每次扩容需要花费的时间为 m/(m-1) 是一个常量，扩容因子为m 太大或太小都影响内存的分配和时间的花费，最理想的因子为 m = 1.5，STL库中一般为 2
        参考： https://cs.stackexchange.com/questions/9380/why-is-push-back-in-c-vectors-constant-amortized?answertab=active#tab-top
        
# 40. stl的map的实现原理是什么，如何给无序的map排序？
    1）底层采用红黑树实现的。
    2）简单一种直接按照key或value值进行排序。对于复杂的类型，向map的insert中插入按指定的类型进行排序，用pair、make_pai类型的对象实现，传入的参数可以为基础类型，也可以为函数对象类型（包括自定义的函数类型或STL库中已有的函数类型）

# 41. 如何快速定位一个大型c++项目的内存泄漏问题？
    1）查看日志log
    2）Linux采用valgrind
    3）Windows下采用visual studio在debug在调用 _CrtDumpMemoryLeaks() 函数
    通过wrap malloc/free + backtrace + addr2line，你就可以定位到内存泄漏了。
    来自 <https://daydaynews.cc/zh-hans/technology/204786.html> 
    
# 42. 内存溢出解决 
    • 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
    • 内存泄露 memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
    • memory leak会最终会导致out of memory！
    内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 
    •  按照发生的方式来分类，内存泄漏可以分为4类： 
    1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 
    2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 
    3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 
    4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 
    从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 
    来自 <https://blog.csdn.net/buutterfly/article/details/6617375?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight> 
    
        § 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
        § 检查代码中是否有死循环或递归调用。
        § 检查是否有大循环重复产生新对象实体。
        § 检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。
    来自 <https://zhuanlan.zhihu.com/p/66765028> 
    
# 43. 缓冲溢出报警及解决 

# 44. 如何比较两个结构体是否相等 
    C：用指针地址比较，形如a==b
    C++：memcmp()函数逐个字节进行比较的，而struct存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较，需要重载==操作运算符。
    来自 <https://blog.csdn.net/lizhentao0707/article/details/80888501> 

# 45. main函数执行前会做些什么工作？ 

# 46. main函数返回值意义及获取方式 
    C/C++中，应将main函数写成 int main() { return 0;},返回值是int类型；而不应该写成void main(){}; 函数没有返回值，有些编译器器可能会报错。如果返回0，则代表程序正常退出，返回其它数字的含义则由系统决定，通常，返回非零代表程序异常退出。
    来自 <https://blog.csdn.net/piaojun_pj/article/details/5986516> 
    
# 47. C/C++中函数传递指针和传递引用的本质区别是什么呢？
    • 指针本质存放的是一个变量地址，它可以改变，包括指针指向的地址、指针指向地址的数据都可以改变。
    • 引用是一个别名，必须在一开始就要被初始化，引用的对象在其整个生命周期中是不能被改变的。在C++中，指针和引用经常用于函数的参数传递。
    • 编译器的角度：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
    • 相同点：
        § 都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
    • 不同点：
        § 指针是一个实体，而引用仅是个别名；
        § 引用只能在定义时被初始化一次，之后不可变；指针可变。
        § 引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）
        § 引用不能为空，指针可以为空；
        § “sizeof （引用）”得到的是所指向的变量(对象)的大小，而“sizeof （指针）”得到的是指针本身的大小；
        § 指针和引用的自增(++)运算意义不一样；
        § 引用是类型安全的，而指针不是 ，引用比指针多了类型检查。
    来自 <https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html> 
    
    地址就是一种指针，而指针是地址的另一种形式，两者之间是互通的。
    

    • 
    reference就是一种漂亮的pointer。
# 48. 讲一下迭代器生效的原因

# 49. define与inline函数的
1.宏（#define）和内联函数（inline）的理解以及区别：
宏
缺点：
1.宏没有类型检测，不安全
2.宏是在预处理时进行简单文本替换，并不是简单的参数传递（很难处理一些特定情况。例如：Add(z++)）
3.使代码变长
4.宏不能进行调试
5.当预处理搜索#define定义的符号时，字符串常量并不被搜索

优点：
1.加快了代码的运行效率
2.让代码变得更加的通用

内联函数
类中的成员函数是默认的内联函数
内联函数内不准许有循环语句和开关语句
内联函数的定义必须出现在第一次调用内联函数之前

缺点：代码变长，占用更多内存
优点：
1.有类型检测，更加的安全
2.内联函数是在程序运行时展开，而且是进行的是参数传递
3.编译器可以检测定义的内联函数是否满足要求，如果不满足就会当作普通函数调用（内联函数不能递归，内联函数不能太大）

对比
相同点：
两者都是可以加快程序运行效率，使代码变得更加通用

不同点：
1.内联函数的调用是传参，宏定义只是简单的文本替换
2.内联函数可以在程序运行时调用，宏定义是在程序编译进行
3.内联函数有类型检测更加的安全，宏定义没有类型检测
4.内联函数在运行时可调式，宏定义不可以
5.内联函数可以访问类的成员变量，宏不可以
6.类中的成员函数是默认的内联函数

# 50. C++11的特性
## 50.1. auto 关键字
## 50.2. for-each 循环
## 50.3. 右值及移动构造函数 
## 50.4. std::forward
## 50.5. std::move 
## 50.6. stl 容器新增的emplace_back() 方法
## 50.7. std::thread 库
## 50.8. std::chrono 库
## 50.9. 智能指针系列（std::shared_ptr/std::unique_ptr/std::weak_ptr）(智能指针的实现原理一定要知道)
## 50.10. 线程库 std::thread 、线程同步技术库std::mutex/std::condition_variable/std::lock_guard 等
## 50.11. lamda表达式
## 50.12. std::bind/std::function 库
## 50.13. 一些关键字的用法(override、final、delete)
## 50.14. hash算法的实现与Hash冲突
    




