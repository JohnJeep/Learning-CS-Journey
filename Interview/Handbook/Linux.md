<!--
 * @Author: JohnJeep
 * @Date: 2021-04-08 21:38:44
 * @LastEditTime: 2025-11-17 09:17:51
 * @LastEditors: JohnJeep
 * @Description: Linux 基础面试
-->

<!-- TOC -->

- [1. gdb调试：如何检查程序出现bug](#1-gdb调试如何检查程序出现bug)
- [2. pthread\_detach的作用](#2-pthread_detach的作用)
- [3. 问了pthread\_join和pthread\_detach两个函数的功能](#3-问了pthread_join和pthread_detach两个函数的功能)
- [4. 进程如何回收 ？](#4-进程如何回收-)
- [5. 僵尸进程和孤儿进程](#5-僵尸进程和孤儿进程)
- [6. 进程同步的方法？用过哪几种？](#6-进程同步的方法用过哪几种)
- [7. 进程同步里共享内存的底层实现？](#7-进程同步里共享内存的底层实现)
- [8. 网络编程了解么？服务端的socket过程是什么？](#8-网络编程了解么服务端的socket过程是什么)
- [9. 熟悉windows还是linux？既然熟悉windows，windows下进程同步编程做过么，说说。](#9-熟悉windows还是linux既然熟悉windowswindows下进程同步编程做过么说说)
- [10. 讲一下进程之间的通信方式。](#10-讲一下进程之间的通信方式)
- [11. 线程锁（说了自旋锁，信号量，解释了下cas，顺序锁和实现）](#11-线程锁说了自旋锁信号量解释了下cas顺序锁和实现)
- [12. 什么时候选用自旋锁，什么时候用信号量（io密集型用自旋，cpu密集型操作用信号量）](#12-什么时候选用自旋锁什么时候用信号量io密集型用自旋cpu密集型操作用信号量)
- [13. 父进程如何回收子进程](#13-父进程如何回收子进程)
- [14. 多线程编程的一些函数join，detach作用](#14-多线程编程的一些函数joindetach作用)
- [15. 线程阻塞，他是怎么阻塞的，怎么从阻塞态到运行态的](#15-线程阻塞他是怎么阻塞的怎么从阻塞态到运行态的)
- [16. 进程通信 方式，哪个效率高](#16-进程通信-方式哪个效率高)
- [17. 管道 通信原理？（没弄清问题，就把知道的一点相关的全说了）](#17-管道-通信原理没弄清问题就把知道的一点相关的全说了)
- [18. 有两个进程，有同名变量，这个变量是共享的吗？如果是动态库呢？](#18-有两个进程有同名变量这个变量是共享的吗如果是动态库呢)
- [19. 如何查看耗时最大的函数？使用什么工具？](#19-如何查看耗时最大的函数使用什么工具)
- [20. 两个进程要通信，什么样的方式最快？](#20-两个进程要通信什么样的方式最快)
- [21. 父进程使用malloc得到一块内存，子进程可以使用吗？](#21-父进程使用malloc得到一块内存子进程可以使用吗)
- [22. 进程使用malloc分配一块M的内存，是马上就得到这块内存了吗？](#22-进程使用malloc分配一块m的内存是马上就得到这块内存了吗)
- [23.  有一个进程突然卡死了，你是怎么定位这个问题的？](#23--有一个进程突然卡死了你是怎么定位这个问题的)
- [24. 怎么查看CPU的占用情况？](#24-怎么查看cpu的占用情况)
- [25. 某一个线程占用很大的内存，怎么解决？](#25-某一个线程占用很大的内存怎么解决)
- [26. Linux下， 获取文件大小（文件可能很大，很小），接口函数使用](#26-linux下-获取文件大小文件可能很大很小接口函数使用)
- [27. 写过守护进程吗？写过demo吗？](#27-写过守护进程吗写过demo吗)
- [28. 问了一下项目中的线程池是怎么实现的](#28-问了一下项目中的线程池是怎么实现的)
- [29. 正在运行的代码，出现性能瓶颈怎么排查（strace等工具）](#29-正在运行的代码出现性能瓶颈怎么排查strace等工具)
- [30. 系统调用与函数调用](#30-系统调用与函数调用)
- [31. linux信号有哪些](#31-linux信号有哪些)
- [32. 可重入函数，线程安全](#32-可重入函数线程安全)
- [33. 阻塞与非阻塞](#33-阻塞与非阻塞)
- [34. 可变参数函数的定义及实现](#34-可变参数函数的定义及实现)
- [35. 简单说一下进程和线程的区别](#35-简单说一下进程和线程的区别)
- [36. 内存的分页和分段](#36-内存的分页和分段)
- [37. 操作系统之内存管理](#37-操作系统之内存管理)
- [38.  多线程的同步有哪几种方式？多进程之间的通信方式呢？](#38--多线程的同步有哪几种方式多进程之间的通信方式呢)
- [39.  如何避免死锁？](#39--如何避免死锁)
  - [39.1.  产生死锁的条件](#391--产生死锁的条件)
  - [39.2. 怎样阻止死锁的发生？](#392-怎样阻止死锁的发生)
- [40. 多线程的实现、线程池、消息队列、套](#40-多线程的实现线程池消息队列套)

<!-- /TOC -->


# 1. gdb调试：如何检查程序出现bug
# 2. pthread_detach的作用 
    ○ int pthread_detach(pthread_t tid);
    ○ pthread_detach()即主线程与子线程分离，子线程结束后，资源自动回收。pthread_join()即是子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。
# 3. 问了pthread_join和pthread_detach两个函数的功能
    pthread_join：回收子线程的资源，线程没有结束，会一直阻塞等待。
    pthread_detach：将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源
# 4. 进程如何回收 ？
调用 wait() 函数
`pid_t wait(int *wstatus);`


# 5. 僵尸进程和孤儿进程
# 6. 进程同步的方法？用过哪几种？ 
# 7. 进程同步里共享内存的底层实现？ 
# 8. 网络编程了解么？服务端的socket过程是什么？
# 9. 熟悉windows还是linux？既然熟悉windows，windows下进程同步编程做过么，说说。 
# 10. 讲一下进程之间的通信方式。 
# 11. 线程锁（说了自旋锁，信号量，解释了下cas，顺序锁和实现）
# 12. 什么时候选用自旋锁，什么时候用信号量（io密集型用自旋，cpu密集型操作用信号量）
# 13. 父进程如何回收子进程
# 14. 多线程编程的一些函数join，detach作用 
# 15. 线程阻塞，他是怎么阻塞的，怎么从阻塞态到运行态的
# 16. 进程通信 方式，哪个效率高
# 17. 管道 通信原理？（没弄清问题，就把知道的一点相关的全说了）
# 18. 有两个进程，有同名变量，这个变量是共享的吗？如果是动态库呢？
# 19. 如何查看耗时最大的函数？使用什么工具？
# 20. 两个进程要通信，什么样的方式最快？
# 21. 父进程使用malloc得到一块内存，子进程可以使用吗？
# 22. 进程使用malloc分配一块M的内存，是马上就得到这块内存了吗？


# 23. <font color=red> 有一个进程突然卡死了，你是怎么定位这个问题的？</font>
○ 判断是否是IO超时或者其它调度的问题。需要在这个进程出现卡死或超时，获取当时的调用栈信息，通过调用栈信息来分析可能的原因。可以使用 `pstack` 来查看线程的堆栈信息。

（1）如系统存在运行日志，首先分析日志信息。
（2）利用 `pstack` 工具打印出此时系统的存在线程堆栈快照。
（3）有些阻塞栈可能是因为它需要等待前面的线程执行结束才可以执行，所以要先确定依赖关系。
（4）若问题可以复现，可以利用gdb调试系统，但若不确定问题是否可以复现，则推荐不要使用gdb，
 因为会破坏问题产生的环境，gdb在一定程度上会影响系统运行导致卡住的因素由成立变成不成立。

来自 <https://www.cnblogs.com/LyndonYoung/articles/7364165.html> 
来自 <https://www.cnblogs.com/xingmuxin/p/9712113.html> 
    
# 24. 怎么查看CPU的占用情况？
top命令
    
    
# 25. 某一个线程占用很大的内存，怎么解决？

# 26. Linux下， 获取文件大小（文件可能很大，很小），接口函数使用
    ○ lseek()函数：文件偏移量
    
# 27. 写过守护进程吗？写过demo吗？
```c
void create_daemon()
{
    int fd;
    pid_t pid, sid;
    // 1、创建子进程，父进程退出
    pid = fork();
    if (pid == -1){
        perror("fork error.\n");
        exit(1);
    }
    if (pid > 0){
        exit(1);
    }
    // 2、子进程创建会话、
    sid = setsid();
    if ((sid == -1) ){
        perror("setsid error.\n");
        exit(1);
    }
    // 3、改变当前目录为根目录
    fd = chdir("/home/steve");
    if (fd == -1) {
        perror("chdir error.\n");
        exit(1);
    }
    // 4、重设文件权限掩码
    umask(0022);
    // 5、关闭重定向文件描述符
    close(STDIN_FILENO);
    open("/dev/null", O_RDWR);
    dup2(0, STDOUT_FILENO);
    dup2(0, STDERR_FILENO);
}
```


# 28. 问了一下项目中的线程池是怎么实现的


# 29. 正在运行的代码，出现性能瓶颈怎么排查（strace等工具）

# 30. 系统调用与函数调用 
Linux下对文件操作有两种方式：系统调用(system call)和库函数调用(Library functions)。系统调用实际上就是指最底层的一个调用，在linux程序设计里面就是底层调用的意思。面向的是硬件。而库函数调用则面向的是应用开发的，相当于应用程序的api,采用这样的方式有很多种原因，第一：双缓冲技术的实现。第二，可移植性。第三，底层调用本身的一些性能方面的缺陷。第四：让api也可以有了级别和专门的工作面向。 


# 31. linux信号有哪些 
常用信号
信号    值    动作解释 
SIGHUP    1    终端线路挂断 
SIGINT    2    Term键盘输入的中断命令，从终端输入 Ctrl-C 时发生 
SIGQUIT    3    Core键盘输入的退出命令 
SIGILL    4    Core错误指令 
SIGABRT    6    Coreabort(3)发出的中止信号 
SIGFPE    8    Core浮点数异常 
SIGKILL    9    TermKILL信号 
SIGSEGV    11    Core非法内存访问 
SIGPIPE    13    Term管道断开 
SIGALRM    14    Termalarm(2)发出的中止信号 
SIGTERM    15    Term强制中止信号 
SIGUSR    130,10,16    Term用户自定义信号1 
SIGUSR    231,12,17    Term用户自定义信号2 
SIGCHLD    20,17,18    Ign子进程中止信号 
SIGCONT    19,18,25    Cont继续执行一个停止的进程 
SIGSTOP    17,19,23    Stop非终端来的停止信号 
SIGTSTP    18,20,24    Stop终端来的停止信号 
SIGTTIN    21,21,26    Stop后台进程读终端 
SIGTTOU    22,22,27    Stop后台进程写终端 

# 32. 可重入函数，线程安全 
主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。 
也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。 


# 33. 阻塞与非阻塞 
阻塞是指在函数执行时如果条件不满足,程序将永远停在那条函数那里不在往下执行,而非阻塞则是函数不管条件是否满足都会往下执行. 


# 34. 可变参数函数的定义及实现 
通常我们使用的C函数的参数个数都是固定的，但也有不固定的，参数个数由使用者确定的即可变参数函数

# 35. 简单说一下进程和线程的区别

# 36. 内存的分页和分段
# 37. 操作系统之内存管理


# 38. <font color=red> 多线程的同步有哪几种方式？多进程之间的通信方式呢？</font>
○ 多进程通信
1. 管道（最简单）
2. 信号（开销最小）
3. 共享映射区（无血缘关系）
4. 本地套接字（最稳定）    
5. 消息队列
6. 信号量(semaphore)


○ 线程之间同步方式

线程之间通信的目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

1. 锁机制
   - 互斥锁：确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。
   - 读写锁：当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
   - 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
   - 自旋锁：上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

2. 唤醒/等待(wait/notify)
3. 信号量机制(Semaphore)：可以跨进程，始终代表可用资源数量，当资源数为o时，线程阻塞，允许多个线程同时访问一个共享资源
4. 信号机制(Signal)
5. violate全局变量-共享内存

- 参考
  - [进程间通信和线程间通信总结](https://blog.csdn.net/J080624/article/details/87454764)     


# 39. <font color=red> 如何避免死锁？</font>
1、按顺序加锁。线程间加锁的顺序各不一致，导致死锁，如果每个线程都按同一个的加锁顺序这样就不会出现死锁。

2、获取锁时限。获取每个锁持有的时间上限，如果超过某个时间就放弃获取锁的。

3、死锁检测。按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。

## 39.1. <font color=red> 产生死锁的条件</font>

死锁的产生需要下面 4 个条件。
- 互斥(Mutual exclusion)：线程对需要的资源进行互斥的访问。
- 持有和等待(Hold-and-wait)：线程持有资源（持有得到的锁），同时又在等待其它资源（希望获得锁）
- 非抢占(No preemption)：线程获得的资源（锁）不能被抢占。
- 循环等待(Circular wait)：线程之间存在一个环路，环路上每个线程都持有一个或多个资源（locks），而这个资源又是下一个线程要申请的（requested）。

> 上述 4 个条件中的任何一个没有满足，死锁（deadlock）都不会发生。 


## 39.2. 怎样阻止死锁的发生？
- 不产生循环等待（ never induce a circular wait）。
  - 简单的系统中采取 `全序（total ordering）` 方式解决。
  - 复杂的系统采取 `偏序（partial ordering ）` 方式解决。
  > 技巧：可以通过获取锁的地址来获取锁的顺序（lock ordering）。
  
- 锁在持有和等待时，通过原子性的方式避免。
  - 这种方式不能适用与封装（encapsulation），需要准确的知道要持有（held）哪些琐，并且要提前获得（acquire）。 采取这种方式降低了并发。
  
- 其它的线程获得锁之前，先释放之前得到的锁。
  - 实现过程中可能会产生活锁（livelock）问题
    - 两个线程可能一直重复地释放锁，又同时都获得锁失败，系统一直的在运行，但不会有任何的进展。
  - 如何解决活锁问题？
    - 在循环结束的时候，先随机等待一个时间，再次重复整个过程，这样可以降低线程之间重复干扰的几率。

- 完全避免互斥。代码存放在临界区（critical sections），通常很难避免互斥。需要结合硬件指令，构造出不要锁的数据结构。

- 通过检查和恢复（Detect and Recover）的方法。允许死锁偶尔发生，检查到死锁时再采取行动。



# 40. 多线程的实现、线程池、消息队列、套
    
