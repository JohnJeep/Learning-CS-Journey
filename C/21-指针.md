参考
- [关于指针类型和指针类型转换的理解](https://www.cnblogs.com/chanabi/p/9228998.html)
- [C语言再学习 -- 再论数组和指针](https://blog.csdn.net/qq_29350001/article/details/54599196)


#### 概念
- 地址：一片内存中，每个字节（Byte）的编号
- `地址，字节，位`他们在内存中的关系：
    > 内存是一栋大楼，字节（Byte）是大楼中的每一层，地址是楼层编号，位（bit）是每一层中的房间，每一层有8个房间。
- 变量内存：在内存中申请一块空间，该空间由多个字节组成
- 指针：是一种数据类型，是指它指向的内存空间的数据类型。（程序数据在内存中的地址）。在c语言当中，允许用一个变量来存放指针，这种变量称为指针变量。
- 不管是什么类型的指针变量，所存的值都是地址（int类型的值）。那么声明不同类型的作用是什么？
  > 答案：==通过声明指针类型，告诉指针每次移动多少字节，来获取变量的值。==


##### 定义
- 指针定义：` 数据类型 *指针变量名; `
  - 符号` * `是定义指针变量的标志， 不是变量名的一部分
  - 表示指针变量指向的数据类型；`int *P`：表示指针变量指向int的数据类型
  - `指针变量名`：表示指向另一个数据地址的变量，本质是一个地址变量。
  - `*指针变量名`：表示指向另一个数据地址里面的值，本质是一个数据值变量。
  - ` * `：取内容运算符；取出指针变量所指向地址的内容
  - ` & `：取地址运算符；获取变量在计算机内存中的存储地址。取地址运算符的操作对象（变量）一定是定义过的变量或数组元素。 
 

##### 指针关键注意点
- 定义指针时，编译器并不为指针所指向的对象分配空间，它只是分配指针本身的空间，除非在定义时同时赋值给指针一个字符串常量进行初始化。
- ==定义时不能为常量分配空间。== 例如：`float *p = 3.14;` 会导致编译不通过。
- 保存数据的地址，任何存入指针变量p 的数据都会被当作地址来处理。 p 本身的地址由编译器另外存储，存储在哪里，我们并不知道。
- `*`放在`=`的左边，给内存赋值，读内存；`int *p = 10;`
- `*`放在`=`的右边，取内存的值，往内存写；`int q = *p;`
- 指针变量与它指向的内存块是两个不同的概念
- 不允许向NULL和非法地址拷贝内存。
  - `char *p = NULL; strcpy(p, "abcdef");`  会出错，空指针p不指向任何对象或函数。
  - `char *p = 0x1234; strcpy(p, "abcdef");` 也出错，指针p没有指向一个内存地址。
- 向内存中写数据时，要保证指针所指向的内存块能修改。
  - `char buf[] = "abcdef"; buf[2] = 2;` 可以修改buf[2]的值，数组中的一般变量存放在内存的栈区。
  - `char *buf = "abcdef"; buf[2] = 2;` 不可以修改，*buf定义的变量存放在数据区。


- 空指针：定义一个指针变量后，没有指向一个确定的值。
  - 例如：`int* p=NULL;` 指针p为一个空指针。
  - C语言中使用宏NULL表示空指针常量：`#define  NULL  ((void *)0)`
  - 系统保证空指针不指向任何对象或函数。


- 初始化：` 数据类型 *指针变量名=内存地址； ` 
  - “内存地址”是地址常量或对变量取地址的运算表达式。 
  

##### 应用
- 指针为形参，作为函数的参数，给变量间接赋值。（实际中应用很多）
- 通过形参来改变实参的内容，必须地址传递


