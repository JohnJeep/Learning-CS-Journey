<!--
 * @Author: JohnJeep
 * @Date: 2019-09-20 15:05:29
 * @LastEditTime: 2025-11-13 20:32:48
 * @LastEditors: JohnJeep
 * @Description: 深入理解指针
--> 

# 1. 概念

- 地址：一片内存中，每个字节（Byte）的编号
- address, byte, bit 他们在内存中的关系：
    > 内存是一栋大楼，字节（Byte）是大楼中的每一层，地址是楼层编号，位（bit）是每一层中的房间，每一层有8个房间。
- 变量内存：在内存中申请一块空间，该空间由多个字节组成
- 指针：是一种数据类型，是指它指向的内存空间的数据类型。（程序数据在内存中的地址）。在c语言当中，允许用一个变量来存放指针，这种变量称为指针变量。
- 不管是什么类型的指针变量，所存的值都是地址（int类型的值）。那么声明不同类型的作用是什么？
  > 答案：通过声明指针类型，告诉指针每次移动多少字节，来获取变量的值。


# 2. 定义

指针定义：` 数据类型 *指针变量名; `
- 符号` * `是定义指针变量的标志， 不是变量名的一部分
- 表示指针变量指向的数据类型。例如：`int *P` 表示指针变量指向int的数据类型
- `指针变量名`：表示指向另一个数据地址的变量，本质是一个地址变量。
- `*指针变量名`：表示指向另一个数据地址里面的值，本质是一个数据值变量。
- ` * `：取内容运算符；取出指针变量所指向地址的内容
- ` & `：取地址运算符；获取变量在计算机内存中的存储地址。取地址运算符的操作对象（变量）一定是定义过的变量或数组元素。 

# 3. 指针关键注意点

- 定义指针时，编译器并不为指针所指向的对象分配空间，它只是分配指针本身的空间，除非在定义时同时赋值给指针一个字符串常量进行初始化。
- 定义时不能为常量分配空间。例如：`float *p = 3.14;` 会导致编译不通过。
- 保存数据的地址，任何存入指针变量p 的数据都会被当作地址来处理。 p 本身的地址由编译器另外存储，存储在哪里，我们并不知道。
- `*` 放在 `=` 的左边，给内存赋值，读内存；`int *p = 10;`
- `*` 放在 `=` 的右边，取内存的值，往内存写；`int q = *p;`
- 指针变量与它指向的内存块是两个不同的概念
- 不允许向NULL和非法地址拷贝内存。
  - `char *p = NULL; strcpy(p, "abcdef");`  会出错，空指针p不指向任何对象或函数。
  - `char *p = 0x1234; strcpy(p, "abcdef");` 也出错，指针p没有指向一个内存地址。
- 向内存中写数据时，要保证指针所指向的内存块能修改。
  - `char buf[] = "abcdef"; buf[2] = 2;` 可以修改buf[2]的值，数组中的一般变量存放在内存的栈区。
  - `char *buf = "abcdef"; buf[2] = 2;` 不可以修改，*buf定义的变量存放在数据区。
- 空指针：定义一个指针变量后，没有指向一个确定的值。
  - 例如：`int* p = NULL;` 指针p为一个空指针。
  - C语言中使用宏NULL表示空指针常量：`#define  NULL  ((void *)0)`
  - 系统保证空指针不指向任何对象或函数。
- 初始化：` 数据类型 *指针变量名=内存地址； ` 
  - “内存地址”是地址常量或对变量取地址的运算表达式。 

# 4. 初始化

## 4.1. 堆 上分配

在C++中，堆(heap)上分配内存，用 `new` 运算符有两种初始化方式：

### 4.1.1. 直接初始化（使用圆括号 `()`）

C++的语法规定：当使用new分配单个对象时，可以使用括号传递初始值。

```cpp
 // 为单个对象分配内存并进行初始化
int* ptr = new int(100); // 分配一个int，初始值为 100
```

对于数组，我们通常使用大括号进行初始化，例如C++11以后可以这样写：`new int[200]{1,2,3,...}`，但注意，在C++11之前，数组的初始化不能直接使用括号，而是只能默认初始化或使用循环赋值。

### 4.1.2. 默认初始化（不使用括号）

```cpp
// 为单个对象分配内存，但不进行显式初始化
int* p = new int;          // 值未定义（可能是任意值）
double* d = new double;    // 值未定义

p = 100; // 赋值
```

### 4.1.3. 为什么这样设计？

这种语法设计是为了与**构造函数调用**保持一致：

```cpp
// 对于内置类型
int* p1 = new int(200);    // 类似于 int x(200);

// 对于类类型
class MyClass {
public:
    MyClass(int value) { /* ... */ }
};

MyClass* obj = new MyClass(100);  // 调用构造函数 MyClass(100)
```

### 4.1.4. 与数组分配的区别

**重要**：这种括号初始化语法**只适用于单个对象**，不适用于数组：

```cpp
// 正确 - 单个对象
int* p = new int(200);

// 错误 - 不能这样初始化数组
// int* arr = new int[200](100);  // 编译错误！

// 正确初始化数组的方式（C++11以后）
int* arr = new int[200]{100};  // 第一个元素为100，其余为0
```

### 4.1.5. 历史背景

这种语法一致性来自于C++的哲学："用户定义类型应该与内置类型一样好用"。既然我们可以这样写：

```cpp
// 栈上分配
int x(200);           // 直接初始化
MyClass obj(100);     // 调用构造函数

// 那么堆上分配也应该类似
int* p = new int(200);      // 直接初始化
MyClass* obj = new MyClass(100);  // 调用构造函数
```

### 4.1.6. 实际应用实例

```cpp
#include <iostream>
using namespace std;

int main() {
    // 各种初始化方式
    int* uninitialized = new int;           // 值未定义
    int* zero = new int();                  // 值初始化为0 (C++特性)
    int* with_value = new int(200);         // 初始化为200
    
    cout << "未初始化: " << *uninitialized << endl;  // 随机值
    cout << "零初始化: " << *zero << endl;           // 输出0
    cout << "指定值: " << *with_value << endl;       // 输出200
    
    delete uninitialized;
    delete zero;
    delete with_value;
    
    return 0;
}
```



## 4.2. 栈上分配

### 4.2.1. 指向栈上变量（最常见）

```cpp
int main() {
    int x = 100;           // 栈上分配的整型变量
    int* ptr = &x;         // 指针指向栈上的变量x
    
    cout << *ptr << endl;  // 输出100
    // 不需要手动释放，main函数结束时x和ptr自动销毁
}
```

### 4.2.2. 指向其他指针

```cpp
int main() {
    int x = 100;
    int* ptr1 = &x;
    int* ptr2 = ptr1;      // ptr2也指向x
    
    cout << *ptr2 << endl; // 输出100
}
```

### 4.2.3. 指向数组（栈上数组）

```cpp
int main() {
    int arr[5] = {1, 2, 3, 4, 5};  // 栈上数组
    int* ptr = arr;                 // 指向数组首元素
    
    for(int i = 0; i < 5; i++) {
        cout << ptr[i] << " ";      // 输出1 2 3 4 5
    }
}
```

### 4.2.4. 指向字符串常量

```cpp
int main() {
    const char* str = "Hello World";  // 指向字符串常量
    cout << str << endl;              // 输出Hello World
}
```

### 4.2.5. 空指针或野指针

```cpp
int main() {
    int* ptr1 = nullptr;    // 空指针（推荐）
    int* ptr2 = NULL;       // 空指针（传统C风格）
    int* ptr3;              // 未初始化，野指针（危险！）
}
```

## 4.3. 静态存储区

指针指向全局区

```cpp
int global_var = 100;

int main() {
    int *p = &global_var;   // p指向全局变量global_var

    // 使用p

    // 不需要手动释放，因为global_var的生命周期是整个程序

    return 0;
}
```

## 4.4. 总结

- 栈上分配：使用已有栈变量的地址初始化指针，无需手动释放。
- 堆上分配：使用new初始化指针，必须使用delete释放。
- 静态存储区：使用全局变量或静态变量的地址初始化指针，无需手动释放。

# 5. 应用

- 指针为形参，作为函数的参数，给变量间接赋值。
- 通过形参来改变实参的内容，必须地址传递

# 6. Wild Pointer(野指针)

## 6.1. 什么是野指针

**定义**：未被初始化或指向未知内存地址的指针。

- 野指针通常指的是未被初始化的指针。也就是说，这个指针变量被声明了，但没有被赋予一个明确的地址值。它可能指向任意内存地址，可能是随机的、不确定的。

- 使用野指针会导致未定义行为，因为它可能指向不可访问的内存区域（如系统保护区），或者意外地修改了其他重要数据。

  ```cpp
  // 示例1：未初始化的指针
  int* wildPtr;  // 野指针 - 指向随机内存地址
  *wildPtr = 10; // 未定义行为！
  
  // 示例2：指向已释放内存但未置空的指针
  int* ptr = new int(5);
  delete ptr;    // 内存已被释放
  *ptr = 10;     // 野指针 - 访问已释放内存
  ```

## 6.2. 产生的原因

- 指针指向了一块没有访问权限的内存。（即指针没有初始化）
- 指针被 free 或者 delete 之后，没有置为 `nullptr`。
- 指针操作超越了变量的作用围。

## 6.3. 如何避免野指针

- 将指针初始化为  `nullptr`。 
- 用已有合法的可访问的内存地址对指针初始化
  ```c
  char num[ 30] = {0};
  char *p = num;
  ```
- 使用malloc分配内存。（在堆空间内分配）分配后要进行检查是否分配成功，最后要进行释放内存。malloc函数分配完内存后需注意：
  - 检查是否分配成功（若分配成功，返回内存的首地址；分配不成功，返回NULL。可以通过if语句来判断）
  - 清空内存中的数据（malloc分配的空间里可能存在垃圾值，用memset或bzero 函数清空内存）     

# 7. Dangling Pointer(悬挂指针)

**定义**：指向曾经有效但现在已经失效的内存地址的指针。

```cpp
// 示例1：指向局部变量的指针
int* createDanglingPointer() {
    int localVar = 42;
    return &localVar;  // 返回局部变量的地址
} // localVar 生命周期结束

int* danglingPtr = createDanglingPointer();
// danglingPtr 现在是指向已销毁对象的悬挂指针

// 示例2：多个指针指向同一内存
int* ptr1 = new int(100);
int* ptr2 = ptr1;      // ptr2 也指向同一内存

delete ptr1;           // 释放内存
// 现在 ptr1 和 ptr2 都成为悬挂指针
```

**特点**：

- 曾经指向有效的内存地址
- 由于对象生命周期结束或内存被释放而失效
- 访问会导致未定义行为

## 7.1. 如何应对悬挂指针？

```cpp
// 1. 总是初始化指针
int* ptr = nullptr;  // 而不是 int* ptr;

// 2. 释放内存后立即置空
delete ptr;
ptr = nullptr;

// 3. 避免返回局部变量的地址
int* safeFunction() {
    static int value = 42;  // 静态变量或动态分配
    return &value;
}

// 4. 使用智能指针（推荐）
#include <memory>
std::shared_ptr<int> smartPtr = std::make_shared<int>(42);
// 自动管理生命周期，避免悬挂指针

// 5. 谨慎使用指针别名
int* ptr1 = new int(100);
int* ptr2 = ptr1;
delete ptr1;
ptr1 = nullptr;
// 注意：ptr2 仍然是悬挂指针！
```



# 8. 零值指针和 NULL 指针的区别

- 零值指针，是值为 0 的指针，可以是任何一种指针类型，可以是通用变体类型 void* 也可以是 char*，int*等。
- 空指针，其实空指针只是一种编程概念，就如一个容器可能有空和非空两种基本状态，而在非空时可能里面存储了一个数值是 0，因此空指针是人为认为的指针不提供任何地址讯息。

