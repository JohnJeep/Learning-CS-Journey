<!--
 * @Author: JohnJeep
 * @Date: 2019-07-28 21:54:53
 * @LastEditTime: 2020-06-13 11:57:08
 * @LastEditors: your name
 * @Description: 段错误问题
 * @FilePath: /C/7-段错误.md
--> 

<!-- TOC -->

- [1. segmentation fault](#1-segmentation-fault)
  - [1.1. 参考](#11-参考)
  - [1.2. 概念](#12-概念)
  - [1.3. 产生的原因](#13-产生的原因)
  - [1.4. return返回](#14-return返回)

<!-- /TOC -->

# 1. segmentation fault
## 1.1. 参考
- [C语言再学习 --段错误（核心已转储）](https://blog.csdn.net/qq_29350001/article/details/53780697)
- [C语言再学习](https://blog.csdn.net/qq_29350001/article/category/9267707/3) 


## 1.2. 概念
- 什么是段错误(segmentation fault)？
  > 程序发生了越界访问，cpu就会产生相应的异常保护，于是segmentation fault就出现了。


## 1.3. 产生的原因
- 什么时候会发生 `segmentation fault`?
  - 访问了不可访问的内存,这个内存区要么是不存在的，要么是受到系统保护的。
  - 错误的访问类型引起
  - 访问了不属于进程地址空间的内存
  - 内存越界，数组越界，变量类型不一致等,访问到不属于你的内存区域
  - 试图把一个整数按照字符串的方式输出
  - 栈溢出了，有时`SIGSEGV`，有时却啥都没发生

- 为什么访问 `null pointer`会发生 `segmentation fault`？
  > 进程(process) 运行时生成了一个虚拟地址(virtual address)0，硬件尝试在TLB(Translation Lookaside Buffer)中查找VPN(virtual page number)0，在TLB中没有找到，则查询页表(page table)，发现VPN 0 的entry被标记为无效。遇到无效的访问，将控制权交给OS(operation system)，可能会终止进程。



## 1.4. return返回
- `return` 语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数
体结束时被自动销毁。

