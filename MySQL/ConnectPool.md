# 连接池

## 为什么要连接池？

 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。使用数据库连接池可以节约资源，程序更加高效。

数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库连接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

## 原理

**连接池基本的思想**：在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

通俗的来讲：**就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去**

数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由**最小数据库连接数**制约。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的**最大连接数**，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。

**1. 最小连接数**

连接池事先会和MySQL服务器创建一定数量的连接数（min_size），当应用发起MySQL访问时，不用再创建和MySQL服务器新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放 connection，而是把当前 connection再归还到连接池当中 。

**2. 最大连接数**

 当并发访问MySQL服务器的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是max_size，不能无限制的创建连接。因为每个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收更多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护。

**3.最大空闲时间**

当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是 max_size个，当这些连接用完再次归还到连接池当中。如果在指定的 max_idle_time 里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收，只需要保持初始连接量 min_size 个连接就可以了。

**4.连接超时时间**

当MySQL的并发请求量过大，连接池中的连接数量已经到达max_size了，而此时没有空闲的连接可供使用，那么此时应用无法从连接池获取连接，它通过阻塞的方式等待获取连接的时间如果超过connection_timeout时间，那么连接失败，无法访问数据库。

**5.超时重试连接次数**

## 连接池的设计

连接池在程序初始化时，创建最小数量的的连接数，等待客户端去连接服务器。当创建的连接数不够时，则需要再创建连接数，但不能超过规定的最大连接数。若创建的连接数超过最小连接数但小于最大连接数时，连接池中的连接存在有未全部使用的情况，有空闲的连接（没有与服务器发生连接），需要动态的去把未使用的连接释放掉，可采用超时的机制。即计算从连接创建到未使用整个期间的时间，超过规定的最大空闲时间时，释放连接，达到让连接池中的数量维持一定的数目，以节省资源。

连接池中已创建的连接数：

- 已与服务端建立连接的
- 空闲未建立连接的



要设计一个数据库连接池，我们需要实现以下几个功能点：

1. 连接池只需要一个实例，所以连接池类应该是一个单例模式的类

2. 所有的数据库连接应该维护到一个安全的队列中
   - 使用队列的目的是方便连接的添加和删除
   - 所谓的安全指的是线程安全，也就是说需要使用互斥锁来保护队列数据的读写。
   
3. 当有数据库访问请求时，直接从连接池的容器中得到一个连接，这里出现三种情况：
   
   (a)当容器中的还有连接时，则返回给数据库访问请求者一个连接
   
   (b)当容器中没有连接时，并且当前建立的连接数没有达到系统定义的最大连接数，则创建一个新的数据库连接。
   
   (c)当容器中的没有连接并且当前建立的连接数达到系统定义的最大连接数，则当前访问数据库请求就要等待其他访问请求释放连接，阻塞等待一定时长然后再重试。
   
4. 如果队列中没有多余的可用连接，需要动态的创建新连接

5. 如果队列中空闲的连接太多，需要动态的销毁一部分

6. 数据库操作完毕，需要将连接放回到连接池的容器中。

7. 当服务停止时，需要先释放数据库连接池中的所有数据库连接，然后再释放数据库连接池对象。

### 细节分析

1. 数据库连接的存储：可用使用 STL 中的队列 **queue**。在并发情况下，STL的queue不是线程安全的，可使用互斥锁实现线程安全。

2. 连接池连接的动态创建：这部分工作需要交给一个单独的线程来处理

3. 连接池连接的动态销毁：这部分工作需要交给一个单独的线程来处理

4. 数据库连接的添加和归还：这是一个典型的生产者和消费者模型。考虑并发情况，使用互斥锁和条件变量实现线程安全和同步。
   
    当用户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给用户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的用户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给用户。
    
    - 消费者：需要访问数据库的线程，数据库连接被取出（消费）
    - 生产者：专门负责创建数据库连接的线程
    - 处理生产者和消费者模型需要使用条件变量阻塞线程
    
5. 连接池的默认连接数量：连接池中提供的可用连接的最小数量
    - 如果不够就动态创建
    - 如果太多就动态销毁

6. 连接池的最大连接数量：能够创建的最大有效数据库连接上限。

7. 最大空闲时间：创建出的数据库连接在指定时间长度内一直未被使用，此时就需要销毁该连接。

8. 连接超时：消费者线程无法获取到可用连接是，阻塞等待的时间长度

### 讨论

**连接池中数据库连接存放的方式可以用队列存放，先放进来的先取出来，也可以用栈来存放，先放进来的后取出来，具体用那种方式，要看需要实现的功能。**

根据要实现的第三种功能得出，我们需要在存放数据库连接的时候记录连接的上一次使用时间，如果上一次使用时间超过一定时间，则关闭此连接。

如果我们使用队列来存储连接，我们会发现每次新放入的连接都放到了队尾，每次取出来的都是队列前面的最老的数据库连接，所以在不断的存取的过程中，队列里面每一个连接的上一次使用时间都会不断刷新。

> 一个使用队列的连接池如果有十个连接，每隔10秒取出一个连接使用并放回，则连接池的连接队列会不断从头部取出来，刷新使用时间，放回队列尾部，这样队列每一个连接的上次使用时间都不会超过当前10秒，队列里面所有连接都不能因为超时被释放。

所以我们应当使用栈来存放数据库连接，每次都从上面取出连接，使用完也放回上面。假如使用的频率特别低会导致栈底部的连接长时间未使用，则可以直接释放以节省资源。

连接容器中超时连接的释放有两种方式：

1. 在往容器中添加或者取出连接的时候释放。
2. 单独开一个线程不断轮询所有连接释放超时的连接。

我们采用的是第一种方式，**在往容器中添加连接的时候释放超时连接**，有以下三个原因：

1. 单独开一个线程需要耗费更多的资源，也更加难以管理
2. 使用栈来存储连接的话，实际上在不断的存取过程中，栈一直保持着从顶部到底部上次使用时间越来越长的规律，即栈中连接的使用时间是有序的。所以每次释放的时候，只需要从底部向上开始扫描，遇到超时的连接则进行释放，遇上非超时的连接则停止扫描，如果栈中连接均未超时，则只需要扫描最后一个就可以了。
3. 使用数据库连接的时候，取出来使用应当比放回去的优先级更高，所以释放超时连接的操作应当放在放回连接池中的部分。
4. 这种方法最坏的情况为：程序开始运行时打开了若干个数据库连接，放置回连接池中，后面则不再进行任何数据库操作（即不再往连接池中取出或存放连接）。这样会导致之前建立的连接一直存放在连接池中，得不到超时释放。但是这种情况出现的几率较少，严格来说这种情况可以通过程序编写避免，所以为了简单和稳定性可以忽略这种情况。

### 注意点

1. 并发问题

2. 事务处理

3. 连接池的分配与释放

   连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 

4. 设置多少连接，性能最佳？

   最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。






# Reference

- [C++实现MySQL数据库连接池](https://blog.csdn.net/qq_29108585/article/details/78178232)
- [基于 C++11 的数据库连接池](https://subingwen.cn/cpp/dbconnectionPool)
- [MySQL API 使用详解](https://subingwen.cn/mysql/mysql-api/)
- 自己动手实现数据库连接池：https://blog.csdn.net/deginch/article/details/70059409
- C/C++数据库连接池项目：https://blog.51cto.com/BugMaker/5588483

