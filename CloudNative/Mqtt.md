## 客户端ID（ClientID）

ClientID 是MQTT连接的唯一标识符。在IoTCore中，不同实例之间是隔离的，故实际上 CoreID + ClientID 唯一标识了一个客户端连接。

如果多个客户端使用相同的 ClientID 连接到MQTT服务器，那么只有最后一个连接会被保留，其他连接会被强制断开。

在使用MQTT连接时，客户端ID应该是唯一的，并且应该易于识别。一个**通常的做法**是，使用固定前缀加上随机生成的UUID作为ClientID：前缀可以用来标识客户端的身份或分组，UUID保证了唯一性。

## 参数设置

在 MQTT 协议中，`retain` 和 `retainHandling` 是两个不同的概念，分别与消息保留和消息传递策略有关。

### 1. `retain` 参数：

- **作用**：决定发布的消息是否被保留在 MQTT 服务器上。
- **范围**：仅在发布消息时有效。
- 取值：true 或  false
  - **`retain = true`**：消息被保留，新的订阅者会立即收到此消息。
  - **`retain = false`**：消息不被保留，新的订阅者不会收到过去发布的消息。

### 2. `retainHandling` 参数：

- **作用**：控制 MQTT 客户端在订阅时如何处理保留消息。
- **范围**：仅在订阅消息时有效。
- 取值 ：`retainHandling`是 MQTT v5 引入的新特性，取值有三种：
  1. **`0`（默认）**：当客户端订阅主题时，接收服务器上的保留消息。
  2. **`1`**：当客户端订阅主题时，**如果客户端以前没有订阅过该主题**，才接收保留消息。
  3. **`2`**：客户端**永远不会**接收保留消息。

### 区别总结：

- **`retain`** 是在发布消息时设置的，用于决定服务器是否应保留该消息。
- **`retainHandling`** 是在订阅时设置的，用于控制客户端是否接收服务器上已经保留的消息。

例如，在某些场景中，用户可能希望只接收新的消息（不包括以前保留的消息），那么可以在订阅时将 `retainHandling` 设置为 `2`。

# TroubleShoots

## 冲突的 MQTT 客户端 ID

- 问题描述

  多个设备使用同一客户端 ID 连接，导致每次有新的数据发送时，原来的连接被断开后重连。

- 分析：

  多个设备使用同一客户端 ID 连接，使用同一客户端 ID 建立了多个连接，从而导致已连接的设备断开连接。MQTT 规范只允许每个客户端 ID 有一个活动连接，因此当另一个设备使用同一客户端 ID 连接时，它会使前一个连接断开。

- 导致的问题：

  ID 相冲突的设备将被迫不断重新连接，这可能导致消息丢失或致使设备无法连接。

  这可能表示设备或设备的凭证已遭破坏，并可能是 DDoS 攻击的一部分。也有可能是设备未在账户中得到正确配置，或者设备连接效果不佳，被迫每分钟重新连接多次。

- 解决方式：

  1. MQTT 连接设备时使用 UUID 作为客户端 ID。
  2. 将每个设备注册为唯一的 客户端ID。

# References

- [centos7设置emqx开机自启动](http://iotts.com.cn/blog/2023/06/28/centos7%E8%AE%BE%E7%BD%AEemqx%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/)
- https://bifromq.io/zh-Hans/docs/2.0.0/best_practices/mqtt_parameters/