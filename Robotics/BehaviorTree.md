## 1. BehaviorTree

### 1.1. 定义

**行为树** 是一种用于建模AI决策逻辑的**图形化编程架构**。它通过**节点**和**树状结构**来控制任务流程，广泛应用于游戏AI、机器人、自动驾驶等领域，以实现复杂、响应式且易于调试的智能行。

行为树你可以把它想象成一个流程图或决策树，用于控制一个机器人（或游戏中的角色）应该如何根据周围环境的变化来执行任务。

可将行为树中的 Node，想象为 乐高积木 中的一个小模块。



### 1.2. 特点

行为树是树状的结构，它的逻辑流程是由`xml`文件描述的。行为树本身并不具体实现机器人的执行内容，它只负责将执行内容进行编排。可用 Groot 工具来可视化行为树。



### 1.3. 优点

1. 调试方便，机器行为的变化都可以追溯。机器行为的变化可记录回放。行为变化也可实时监控。
2. 代码复用率高。不同的功能只需少量代码的修改和机器行为的重新组织。



### 1.4. 行为树与有限状机对比

| 特性       | **有限状态机**                                           | **行为树**                                                   |
| :--------- | :------------------------------------------------------- | :----------------------------------------------------------- |
| **结构**   | 网状。状态之间互相跳转，关系复杂。                       | **树状**。层次清晰，从根到叶单向流动。                       |
| **扩展性** | 添加新状态时，需修改多个现有状态间的跳转逻辑，容易出错。 | **模块化强**。添加新分支/节点通常不影响现有逻辑。            |
| **可读性** | 状态多时，“意大利面条”式的跳转线难以理解。               | **直观**。树形结构一目了然，逻辑易于理解和沟通。             |
| **复用性** | 状态逻辑通常绑定具体任务，复用性差。                     | **节点可高度复用**。一个“移动到某点”节点可被多处调用。       |
| **反应性** | 需要在每个状态中检查外部事件，实现较笨拙。               | **天生反应式**。每次“滴答”都从根节点重新评估，能快速响应变化。 |

**核心优势总结**：行为树通过**模块化、层次化和反应性**，解决了复杂AI逻辑难以编写、调试和维护的痛点。

状态机弊端：

1. 状态与执行内容是绑定在一起的。当执行内容需要在多个状态中执行时，各个状态下都需要放置执行内容的逻辑。当业务逻辑代码分散在各处时就不太好维护了，特别是对于复杂的机器人系统。



**行为树相比状态机的优势**：

- 模块化与可复用性： 节点（如“导航到A点”）是独立的，可以在树的不同位置重复使用。

- 可维护性： 树形结构非常直观，易于理解、调试和修改。添加新行为就像在树上添加一个新分支。

- 动态性： 行为树可以“反应式”地响应环境变化。例如，当一个机器人正在执行“前往目标点”的任务时，如果电池电量低，它可以立即中断当前任务，转而执行“返回充电”任务。
- **可伸缩性**： 可以轻松地构建非常庞大和复杂的行为逻辑，而不会变得像“意大利面条”一样的代码。



## 2. Basical Concepts

- **Tick**：是一个 signal。tick signal 发送到树的根节点，并通过树传播直到到达叶节点。

- 任何接收到 tick 信号的 TreeNode 都会执行其回调函数(callback)。回调返回的结果如下

  - 成功(SUCCESS)： 节点已完成其任务。

  - 失败(FAILURE)： 节点未能完成其任务。

  - 运行中(RUNNING)： 节点正在执行中，尚未完成（例如，机器人正在移动中）。这是实现“反应性”的关键。

- **LeafNodes**：TreeNodes 没有任何的 children，是实际的 命令。

- **Blackboard**：是一种由树中所有节点共享的键值存储（ *key/value* storage ）。
  1. 这不是一个节点，而是**行为树的“共享内存”或“数据库”**。
  2. 所有节点都可以从 blackboard **读取**数据（如“敌人位置”、“剩余电量”）或向 blackboard **写入**数据（如“设置目标点=”）。
  3. **作用**：实现节点间的数据通信，解耦逻辑与数据。
  
- Port：是一种 nodes 之间可以彼此交换信息的机制。

  常用类型：

  - `double` - 浮点数
  - `int` - 整数
  - `bool` - 布尔值
  - `std::string` - 字符串
  - `Pose2D` - 位姿（格式：`x;y;theta`）

## 3. Nodes

任何 TreeNode 都可以看作是一种调用回调函数（callback）的机制，也就是执行一段代码。这个回调函数具体做什么，由使用者自己决定。

### 3.1. Types of nodes

1. ControlNode
2. DecoratorNode
3. LeafNode
   1. ActionNode：要区分 synchronous, asynchronous nodes
   2. ConditionNode

| Type of TreeNode | Children Count | Notes                                                        |
| ---------------- | -------------- | ------------------------------------------------------------ |
| ControlNode      | 1...N          | Usually, ticks a child based on the result of its siblings or/and its own state. |
| DecoratorNode    | 1              | Among other things, it may alter the result of its child or tick it multiple times. |
| ConditionNode    | 0              | Should not alter the system. Shall not return RUNNING.       |
| ActionNode       | 0              | This is the Node that "does something"                       |

### 3.2. controlNode

controlNode 叫控制节点。像树干和树枝，负责控制子节点的执行流程。

这是行为树中的控制流。类似`c++`语言中的`if else`，`switch`等等。它负责构建行为树的逻辑结构。`sequeence`，`fallback`等等就属于这个范畴。

#### 3.2.1. Sequence

Sequence 叫序列节点。

- **逻辑**：按顺序执行所有子节点。**只有全部成功，它才返回成功；任何一个失败，则立即停止并返回失败。**
- **例子**：`序列[接近门，开门，通过，关门]` —— 任何一个步骤失败（如门打不开），整个任务失败。
- 最基本和最常用。

#### 3.2.2. Fallback

FallbackNode 叫选择节点或者选择器(Selector)。

- **逻辑**：按顺序执行子节点，**直到有一个成功为止**。即“尝试方案A，不行就试B，还不行就试C...”。
- **例子**：`选择[用钥匙开门， 用力拉门， 呼叫管理员]` —— 尝试各种开门方法，直到一个成功。

![](./figures/sequences_fallbacks.png)





#### 3.2.3. Parallel

parallel 叫并行节点。

- **逻辑**：同时执行所有子节点。可根据成功/失败数量阈值来决定自身返回结果。
- **例子**：`并行[播放音乐， 闪烁灯光]` —— 同时完成多个动作，营造氛围。



### 3.3. LeafNode

LeafNode 叫执行节点或者叶子节点。在树的最末端，像树叶，是实际“干活”的节点。

#### 3.3.1. ActionNode

ActionNode 叫动作节点，**最常用的类型**。

- 动作节点通常实现服务客户端和动作客户端，也可以是一些简单的执行程序。他们通过向`Planner server`，`Controller server`，`Recovery server`发送请求来启动相应的功能程序。`action`通常作为行为树中的叶子节点，负责具体行为和功能的实现。但这些具体的功能代码并没有在叶子节点中而是在对应的服务端。

- **做什么**：执行一个具体的动作或任务（如“移动”、“抓取”、“说话”）。
- **特点**：可能耗时，会返回“**运行中**”，直到动作完成或失败。

#### 3.3.2. ConditionNode

ConditionNode 叫条件节点。

- 条件控制节点。比如判断电池电量，某一开关信号等等。
- **检查什么**：检查一个世界状态是否成立（如“生命值<30%？”、“看到敌人了吗？”）。
- **特点**：瞬间完成，只返回**成功**或**失败**，不改变世界状态。

### 3.4. DecoratorNode

decoratorNode 叫装饰节点。像树上的装饰，用于修饰或调整单个子节点的行为。它只能有一个子节点。负责将子节点的结果进行修饰。比如将子节点的结果进行反向，约束子节点的执行次数等等。

**常用类型**：

- `反转（Not）`：将子节点的结果反转（成功变失败，失败变成功）。
- `重复（Repeat）`：反复执行子节点N次或直到失败。
- `直到失败（Until Fails）`：反复执行子节点直到其返回失败。
- `强制成功/失败（Force Success/Failure）`：无论子节点结果如何，都返回指定状态。



### 3.5. Custom nodes

通常自定义一个 TreeNode，继承自 `TreeNode`类，或者更具体地说，继承其派生类：

- `ActionNodeBase`
- `ConditionNode`
- `DecoratorNode`



## 4. XML schema

采用 `XML`语描述行为树的内容。



## 5. ROS 中如何实现行为树？

在 ROS 中，行为树不是一个官方的包，而是由社区开发和维护的。最流行、最成熟的库是 **BehaviorTree.CPP**。

**BehaviorTree.CPP 库的特点：**

1. **C++库**： 是一个独立的 C++ 库，可以很好地与 ROS 集成。
2. **Groot GUI 工具**： 提供了一个强大的图形化工具，用于**设计、监控和调试**行为树。你可以拖拽节点来构建树，并实时看到节点的状态变化（用颜色表示），这对于开发和调试至关重要。
3. **XML 定义**： 行为树的结构可以用 XML 文件来定义，这使得树的修改变得非常容易，无需重新编译代码。
4. **与 ROS 通信**： 你的“动作”和“条件”节点内部是通过 ROS 的**Actionlib**、**Service**、**Topic** 等机制与机器人系统的其他部分（如导航、感知、控制）进行通信的。

## 6. Groot

使用 Groot 工具查看 xml 文件时，得加 **节点模型**（`<TreeNodesModel>`）后，groot 编辑器才能渲染后现实，若只有 **树结构**（`<BehaviorTree>`）标签，是不能加载的。

### 6.1. 为什么这样设计？

**关注点分离：**

1. **树结构**（`<BehaviorTree>`）：定义行为逻辑
2. **节点模型**（`<TreeNodesModel>`）：定义编辑界面

**优势：**

- **一份代码，多种用途**：同一个XML既用于编辑又用于运行
- **向后兼容**：BehaviorTree.CPP 忽略不认识的 `TreeNodesModel`
- **编辑器友好**：Groot 有足够的信息渲染GUI

## 7. References

1. BehaviorTree.CPP: https://www.behaviortree.dev/
2. 知乎：ROS2中的行为树 BehaviorTree：https://zhuanlan.zhihu.com/p/534072049

