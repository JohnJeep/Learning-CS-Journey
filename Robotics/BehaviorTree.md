## BehaviorTree

**定义**：

**行为树** 是一种用于建模AI决策逻辑的**图形化编程架构**。它通过**节点**和**树状结构**来控制任务流程，广泛应用于游戏AI、机器人、自动驾驶等领域，以实现复杂、响应式且易于调试的智能行。

行为树你可以把它想象成一个流程图或决策树，用于控制一个机器人（或游戏中的角色）应该如何根据周围环境的变化来执行任务。



**特点**：

行为树是树状的结构，它的逻辑流程是由`xml`文件描述的。行为树本身并不具体实现机器人的执行内容，它只负责将执行内容进行编排。可用 Groot 工具来可视化行为树。



优点

1. 调试方便，机器行为的变化都可以追溯。机器行为的变化可记录回放。行为变化也可实时监控。
2. 代码复用率高。不同的功能只需少量代码的修改和机器行为的重新组织。





### 行为树与有限状机对比

| 特性       | **有限状态机**                                           | **行为树**                                                   |
| :--------- | :------------------------------------------------------- | :----------------------------------------------------------- |
| **结构**   | 网状。状态之间互相跳转，关系复杂。                       | **树状**。层次清晰，从根到叶单向流动。                       |
| **扩展性** | 添加新状态时，需修改多个现有状态间的跳转逻辑，容易出错。 | **模块化强**。添加新分支/节点通常不影响现有逻辑。            |
| **可读性** | 状态多时，“意大利面条”式的跳转线难以理解。               | **直观**。树形结构一目了然，逻辑易于理解和沟通。             |
| **复用性** | 状态逻辑通常绑定具体任务，复用性差。                     | **节点可高度复用**。一个“移动到某点”节点可被多处调用。       |
| **反应性** | 需要在每个状态中检查外部事件，实现较笨拙。               | **天生反应式**。每次“滴答”都从根节点重新评估，能快速响应变化。 |

**核心优势总结**：行为树通过**模块化、层次化和反应性**，解决了复杂AI逻辑难以编写、调试和维护的痛点。

状态机弊端：

1. 状态与执行内容是绑定在一起的。当执行内容需要在多个状态中执行时，各个状态下都需要放置执行内容的逻辑。当业务逻辑代码分散在各处时就不太好维护了，特别是对于复杂的机器人系统。



**行为树相比状态机的优势**：

- 模块化与可复用性： 节点（如“导航到A点”）是独立的，可以在树的不同位置重复使用。

- 可维护性： 树形结构非常直观，易于理解、调试和修改。添加新行为就像在树上添加一个新分支。

- 动态性： 行为树可以“反应式”地响应环境变化。例如，当一个机器人正在执行“前往目标点”的任务时，如果电池电量低，它可以立即中断当前任务，转而执行“返回充电”任务。
- **可伸缩性**： 可以轻松地构建非常庞大和复杂的行为逻辑，而不会变得像“意大利面条”一样的代码。



### Nodes



任意的 TreeNode 都可以看成是一种 callback 机制。



#### 1. 控制节点（control）

像树干和树枝，负责控制子节点的执行流程。

这是行为树中的控制流。类似`c++`语言中的`if else`，`switch`等等。它负责构建行为树的逻辑结构。`sequeence`，`fallback`等等就属于这个范畴。

- **序列节点（Sequence）**：
  - **逻辑**：按顺序执行所有子节点。**只有全部成功，它才返回成功；任何一个失败，则立即停止并返回失败。**
  - **例子**：`序列[接近门，开门，通过，关门]` —— 任何一个步骤失败（如门打不开），整个任务失败。
- **选择节点（选择器，Fallback）**：
  - **逻辑**：按顺序执行子节点，**直到有一个成功为止**。即“尝试方案A，不行就试B，还不行就试C...”。
  - **例子**：`选择[用钥匙开门， 用力拉门， 呼叫管理员]` —— 尝试各种开门方法，直到一个成功。
- **并行节点（Parallel）**：
  - **逻辑**：同时执行所有子节点。可根据成功/失败数量阈值来决定自身返回结果。
  - **例子**：`并行[播放音乐， 闪烁灯光]` —— 同时完成多个动作，营造氛围。

#### 2. 执行节点（叶子节点）

树的最末端，像树叶，是实际“干活”的节点。

- **动作节点（Action）**：

  - 动作节点通常实现服务客户端和动作客户端，也可以是一些简单的执行程序。他们通过向`Planner server`，`Controller server`，`Recovery server`发送请求来启动相应的功能程序。`action`通常作为行为树中的叶子节点，负责具体行为和功能的实现。但这些具体的功能代码并没有在叶子节点中而是在对应的服务端。

  - **做什么**：执行一个具体的动作或任务（如“移动”、“抓取”、“说话”）。
  - **特点**：可能耗时，会返回“**运行中**”，直到动作完成或失败。

- **条件节点（Condition）**：
  - 条件控制节点。比如判断电池电量，某一开关信号等等。
  - **检查什么**：检查一个世界状态是否成立（如“生命值<30%？”、“看到敌人了吗？”）。
  - **特点**：瞬间完成，只返回**成功**或**失败**，不改变世界状态。

#### 3. 装饰节点(decorator)

像树上的装饰，用于修饰或调整单个子节点的行为。

`decorator`是节点装饰器。它只能有一个子节点。负责将子节点的结果进行修饰。比如将子节点的结果进行反向，约束子节点的执行次数等等。

- **常用类型**：
  - `反转（Not）`：将子节点的结果反转（成功变失败，失败变成功）。
  - `重复（Repeat）`：反复执行子节点N次或直到失败。
  - `直到失败（Until Fails）`：反复执行子节点直到其返回失败。
  - `强制成功/失败（Force Success/Failure）`：无论子节点结果如何，都返回指定状态。

#### 4. 黑板（Blackboard）

- 这不是一个节点，而是**行为树的“共享内存”或“数据库”**。
- 所有节点都可以从黑板**读取**数据（如“敌人位置”、“剩余电量”）或向黑板**写入**数据（如“设置目标点=”）。
- **作用**：实现节点间的数据通信，解耦逻辑与数据。





#### 节点状态

每个节点在执行后都会返回一个状态：

- **成功(Success)**： 节点已完成其任务。
- **失败(Failure)**： 节点未能完成其任务。
- **运行中(Running)**： 节点正在执行中，尚未完成（例如，机器人正在移动中）。这是实现“反应性”的关键。

LeafNodes

- ActionNode
- ConditionNode





### ROS 中如何实现行为树？

在 ROS 中，行为树不是一个官方的包，而是由社区开发和维护的。最流行、最成熟的库是 **BehaviorTree.CPP**。

#### BehaviorTree.CPP 库的特点：

1. **C++库**： 是一个独立的 C++ 库，可以很好地与 ROS 集成。
2. **Groot GUI 工具**： 提供了一个强大的图形化工具，用于**设计、监控和调试**行为树。你可以拖拽节点来构建树，并实时看到节点的状态变化（用颜色表示），这对于开发和调试至关重要。
3. **XML 定义**： 行为树的结构可以用 XML 文件来定义，这使得树的修改变得非常容易，无需重新编译代码。
4. **与 ROS 通信**： 你的“动作”和“条件”节点内部是通过 ROS 的**Actionlib**、**Service**、**Topic** 等机制与机器人系统的其他部分（如导航、感知、控制）进行通信的。





### References

1. BehaviorTree.CPP: https://www.behaviortree.dev/
2. 知乎：ROS2中的行为树 BehaviorTree：https://zhuanlan.zhihu.com/p/534072049

