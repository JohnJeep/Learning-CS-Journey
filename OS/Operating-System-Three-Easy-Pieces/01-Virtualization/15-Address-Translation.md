### 地址转换（Address Translation）

#### 问题
1. 怎样在内存中重定位运行的进程，同时对该进程透明（tansparent）?
2. 怎样提供一种虚拟地址从零开始的假象，而实际上地址空间位于另外某个物理地址？


#### 基础
1. 实现CPU虚拟化遵循的准则：受限直接访问（limited direct execution, LDE）。
> 原理：让程序运行的大部分指令直接访问硬件，只在一些关键点（如何发起系统调用或发生时钟中断）由操作系统干预，确保“在正确的时间，正确的地点，做正确的事”。


2. 如何高效、灵活地虚拟化内存？
   - 采用基于硬件的地址转换（hardware-based address translation），简称地址转换。
   - 灵活性：程序能以任何的方式去访问自己的地址空间，让系统更容易编程。
   - 高效性：利用硬件的支持，快速的将所有内存访问操作中的虚拟地址转化为物理地址。
 
 
3. 地址转换
   - 硬件对每次内存访问进行处理（eg: an instruction fetch, load, or store），将指令中的虚拟地址转化为数据实际存储的物理地址。因此，每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定向到内存中的实际位置。
   - 虚拟地址：进程自己看到的地址。
   - 物理地址：实际中内存的地址。


4. 动态重定位（dynamic reloction）也称为基址加界限机制（base and bound）
   - CPU需要两个硬件寄存器：基址寄存器和界限寄存器。 
     - 基址寄存器: 将虚拟地址转化为物理地址。
     - 界限寄存器也叫限制寄存器(limit register)：确保虚拟地址在进程地址空间的范围内。
       - 界限寄存器记录地址空间的大小，硬件在将虚拟地址与基址寄存器内容求和之前，需检查这个界限。
       - 界限寄存器中记录地址空间结束的物理地址，硬件在转化虚拟地址到物理地址之后才去检查这个界限。
     - 基址寄存器与界限寄存器组成的结构称为内存管理单元(memory management unit, MMU)，只有在内核模式下才能修改这两个寄存器。
   - 操作系统中有记录哪些空闲物理内存没有使用的**空闲列表(free list)**，以便能够为其它进程分配内存。    
   - 进程产生的所有内存引用，怎样转化为物理地址？
   
   ```
   virtual address也可叫偏移量(offset)。

   physical address = virtual address + base
   ```

   > 采用静态重定位（static reloction）的缺点
   - 不提供访问保护，进程中的错误地址可能导致对其他进程或操作系统内存的非法访问。
   - 一旦完成，很难将内存空间**重定位**到其它位置。  
  
  - 动态重定位的缺点：会造成内存块中大量的空间被浪费，即称为内部碎片。
    > 内部碎片(internal fragmentation): 指已经分配的内存单元内部有未使用的空间，造成了浪费。

