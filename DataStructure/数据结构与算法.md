<!--
 * @Author: JohnJeep
 * @Date: 2018-09-20 19:59:50
 * @LastEditTime: 2020-07-28 10:34:56
 * @LastEditors: Please set LastEditors
 * @Description: 数据结构与算法新视角书学习笔记
 * @FilePath: /DataStructure/数据结构与算法新视角.md
--> 

<!-- TOC -->

- [0.1. 参考资源](#01-参考资源)
- [0.2. 编写程序需要思考的问题](#02-编写程序需要思考的问题)
- [0.3. 概念](#03-概念)
- [0.4. 线性表](#04-线性表)
  - [0.4.1. 结构体定义（3种）](#041-结构体定义3种)
  - [0.4.2. 单链表](#042-单链表)
  - [0.4.3. 循环链表](#043-循环链表)
- [0.5. 栈](#05-栈)
- [0.6. 队列](#06-队列)
- [0.7. 树](#07-树)
  - [0.7.1. 二叉树](#071-二叉树)
  - [0.7.2. 前序、中序、后序遍历的特性：](#072-前序中序后序遍历的特性)
- [0.8. 算法](#08-算法)

<!-- /TOC -->

## 0.1. 参考资源
- [visualgo](https://visualgo.net/en/sorting) 是一款可视化学习算法的工具，从简单的排序算法到复杂的图形数据结构和算法都有 
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html) San Francisco大学计算机学院提供一个可视化的教学资源 
- [algorithm-visualizer](https://algorithm-visualizer.org/) 支持的语言有：Java，C++，JS 等，还有控制台也会输出整个执行的过程，能帮你更好的理解算法。
- [LeetCode上的经典算法解题实战，在实验楼实现](https://www.shiyanlou.com/courses/492)
- [LeetCode 网址](https://leetcode.com/)


## 0.2. 编写程序需要思考的问题 
- 它容易读懂吗？
- 它有完善的文档吗？
- 它容易修改吗？
- 它在运行时需要多大内存？
- 它的运行时间有多长？
- 它的通用性如何？能不能不加修改就可以用它来解决更大范围的问题？
- 它可以在多种机器上编译和运行吗？或者说需要经过修改才能在不同的机器上运行吗？ 


## 0.3. 概念
- 算法：处理问题的策略
- 数据结构：描述问题的数据模型
- 程序：计算机按照处理问题的策略，处理问题信息的一组指令集

- 计算机处理问题的过程（按流程图走向）
   - 具体问题
   - 抽象
   - 问题模型
   - 数据分析
   - 数据结构
   - 算法分析
   - 算法
   - 程序设计
   - 程序
   - 测试通过
   - 问题得以解决

- 程序解题步骤
   - 建模型：给定的条件是什么，得到的结果是什么
   - 设计
      - 数据结构设计：分析数据对象、时间对象间的联系、确定数据对象的存储方式、确定要对数据对象进行的操作
      - 软件结构设计：用“自顶向下，逐步求精”法，把问题分解成规模适中且便于处理的若干模块
      - 算法设计：为每个模块完成的功能进行具体的描述，把功能描述转化为精确到、结构化的过程描述
   - 编程
   - 验证
      - 测试
      - 纠错

- 数据结构的三要素：
   - 逻辑结构（Logic Structure）
      - 集合：节点间无关系
      - 线性结构：节点间一对一关系
      - 树形结构：节点间一对多关系
      - 图形结构：节点间多对多关系
   - 物理结构（Physical Structure）
      - 顺序存储
      - 链式存储
      - 索引存储
      - 散列存储
   - 数据的运算
 
- 用时间换空间思想
- 用空间换时间思想：将计算的中间结果缓存下来，从缓存中找出目标结果，以牺牲内存空间来提高时间效率。
  

- C语言中常见的问题
  - 内存重叠的处理
  - 临时变量太多或new的内存没有安全释放
  - 没有测试内存越界
  - 指针操作不熟悉 




## 0.4. 线性表
1. 链表是一种动态的数据结构，每添加一个节点分配一次内存，占用的内存是连续的，没有闲置的内存
2. 数组的内存是一次性分配内存

- 同一个线性表中所有的结点都必须是**相同的数据类型**
- 主要操作
  - 初始化
  - 求长度
  - 取元素
  - 定位
  - 插入
  - 删除
  - 遍历
  

### 0.4.1. 结构体定义（3种）
- 法一：在定义结构体类型的同时说明结构体变量
  ```
  struct 结构名
  {
      成员表列;
  }变量名表列;
  ```

- 法二:直接说明结构体变量
  ```
  struct
  {
      成员表列;
  }变量名表列;
  ```

- 法三：先定义结构体，在说明结构体变量
  ```
  struct 结构名
  {
      成员表列;
  };
  struct 结构名 变量名表列;
  ```

- 调用结构体：
  - <font color=red> . 成员选择结构 </font> `结构体变量名.成员名`
  - <font color=red> -> 成员选择指针 </font> `结构指针->结构成员`


### 0.4.2. 单链表
- 链表的节点结构设计
  - 链节点结构
    - data：存放节点的值，即为数据域
    - next：存放节点的直接后继地址，即为指针域或链域


 - 单链表中的每个节点的存储地址是存放在**前驱结点next域**中，开始节点无 `前驱`
 - 终端节点无 `后继`，终端节点的 `指针域` 为空
 - 头指针head指向开始节点
  

节点信息 | 相邻节点地址
---|---
data | next


### 0.4.3. 循环链表
- 建立循环链表时，必须使最后一个节点的指针指向表头节点
- 判断是否到表尾时，判断该节点链域的值是否是表头节点，当链域值等于表头指针，说明已到达表尾



## 0.5. 栈
- 栈（stack）是一种特殊的线性表，所有的插入和删除都限制在表的同一端进行。进行插入、删除操作的一端为栈顶（top）,另一端为栈底，栈中没有元素时为空栈。

 - 栈的主要操作
     - 初始化：建立一个空栈S
     - 判断栈空：判断栈是否为空
     - 进栈：在栈S中插入元素X，使其成为新的栈顶元素
     - 出栈：删除栈S的栈顶元素
     - 取栈顶元素的值，不改变栈顶的指针
     - 求栈的长度

- 特点：先入后出


- 顺序栈：采用一个数组和整型变量实现
  - 数组：顺序存储栈中的元素
  - 整型变量：存储栈元素的下标位置
  - 缺点：栈满后就不能再进栈了。
  - 分类 
    - 静态顺序栈：不能根据需要增大栈的存储空间。
    - 动态顺序栈：根据需要可以增大栈的存储空间。


- 链式栈：采用链表的方式实现栈操作，插入和删除只能在表头进行。


## 0.6. 队列
- **定义**：只允许在一端（队尾）进行插入操作，在另一端（队头）进行删除操作的线性表
- 按照 `先入先出` 方式管理的线性表，一般用于数据的缓存。
- 顺序队列：队列的顺序存储结构
- 循环队列：顺序队列的空间是以循环的方式使用


- 队列规则
  - 排列顺序：节点排成一队，后来的排在队尾
  - 处理过程：在队头处理事件；队列中有元素则一直处理，直到队空或者发生中断事件


- 结论
  - 顺序队列中已经出队的元素不需要删除
  - 顺序队列的存储空间是循环使用
  - 循环队列中头尾指针的计算规则
    - 尾指针：`rear = （rear+1） % 表长(QUEUE_SIZE)`
    - 头指针：`front = （front+1）%表长(QUEUE_SIZE)`
  - 队满状态：`rear+1 = front`
  - 队空状态：`rear = front`
  - 队列中少用一个元素的空间，达到使队满和队空的条件不一样
<img src="./figures/队列.png">

- 链队列
  - 用链表的方式实现的队列，仅允许在表头删除和表尾插入的单链表。



## 0.7. 树
- 定义：
  > 树是包含n（n≥0）个结点的有限集。在任意一棵非空树中，有且仅有一个称为根的结点；其余结点分为m（m≥0）个互不相交的子集，每个子集又是一棵树，称为根的子树


- 特点：
  -  每个结点有零个或多个子结点，无子结点的结点称为**叶子结点**
  - 每一个非跟结点有且只有一个父结点
  - 没有父结点的结点称为**根结点**
  - 是非线性结构 


- 树的术语
  - **结点的度**：一个结点拥有的子树个数
  - **树的度**：树中结点的最大度数值
  - **树的深度（高度）**：树中结点的最大层数
  - 分支结点(非终端结点) ：度>0的结点
  - 叶子结点(终端结点)：度==0的结点
  - 孩子：结点子树的根称为该结点的孩子
  - 双亲：孩子的直接前驱结点称为该结点的双亲
  - 兄弟：同一个双亲的结点互称为兄弟
  - 子孙：以某结点为根的各个子树上的所有结点称为该结点的子孙
  - 祖先：从树根到该结点所经过的所有分支结点称为该结点的祖先
  - 森林：m（m≥0）个树的集合


- 树的存储
  - 存储原则
    - 存数值、存联系
    - 存的进、取得出
  - 存储方式
    - 数组连续存储
    - 链式离散存储


### 0.7.1. 二叉树
- 定义：是n(n≥0)个结点的有限集。该集合或者为空，或者由一个根加上两棵互不相交的、分别称为左子树和右子树的二叉树组成
  - 结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；
  - 树的深度：树中最大的结点层
  - 结点的度：结点子树的个数
  - 树的度： 树中最大的结点度。
  - 叶子结点：也叫终端结点，是度为 0 的结点；


- 二叉树的操作
  - 构造：建立一棵二叉树，初始化
  - 查找：查找根结点、双亲节点、孩子节点、叶子结点
  - 插入：在指定位置差节点
  - 删除：在指定位置删除节点
  - 遍历：沿着某条搜索线路，依次对二叉树中每个结点均做依次且仅做一次访问
  - 求深度：计算二叉树的高度


- 性质
  - 在二叉树的第i层上至多有`$2^{i-1}$`个结点
  - 深度为k的二叉树上至多有`$2^{k}-1$`个结点
  - 设二叉树中有`$n_2$`个度为2个结点，`$n_1$`个度为1的结点，`$n_0$`个度为0的结点，则有：`$n_0 = n_2 +1 $`，树枝数 = `$n_1 + 2n_2$`
  - 具有n个结点的完全二叉树的深度为 `$k=(log_2n) +1 $`
  

- 完全二叉树
  - 定义：将深度为k，有n个结点的二叉树自上而下，自左向右进行编号，编号与深度为k的满二叉树中前n个结点一致
  - 前k－1层是满的，第k层可以不满，但第k层结点集中在左侧


- 满二叉树
  - 定义：所有非终端结点的度都等于2且所有树叶都分布在同一个层次上
  - 结点总数：`$2^{i-1}$`个结点


### 0.7.2. 前序、中序、后序遍历的特性： 
- 前序遍历：（根-->左-->右）
    1. 访问根节点 
    2. 前序遍历左子树 
    3. 前序遍历右子树 
- 中序遍历：（左-->根-->右） 
    1. 中序遍历左子树 
    2. 访问根节点 
    3. 中序遍历右子树 
- 后序遍历：（左-->右-->根）  
    1. 后序遍历左子树 
    2. 后序遍历右子树 
    3. 访问根节点



## 0.8. 算法
- 递归：函数自己调用自己。
  - 缺点：
    - 需要消耗时间和空间：每一次函数调用，都需要在栈上分配空间来保存参数、返回地址和临时变量，而且往栈里面压入数据和弹出数据都需要时间的。 
    - 可能会导致栈溢出。
    - 递归分解的子问题中存在大量重复的计算，导致效率较低。

- 动态规划：求一个问题的最优解，通常是最大值或最小值，而且问题可以分解为若干个子问题，并且子问题之间还有重叠的更小的子问题。 
  - 从上往下分析问题，从下往上求解问题。 
