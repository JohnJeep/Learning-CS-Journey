<!--
 * @Author: JohnJeep
 * @Date: 2018-09-20 19:59:50
 * @LastEditTime: 2020-08-12 18:49:14
 * @LastEditors: Please set LastEditors
 * @Description: 数据结构与算法学习笔记
 * @FilePath: /数据结构与算法.md
--> 

<!-- TOC -->

- [0.1. 参考资源](#01-参考资源)
- [0.2. 编写程序需要思考的问题](#02-编写程序需要思考的问题)
- [0.3. 概念](#03-概念)
- [0.4. 结构体定义（3种）](#04-结构体定义3种)
- [0.5. 链表](#05-链表)
  - [0.5.1. 线性表](#051-线性表)
  - [0.5.2. 循环链表](#052-循环链表)
- [0.6. 栈](#06-栈)
- [0.7. 队列](#07-队列)
- [0.8. 树](#08-树)
  - [0.8.1. 树的存储](#081-树的存储)
  - [0.8.2. 二叉树（binary tree）](#082-二叉树binary-tree)
  - [0.8.3. 遍历二叉树（traverse binary tree）](#083-遍历二叉树traverse-binary-tree)
  - [0.8.4. 树的创建](#084-树的创建)
  - [0.8.5. 红黑树（Red–black tree）](#085-红黑树redblack-tree)
  - [0.8.6. 字典数（trie树）](#086-字典数trie树)
- [0.9. 算法](#09-算法)
  - [0.9.1. 递归](#091-递归)
  - [0.9.2. 动态规划](#092-动态规划)

<!-- /TOC -->

## 0.1. 参考资源
- [visualgo](https://visualgo.net/en/sorting) 是一款可视化学习算法的工具，从简单的排序算法到复杂的图形数据结构和算法都有 
- [Data Structure Visualizations](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html) San Francisco大学计算机学院提供一个可视化的教学资源 
- [algorithm-visualizer](https://algorithm-visualizer.org/) 支持的语言有：Java，C++，JS 等，还有控制台也会输出整个执行的过程，能帮你更好的理解算法。
- [LeetCode上的经典算法解题实战，在实验楼实现](https://www.shiyanlou.com/courses/492)
- [LeetCode 网址](https://leetcode.com/)


## 0.2. 编写程序需要思考的问题 
- 它容易读懂吗？
- 它有完善的文档吗？
- 它容易修改吗？
- 它在运行时需要多大内存？
- 它的运行时间有多长？
- 它的通用性如何？能不能不加修改就可以用它来解决更大范围的问题？
- 它可以在多种机器上编译和运行吗？或者说需要经过修改才能在不同的机器上运行吗？ 


## 0.3. 概念
- 算法：处理问题的策略。
- 数据结构：描述问题的数据模型。
- 程序：计算机按照处理问题的策略，处理问题信息的一组指令集。
- 计算机处理问题的过程（按流程图走向）
  - 具体问题
  - 抽象
  - 问题模型
  - 数据分析
  - 数据结构
  - 算法分析
  - 算法
  - 程序设计
  - 程序
  - 测试通过
  - 问题得以解决
- 程序解题步骤
  - 建模型：给定的条件是什么，得到的结果是什么
  - 设计
    - 数据结构设计：分析数据对象、时间对象间的联系、确定数据对象的存储方式、确定要对数据对象进行的操作
    - 软件结构设计：用“自顶向下，逐步求精”法，把问题分解成规模适中且便于处理的若干模块
    - 算法设计：为每个模块完成的功能进行具体的描述，把功能描述转化为精确到、结构化的过程描述
  - 编程
  - 验证
    - 测试
    - 纠错
- 数据结构的三要素：
  - 逻辑结构（Logic Structure）
    - 集合：结点间无关系
    - 线性结构：结点间一对一关系
    - 树形结构：结点间一对多关系
    - 图形结构：结点间多对多关系
  - 物理结构（Physical Structure）
    - 顺序存储
    - 链式存储
    - 索引存储
    - 散列存储
  - 数据的运算
- 用空间换时间思想：将计算的中间结果缓存下来，从缓存中找出目标结果，以牺牲内存空间来提高时间效率。
- 用时间换空间思想
- C语言中常见的问题
  - 内存重叠的处理
  - 临时变量太多或 `new` 的内存没有安全释放
  - 没有测试内存越界
  - 指针操作不熟悉 

## 0.4. 结构体定义（3种）
- 法一：在定义结构体类型的同时说明结构体变量
  ```
  struct 结构名
  {
      成员表列;
  }变量名表列;
  ```

- 法二:直接说明结构体变量
  ```
  struct
  {
      成员表列;
  }变量名表列;
  ```

- 法三：先定义结构体，在说明结构体变量
  ```
  struct 结构名
  {
      成员表列;
  };
  struct 结构名 变量名表列;
  ```

- 调用结构体：
  - <font color=red> . 成员选择结构 </font> `结构体变量名.成员名`
  - <font color=red> -> 成员选择指针 </font> `结构指针->结构成员`


## 0.5. 链表
- 链表是一种动态的数据结构，每添加一个结点分配一次内存，占用的内存是连续的，没有闲置的内存
- 数组的内存是一次性分配内存


### 0.5.1. 线性表
- 同一个线性表中所有的结点都必须是 **相同的数据类型**
- 主要操作
  - 创建
  - 求长度
  - 取元素
  - 定位
  - 插入
  - 删除
  - 遍历
- 链表的结点结构设计
  - 链结点结构
    - `data`：存放结点的值，即为数据域
    - `next`：存放结点的直接后继地址，即为指针域或链域
 - 单链表中的每个结点的存储地址是存放在 **前驱结点next域**中，开始结点无 `前驱`
 - 终端结点无 `后继`，终端结点的 `指针域` 为空
 - 头指针head指向开始结点
  

结点信息 | 相邻结点地址
---|---
data | next


### 0.5.2. 循环链表
- 建立循环链表时，必须使最后一个结点的指针指向表头结点
- 判断是否到表尾时，判断该结点链域的值是否是表头结点，当链域值等于表头指针，说明已到达表尾



## 0.6. 栈
- 栈（stack）是一种特殊的线性表，所有的插入和删除都限制在表的同一端进行。进行插入、删除操作的一端为栈顶（top）,另一端为栈底，栈中没有元素时为空栈。
- 特点：先入后出
- 栈的主要操作
  - 创建：建立一个空栈S
  - 判断栈空：判断栈是否为空
  - 进栈：在栈S中插入元素X，使其成为新的栈顶元素
  - 出栈：删除栈S的栈顶元素
  - 取栈顶元素的值，不改变栈顶的指针
  - 求栈的长度
- 顺序栈：采用一个数组和整型变量实现
  - 数组：顺序存储栈中的元素
  - 整型变量：存储栈元素的下标位置
  - 缺点：栈满后就不能再进栈了。
  - 分类 
    - 静态顺序栈：不能根据需要增大栈的存储空间。
    - 动态顺序栈：根据需要可以增大栈的存储空间。


- 链式栈：采用链表的方式实现栈操作，插入和删除只能在表头进行。


## 0.7. 队列
- 定义
  - 只允许在一端（队尾）进行插入操作，在另一端（队头）进行删除操作的线性表
- 特点： `先入先出` 方式管理的线性表，一般用于数据的缓存。
- 分类
  - 顺序队列：队列的顺序存储结构
  - 循环队列：顺序队列的空间是以循环的方式使用
- 队列规则
  - 排列顺序：结点排成一队，后来的排在队尾
  - 处理过程：在队头处理事件；队列中有元素则一直处理，直到队空或者发生中断事件
- 结论
  - 顺序队列中已经出队的元素不需要删除
  - 顺序队列的存储空间是循环使用
  - 循环队列中头尾指针的计算规则
    - 尾指针：`rear = （rear+1） % 表长(QUEUE_SIZE)`
    - 头指针：`front = （front+1）%表长(QUEUE_SIZE)`
  - 队满状态：`rear+1 = front`
  - 队空状态：`rear = front`
  - 队列中少用一个元素的空间，达到使队满和队空的条件不一样
<img src="./figures/队列.png">
- 链队列
  - 用链表的方式实现的队列，仅允许在表头删除和表尾插入的单链表。



## 0.8. 树
- 定义
  > 树是包含n（n≥0）个结点的有限集。在任意一棵非空树中，有且仅有一个称为根的结点；其余结点分为m（m≥0）个互不相交的子集，每个子集又是一棵树，称为根的子树
- 特点
  - 每个结点有零个或多个子结点，无子结点的结点称为 **叶子结点**
  - 没有父结点的结点称为 **根结点**
  - 每一个非根结点有且只有一个父结点
  - 树是非线性结构 
- 树的术语
  - 结点层：规定： 树中根结点的层定义为 1，其余结点的层等于其双亲结点的层加1；根的孩子为第二层结点。
  - **结点的度（degree）**：一个结点拥有的子树个数。作用对象是 结节点`。
  - **树的度**：树中结点度的最大值，即拥有子树个数的最大值。
  - **树的深度（depth）**：也叫数的高度，树中结点的最大层数值
  - 分支结点：也叫非终端结点，度大于 0 的结点
  - 叶子结点：也叫终端结点，是度为 0 的结点
  - 孩子：结点子树的根称为该结点的孩子
  - 双亲：孩子的直接前驱结点称为该结点的双亲
  - 兄弟：同一个双亲的结点互称为兄弟
  - 子孙：以某结点为根的各个子树上的所有结点称为该结点的子孙
  - 祖先：从树根到该结点所经过的所有分支结点称为该结点的祖先
  - 森林（forest）：m（m≥0）个树的集合


### 0.8.1. 树的存储
- 利用数组的下标将离散的树结点的编号一一对应起来。
- 存储原则
  - 存数值、存联系
  - 存的进、取得出
- 存储方式
  - 顺序连续存储
  - 链式离散存储：
    - 二叉链表结点： 一个数据域，两个分别指向左右子结点的指针域。内部数据的指针指向采用长兄为父的思想。
      Lchild | data |Rchild
      ---|---|--- 
    - 三叉链表结点： 一个数据域，两个分别指向左右子结点的指针域，还有一个父结点。
      Lchild | data | parent | Rchild 
      ---|---|---|--- 
    - 双亲结点表示法：在子结点中存储双亲结点的位置。


- 树如何存储在数据库中？
  - 建立两张表，一张存储树结点的表，另一张存储结点与结点之间关系的表。


### 0.8.2. 二叉树（binary tree）
- 定义：是n(n≥0)个结点的有限集。该集合为空或者由一个根加上两棵互不相交的、分别称为左子树和右子树的二叉树组成。
- 二叉树的定义是递归的


- 二叉树的操作
  - 创建：建立一棵二叉树，初始化
  - 查找：查找根结点、双亲结点、孩子结点、叶子结点
  - 插入：在指定位置差结点
  - 删除：在指定位置删除结点
  - 遍历：沿着某条搜索线路，依次对二叉树中每个结点均做依次且仅做一次访问
  - 求深度：计算二叉树的高度


- 性质
  - 在二叉树的第 `i` 层上至多有 $2^{i-1}$ 个结点
  - 深度为 `k` 的二叉树上至多有 $2^{k}-1$ 个结点，$k{\geq}1$
  - 设二叉树中有 $n_2$ 个度为 `2` 的结点，$n_1$ 个度为 `1` 的结点，$n_0$ 个度为 `0` 的结点，则有：$n_0 = n_2 + 1$，分支总数 = $n_1 + 2n_2$，结点总数 = $n_0 + n_1 + n_2 $
  - 具有 `n` 个结点的完全二叉树的深度为 $k=[log_2 n] + 1$
  

- 完全二叉树（complete binary tree）
  - 定义：
    - 第一种：每一棵树除最下层外，每一层的结点数均达到最大值，在最下层只缺少右边的若干结点。
    - 第二种：先给满树编号，根结点编号为 `1`，从根结点开始自上而下，自左向右进行编号，若去掉树中的若干结点后，树的编号依然连续，则是完全二叉树。
  - 特点
    - 前 `k－1` 层是满的，第 `k` 层可以不满，但第 `k` 层结点集中在 `左侧`。
    - 完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。
    - `n` 个结点的完全二叉树的树深度为 $[log_2 n]+1$，其中$[log_2 n]$ 向下取整数。


- 满二叉树（full binary tree）
  - 定义：除了叶子结点以外每一个结点都有左右子树且叶子结点都处在最底层上。
  - 特点
    - 每一层上的结点数总是最大结点数。
    - 所有分支结点都有左、右子树。
    - 深度为 `k` 的数的结点数为： $2^{k-1}$ 


### 0.8.3. 遍历二叉树（traverse binary tree）
- 先序遍历：（根-->左-->右）
    1. 访问根结点 
    2. 先序遍历左子树 
    3. 先序遍历右子树 
- 中序遍历：（左-->根-->右） 
    1. 中序遍历左子树 
    2. 访问根结点 
    3. 中序遍历右子树 
- 后序遍历：（左-->右-->根）  
    1. 后序遍历左子树 
    2. 后序遍历右子树 
    3. 最后访问根结点


- 无论是采用先序遍历、中序遍历还是后序遍历，算法遍历的过程是一样的，只是访问树结点的时机不一样。
- 前序遍历和中序遍历不采用非递归的方法时，采用栈的思想，因为先经过的结点后访问。后序遍历采用堆的思想实现。
- 非递归中序遍历步骤
  - 步骤一：若结点有左子树，则该结点入栈；若结点没有左子树，则访问该结点。
  - 步骤二：若结点有右子树，则重复步骤 1；若结点没有右子树，则结点访问结束，根据栈顶指示，访问栈顶元素，进行出栈。
  - 步骤三：若栈为空，则遍历结束。


- 如何确定一棵树？ 
  - 通过先序遍历和中序遍历可以确定一棵树。
    - 步骤一：根据`先序遍历` 的序列得到根结点的位置，再由根结点在 `中序遍历` 中的位置得到左右子树的集合；
    - 步骤二：在左子树集合中根据先序遍历得到左子树集合的根结点，重复步骤一；
    - 步骤三：在右子树集合中根据先序遍历得到右子树集合的根结点，重复步骤一；
  - 通过 `中序遍历` 和 `后序遍历` 可以确定一棵树。
  - 通过 `先序遍历` 和 `后序遍历` 不能确定一棵树。


### 0.8.4. 树的创建
- 利用 `#号法` 进行树的创建
  - `#号法` 的先序遍历能确定一颗树。


### 0.8.5. 红黑树（Red–black tree）
- 参考
  - [30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c) 
  - [](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)
  - [AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91) 
  - [红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
  - [漫画：什么是红黑树？](https://zhuanlan.zhihu.com/p/31805309)



- 特点
  - 节点是红色或黑色。
  - 根是黑色。
  - 所有叶子都是黑色（叶子是NIL节点）。
  - 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
  - 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
  - 如果一个结点存在黑子结点，那么该结点肯定有两个子结点
  

<img src="./figures/red-black-tree.png">


- 红黑树是一种平衡二叉查找树的变体

- 关键特点：从根到叶子的最长路径不多于最短路径的两倍长
- 应用场景
  - 适合排序，查找的场景。
  - 容器的基本组成，如Java中的HashMap/TreeMap.
  - Linux内核的完全公平调度器
  - Linux中epoll机制的实现


### 0.8.6. 字典数（trie树）
- 是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题
- 特点
  - 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。
  - 从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符  串。
  - 每个字符串的公共前缀作为一个字符节点保存。

- 缺点
  - 构造Trie树需要很大的内存空间。因为父子字符节点之间用 指针关联。如果用数组保存这些指针，这意味着子节点的数组需要穷举出每一种可能。

- 应用场景
  - 关键词匹配，提示，纠错。
  - 最长公共前缀匹配。
  - 命令自动补全，如zsh.
  - 网址浏览历史记录。
  - 手机号码簿查询



## 0.9. 算法
### 0.9.1. 递归
- 函数自己调用自己。
- 缺点：
  - 需要消耗时间和空间：每一次函数调用，都需要在栈上分配空间来保存参数、返回地址和临时变量，而且往栈里面压入数据和弹出数据都需要时间的。 
  - 可能会导致栈溢出。
  - 递归分解的子问题中存在大量重复的计算，导致效率较低。


### 0.9.2. 动态规划
- 求一个问题的最优解，通常是最大值或最小值，而且问题可以分解为若干个子问题，并且子问题之间还有重叠的更小的子问题。 
- 从上往下分析问题，从下往上求解问题。 
