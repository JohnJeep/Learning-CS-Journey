<!--
 * @Author: JohnJeep
 * @Date: 2020-10-30 09:38:07
 * @LastEditTime: 2021-11-09 13:48:44
 * @LastEditors: DESKTOP-0S33AUT
 * @Description: shall 学习笔记
-->

<!-- TOC -->

- [1. Shell](#1-shell)
- [2. Bash 终端快捷键](#2-bash-终端快捷键)
  - [2.1. 终端控制](#21-终端控制)
  - [2.2. 大小写](#22-大小写)
  - [2.3. 光标移动](#23-光标移动)
  - [2.4. 删除](#24-删除)
  - [2.5. 粘贴](#25-粘贴)
  - [2.6. 字符交换](#26-字符交换)
  - [2.7. 历史记录](#27-历史记录)
  - [2.8. 其它命令](#28-其它命令)
- [3. Shell 启动](#3-shell-启动)
- [4. 基本命令](#4-基本命令)
  - [4.1. 引号](#41-引号)
  - [4.2. 变量](#42-变量)
    - [4.2.1. 环境变量](#421-环境变量)
    - [4.2.2. 用户变量](#422-用户变量)
  - [4.3. 命令替换](#43-命令替换)
  - [4.4. 命令行参数](#44-命令行参数)
  - [4.5. 执行数学运算](#45-执行数学运算)
- [5. 重定向](#5-重定向)
- [6. 结构化命令](#6-结构化命令)
  - [6.1. if 语句](#61-if-语句)
    - [6.1.1. 高级特性](#611-高级特性)
  - [6.2. case 语句](#62-case-语句)
  - [6.3. for 语句](#63-for-语句)
  - [6.4. while 语句](#64-while-语句)
  - [6.5. test 条件测试](#65-test-条件测试)
    - [6.5.1. 数值比较](#651-数值比较)
    - [6.5.2. 字符串比较](#652-字符串比较)
    - [6.5.3. 文件比较](#653-文件比较)
    - [6.5.4. 逻辑比较](#654-逻辑比较)
- [7. 函数](#7-函数)
- [8. 阻止命令输出](#8-阻止命令输出)
- [9. shell调试](#9-shell调试)
- [10. 用户输入处理](#10-用户输入处理)
- [11. 正则表达式](#11-正则表达式)
  - [11.1. 字符串限定符](#111-字符串限定符)
  - [11.2. 数量限定符](#112-数量限定符)
  - [11.3. 位置限定符](#113-位置限定符)
  - [11.4. 其他特殊字符](#114-其他特殊字符)
- [12. tee](#12-tee)
- [13. sed](#13-sed)
- [14. awk](#14-awk)
- [15. Reference](#15-reference)

<!-- /TOC -->

# 1. Shell

一旦启动了终端仿真软件包或者登录 Linux 虚拟控制台，你就会看到 shell CLI 提示符。提示符就是进入shell世界的大门，是你输入 shell 命令的地方。默认 bash shell 提示符是美元符号（ $），这个符号表明 shell 在等待用户输入。  



Shell 命令分为三大类：

- 内建命令(built-in)
- 外部命令
- 用户定义函数（function）、别名（alias）

> 查找某个命令属于哪类：`type -a <命令名称>`



# 2. Bash 终端快捷键

Ctrl开头的快捷键一般是针对字符的，而Alt开头的快捷键一般是针对词的。

## 2.1. 终端控制

- `Ctrl + d` : 退出当前终端（end of file）
- `Ctrl + c` : 强制终止当前命令，终止的是前台进程
- `Ctrl + z` : 将当前任务暂停并挂在后台
- `Ctrl + s`: 冻结当前terminal的stdin，键盘输入的数据不会马上在terminal显示，而是恢复冻结后，在当前光标之前显示输入的数据。（Suspend）
- `Ctrl +  q`: 恢复当前terminal的stdin（Resume）
- ` stop + job号`: 将前台的进程挂起
- ` fg `: 将后台中的命令调至前台继续运行
  > `fg %job number`: 将放在后台的任务通过指定其 `job number`，让它在前台工作。`%job number`是通过jobs命令查到的后台正在执行的命令的序号(不是pid，数字默认从 1 开始)
- `bg`: 进程转到后台
  > `bg %number` 直接让在后台暂停（stopping）的任务变为运行（running）状态。
- `jobs`：查看放在后台的所有任务。
  - `+` : 代表最近被放到后台的任务号码。
  - `-` : 代表最近第二个被放到后台中的任务号码。从第三个任务开始，每个任务前面不在有 `+` 或者 `-` 符号存在。
- 终止后台进程
  - `kill + job号`
  - `kill + PID`
- nohup
  - 在用户注销或脱机后，任务还能继续在后天执行，与系统使用的terminal 无关。
  - 一般的任务管理的后台与所使用的terminal有关，terminal终止后，后台任务也就终止了。
  - 想要后台的任务在你注销用户后还能继续执行，可以使用 `nohup 结合 &` 搭配使用。


## 2.2. 大小写

- `esc + u:`  将当前光标之后以空格隔开的单词或者字符转换为大写，包括当前光标(upper)
- `esc + l:`  将当前光标之后以空格隔开的单词或者字符转换为大小，包括当前光标(lower)
- `esc + c:`  将当前光标之后以空格隔开的单词首字母转换为大写




## 2.3. 光标移动
- `Alt + f` 前移动一个单词
- `Alt + b` 后移动一个单词
- `Esc +f` 移动到当前单词结尾
- `Esc + b` 移动到当前单词开头
- `Ctrl + b`: 光标向后(backward)移动，与 `←` 等价
- `Ctrl + f`: 光标向前移动(forward)，与 `→` 等价
- `Ctrl + a`：移动光标到命令行首。
- `Ctrl + e`：移动光标到命令行尾。


## 2.4. 删除
- `Ctrl + u`: 擦除当前光标之前的字符，不包括当前光标
- `Ctrl + k`: 擦除从当前光标之后到行尾的所有字符，包括当前光标
- `Ctrl + w`: 删除当前光标之前以空格隔开的任意长度的字符，不包括当前光标
- `Alt + d` : 擦除当前光标之后的一个单词，包括当前光标
- `Ctrl + h`: 删除当前光标前面的字符，每次删除一个字符
- `Ctrl + d`: 删除当前光标后面的字符，每次删除一个字符
- `Ctrl + /`: 撤销之前擦除的所有字符

> 擦除：输入的数据还在缓冲内存中，没有被删除，可以复制。


## 2.5. 粘贴

- `Ctrl + y`: 从当前光标处粘贴之前擦除的字符


## 2.6. 字符交换

- `Ctrl + t`: 当前光标处字符与前一个字符交换位置
- `Alt + t` : 当前光标处单词与前一个单词交换位置


## 2.7. 历史记录

- `Ctrl + r` 搜索历史记录
- `Ctrl + g` 退出当前搜索模式（在搜索历史记录下）
- `fc - l`   默认从最后往前显示 16 条历史记录。
- `Ctrl + p` 向上查找历史命令，与 `↑` 等价
- `Ctrl + n` 向下查找历史命令，与 `↓` 等价
- `Alt + r` : 取消当前所有改变的操作，若当前命令从历史记录中来，返回上一次历史记录的原始状态，若当前命令是手动输入，则会清空当前行



## 2.8. 其它命令

- `cd - ` 在两个相邻的目录之间进行切换。
- `;` 在一条行中执行多条命令，采用 ; 实现
- `&&` 仅在上一个命令成功的情况下，才能执行后面的多个命令
- `lsblk` 以树状的格式列出块设备


# 3. Shell 启动

当你登录Linux系统时，bash shell 会作为登录 shell 启动。登录 shell 会从 5 个不同的启动文件里读取命令：
- /etc/profile
- $HOME/.bash_profile
- $HOME/.bashrc
- $HOME/.bash_login
- $HOME/.profile

> `/etc/profile` 文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行这个启动文件。



# 4. 基本命令

- 解释采用哪种shell运行脚本: `!#/bin/sh`
- 多条语句之间使用 `;` 分割开
- 输入的命令采用 `()` 括起来，shell会fork一个新的字shell进程执行括号里面的内容。
- 确定哪些命令是否属于shell内建命令：`type command`
- 数据类型：只有字符串类型。


## 4.1. 引号

单引号与双引号的区别
- 被双引号括住的内容表示单一字符串，它防止通配符扩展，但允许变量扩展。
- 被单引号括住的内容只能表示字符串。
  ```bash
  var=200      # =号两边不能有空格
  echo $var    # 200
  echo '$var'  # $var
  echo "$var"  # 200，打印变量var的内容
  ```

## 4.2. 变量

> 变量名前面加上 `$` 表示显示当前变量的值，还可以让变量作为命令行的参数。没有美元符， shell会将变量名解释成普通的文本字符串。
  
### 4.2.1. 环境变量

- 本地变量: `VARNAME=value`。shell中默认的变量类型为字符串类型，定义时不需要指定类型。
- 环境变量: 将本地变量提升为环境变量，`export VARNAME=value`
- 删除已定义的环境变量或本地变量：`unset VARNAME`
- `env | grep VARNAME`: 查看系统中的环境变量 VARNAME


显示环境变量可用三种命令查看：env、set、printenv
- set 命令会显示出全局变量、局部变量以及用户定义变量，它还会按照字母顺序对结果进行排序。
- env 和 printenv 命令不会对变量排序，也不会输出局部变量和用户定义变量。printenv 可以显示个别的环境变量
```sh
[root@KF-CFT-mongdb3 ~]# printenv HOME
/root
[root@KF-CFT-mongdb3 ~]# echo $HOME
/root
```

### 4.2.2. 用户变量

除了环境变量， shell 脚本还允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在整个脚本中使用，从而使 shell 脚本看起来更像一个真正的计算机程序。

用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过 20 个。用户变量区分大小写，所以变量 `Var1` 和变量 `var1` 是不同的。

- 一般自定义的变量名称使用大写来表示；使用 `$` 取出变量的值，使用`()` 取出命令的值。
- 引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。
```sh
#!/bin/bash

value1=10
value2=$value1
echo The resulting value is $value2
```



## 4.3. 命令替换

> shell脚本中最有用的特性之一就是可以从 shell 命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。

有两种方法可以将命令输出赋给变量：
- 反引号字符 ` ` `
- `$()` 格式：`$(commmand)` 执行括号里面的命令功能。例如：`$(data)`
```
[root@KF-CFT-mongdb3 ~]# test=$(date)
[root@KF-CFT-mongdb3 ~]# echo $test
2021年 11月 08日 星期一 10:52:12 CST
```
> shell会运行命令替换符号中的命令，并将其输出赋给变量testing。注意，赋值等号和命令替换字符之间没有空格。


## 4.4. 命令行参数

- `$0`: 获取 shell 在命令行启动的脚本名，会包含完整的脚本路径。去掉脚本的路径利用 `basenmae` 关键字实现。
- `$1`: 第一个参数 
- `$2`: 第二个参数 
- `$#`: 统计命令行参数的个数。
- `$*`: 将 shell 的所有参数当成单个参数。
- `$@`: 单独处理输入的每个参数。
- `$?`: 显示上一次命令的退出状态码。
  - 成功结束的命令退出状态码是 `0`。
  - 如果一个命令结束时有错误，退出状态就是一个正值；
  - 无效命令会返回一个退出状态码 `127`。
- `$$`: 显示脚本运行的当前进程 ID 号。
- `shift`: 允许你在不知道参数总数的情况下处理各种脚本参数，该命令会将下一个参数移动到 `$1`。默认情况下它会将每个参数变量向左移动一个位置，后面也可以指定移动多个参数的位置。如果某个参数被移出，它的值就被丢弃了，无法再恢复。



## 4.5. 执行数学运算

算术代换: 用于基本的算术计算。

- `echo $[11+12]` 两个数相加
- `echo $[2#10+16#12]` 二进制的 10 加上十六进制的 12，结果按照十进制显示


# 5. 重定向

将脚本的输出重定向到 Linux 系统的不同位置。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。

输出重定向。通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。
- 大于符号 `>` 将命令的输出发送到一个文件中。
- 将命令的输出追加到已有文件中，并不想覆盖文件原有内容，使用 `>>`


输入重定向。Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。
- 输入重定向将文件的内容重定向到命令，使用小于符号 `<`。
  > 形式：`command < inputfile`  ，小于号说明数据正在从输入文件流向命令。
- 内联输入重定向符号是远小于号（ <<）。

临时重定向：想在脚本中生成错误信息时，使用输出重定向符来将输出信息重定向到 `STDERR` 文件描述符，这种方法会重定向每条设定的语句。`echo "This is an error message" >&2`


永久重定向：脚本中用 `exec` 命令告诉shell在脚本执行期间重定向某个特定文件描述符，可以重定向大量的数据。`exec 1>test`


三个标准文件描述符 
- `STDIN`: 标准输入 0
- `STDOUT`: 标准输出 1
- `STDERR`: 标准错误 2


# 6. 结构化命令

许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（ structured command）。


## 6.1. if 语句

如果你在用其他编程语言的if-then语句，这种形式可能会让你有点困惑。在其他编程语言中， if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。

bash shell 的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是 0（该命令成功运行），位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值，部分的命令就不会被执行，bash shell 会继续执行脚本中的下一个命令或者执行 `else` 部分的内容。fi 语句用来表示if-then 语句到此结束。


if 语句格式
```bash
if command
then
  commands
fi

# 另外一种形式
if command; then
  commands
else
  commands
fi

# 嵌套if
if command1
then
  commands
elif command2
then
  more commands
fi
```


```bash
echo "Is it morning? Please answer yes or no."
read YES_OR_NO
if [ "$YES_OR_NO" = "yes" ]; then          # 取值必须使用 ""
    echo "Good moning!"
elif [ "$YES_OR_NO" = "no" ]; then         # 嵌套 if
    echo "Good afternoon!"
else
    echo "Sorry, $YES_OR_NO not recognized. Enter yes or no."
fi
```

### 6.1.1. 高级特性

bash shell 提供了两项可在 `if-then` 语句中使用的高级特性：
* 用于数学表达式的双括号
* 用于高级字符串处理功能的双方括号


双括号 `((expression))` 命令允许你在比较过程中使用高级数学表达式。双括号命令中可以使用的符号：
  ```bash
  var++
  var--
  ++var
  --var
  !     # 逻辑求反
  !     # 位求反
  **    # 幂运算
  <<    # 左位移
  >>    # 右位移
  &     # 位与
  |     # 位或
  &&    # 逻辑与
  ||    #逻辑或

  val1=10
  if (( $val1 ** 2 > 90 ))
  then
    (( val2 = $val1 ** 2 ))
    echo "The square of $val1 is $val2"
  fi
  ```


双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：
`[[ expression ]]`


## 6.2. case 语句

- case 可以匹配字符串额通配符，每条分支语句必须以 `;;` 结尾。
- `esac` 表示整个 case 语句块的结束
```bash
#! /bin/bash
echo "Please input yes or no?"
read TMP     # 从内尺中读输入的变量
case "$TMP" in
    Yes|y|Y|YES)
        echo "It's ok.";;
    [nN]?)
        echo "It's not ok.";;
     *)
         echo "Input error.";;   # 默认执行
esac
return 0;
echo "exec return."   # 该条命令不执行
```

## 6.3. for 语句

利用ls命令判断当前目录下文件的的类型

```bash
#! /bin/bash
for name in $(ls); do
  printf "$name "
  if [ -d "$name" ]; then
    echo "It's a dir."
  elif [-f "$name" ]; then
    echo "It's a file."
  else
    echo "others."
  fi
done
```


## 6.4. while 语句

```bash
while [ ... ]
do 
  .....
done 
```


## 6.5. test 条件测试

test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立， test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。

- `[ -p pipe ]` :左右括号分别表示一个命令，与参数之间需要使用空格隔开，并不是普通的括号。


### 6.5.1. 数值比较

- `-eq`: 等于
- `-ge`: 大于等于
- `-le`: 小于等于
- `-ne`: 不等于
- `-gt`: 大于
- `-lt`: 小于
- 不能在test命令中使用浮点值，bash shell只能处理整数。


### 6.5.2. 字符串比较

- 两个字符串之间可以使用 `>`、`<`、`=`、`!=` 来比较是否相同。
- `-n str1`: 检查 str1 的长度是否非 0
  ```bash
  # 判断val1变量是否长度非0，而它的长度正好非0，所以then部分被执行了。
  if [ -n $val1 ]
  ```
- `-z str1`: 检查 str1 的长度是否为 0 
  ```bash
  # 判断val2变量是否长度为0，而它正好长度为0，所以then部分被执行了。
  if [ -z $var2 ]
  ```


### 6.5.3. 文件比较

- `-d file`: 检查file是否存在并是一个目录
- `-e file`: 检查file是否存在
- `-f file`: 检查file是否存在并是一个文件
- `-r file`: 检查file是否存在并可读
- `-s file`: 检查file是否存在并非空
- `-w file`: 检查file是否存在并可写
- `-x file`: 检查file是否存在并可执行
- `-O file`: 检查file是否存在并属当前用户所有
- `-G file`: 检查file是否存在并且默认组与当前用户相同
- `file1 -nt file2`: 检查file1是否比file2新
- `file1 -ot file2`: 检查file1是否比file2旧 


### 6.5.4. 逻辑比较

- `expr1 -a expr2`: 逻辑与
- `expr1 -o expr2`: 逻辑或
- `expr1 ! expr2` : 逻辑非 

  
  
# 7. 函数

shell函数体中没有函数参数和返回值，函数参数在运行时传递。

- 格式
  ```bash
  // 第一种格式 name为函数名
  name()
  {
    ...
  }
  
  // 第二种方式: 采用function关键字，name为函数名，后面没有小括号
  function name
  {
  
  }
  ```


- 返回值
  - 默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后（即执行完最后一条命令），可以用标准变量 `$?` 来确定函数的退出状态码。
  - 语句执行成功，退出状态码为 `0`，没有执行成功退出状态码为 `1`；退出状态码的范围在 `0~255` 之间 
  - 使用 `return` 命令来退出函数并返回特定的退出状态码。


# 8. 阻止命令输出

有时候，你可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。如果在运行在后台的脚本出现错误消息， shell会通过电子邮件将它们发给进程的属主。这会很麻烦，尤其是当运行会生成很多烦琐的小错误的脚本时。

要解决这个问题，可以将 `STDERR` 重定向到一个叫作 null 文件的特殊文件。 `null` 文件跟它的名字很像，文件里什么都没有。 shell 输出到 `null` 文件的任何数据都不会保存，全部都被丢掉了。在 Linux 系统上 null 文件的标准位置是 `/dev/null`，你重定向到该位置的任何数据都会被丢掉，不会显示。

```sh
[root@KF-CFT-mongdb3 ~]# ls -al > /dev/null
[root@KF-CFT-mongdb3 ~]# cat /dev/null
[root@KF-CFT-mongdb3 ~]#
```
在输入重定向中将 `/dev/null` 作为输入文件。由于 `/dev/null`文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。
> 在输入重定向中将 `/dev/null` 作为输入文件。由于 `/dev/null` 文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。


# 9. shell调试

- `. test.sh -n`: 检查test.sh脚本中是否有语法错误，但不执行脚本。
- `. test.sh -x`: 跟踪执行的信息，将执行的每一条结果和命令都打印出来。
 > 注意：需要在脚本的头部中添加 `#! /bin/bash -x` ，跟踪的前后添加 `set -x` 和 `set +x`


# 10. 用户输入处理

- `read` 命令
  - 从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后， read 命令会将数据放进一个变量中。
  - `-p` 参数：允许你直接在read命令行指定提示符。
  - `-t`选项: 指定一个计时器，等待输入的秒数，在指定的时间内输入值。当计时器过期后， read命令会返回一个非零退出状态码。
  - `-s` 参数：避免在read命令中输入的数据出现在显示器上，实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样。常常用于用户密码的输入。 `read -s -p "Enter your password: " pass`



# 11. 正则表达式

两种流行的正则表达式引擎
  - POSIX基础正则表达式（ basic regular expression， BRE）引擎。例子：sed编辑器。
  - POSIX扩展正则表达式（ extended regular expression， ERE）引擎。例子：gawk工具。

<img src="./figures/regExp.png">


## 11.1. 字符串限定符

- `.`: 匹配任意一个字符
- `[]`: 匹配括号中的任意一个字符
- `-`: 在[] 括号内表示字符范围。eg: `[0-9]`
- `^`: 位于[] 括号的开头，匹配除括号中的字符之外的任意一个字符。eg: `[^abf]` 匹配除abf字符以外的所有字符。
- `\s`: 匹配任意空白字符。
- `\S`: 匹配任意非空白字符。
- `\d`: 匹配任意数字。
- `\D`: 匹配非任意数字。
- `w`: 匹配任意单字字符（字母、数字、下划线）。
- `W`: 匹配任意非单字字符。
- `[[:xxx:]]`: grep工具转给你预定义的一些字符类。


## 11.2. 数量限定符

- `?`: 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。
- `+`: 匹配前面的子表达式一次或多次。
- `*`: 匹配前面的子表达式零次或多次。
- `{N}`: 精确匹配N次
- `{N,}`: 至少匹配N次
- `{,N}`: 最多匹配N次
- `{M,N}`: 至少匹配M次，最多匹配N次


## 11.3. 位置限定符

- `^xxx`: 匹配以xxx开始的行
- `$xxx`: 匹配以xxx结束的行
- `xxx\<`: 匹配以xxx字符开头的单词 
- `xxx\>`: 匹配以xxx字符结尾的单词
- `\b`: 匹配以xxx字符开始或结尾的单词
- `\B`: 匹配不包含以xxx字符开始或结尾的单词。eg: `\Bth\B----->mythed`


## 11.4. 其他特殊字符

- `\`: 转义字符，可以将普通字符转义为特殊字符，也可以将特殊字符转义为普通字符。
- `()`: 将正则表达式的一部分使用括号括起来，组成一个单元，对整个单元使用数量限定符。
- `|`: 连接两个子表达式。


# 12. tee 

- 作用：将从 `STDIN` 过来的数据同时发送到显示器和日志文件中。
- 默认情况下， tee 命令会在每次使用时覆盖输出文件内容。想将数据追加到文件中，必须用 `-a` 选项。


# 13. sed

sed俗称做流编辑器，以行单位进行字符处理。

- 格式
  - `sed 参数 '脚本语句' 带操作文件`
  - `sed 参数 -f '脚本文件' 带操作文件` 
- 脚本语句参数
  - `a(append)`：追加
  - `i(insert)`：插入
  - `d(delete)`：删除
  - `s(substitution)` : ` sed -i 's/echo/printf/g' for_tmp.sh` 将for_tmp.sh脚本文件中的所有echo替换为printf，使用 `-i` 参数并将修改的内容保存，而非仅仅输出显示到标准输出上。
- 选项参数
  - `-n`：默认情况下，脚本执行完后，自动打模式空间中的内容，使用 `-n` 可以屏蔽自动打印。
  - `-i`: 将修改后的源文件保存
  - `-E`：使用扩展正则表达式
  - `-e`: 使用多个脚本语句替换 时，需要用 `-e` 选项。


# 14. awk

以列单位进行字符处理，默认情况下按照TAB或空格对文件进行拆分。

- 格式
  - `awk 参数 '脚本语句' 带操作文件`。例子：`ps aux | awk '{print $3}'` 打印进程信息中的第三列
  - `awk 参数 -f '脚本文件' 带操作文件` 
- 变量
  - `print`: 打印输出变量，默认打印数据后自动会换行。
  - `printf`: 类似于C语言中的printf函数用法。  
  - 两个特殊的条件：BEGIN、END。例子：统计一个文件中的所有空格数 `awk '/^ *$/ {count=count+1} END {print count}' test.txt`
  - 常用内建变量
    - FILENAME：当前输入文件的文件名
    - NR：当前行的行号，R(record)
    - NF：当前行所拥有的的列数，F(field)
    - OFS：输出字段的列分隔符，默认是空格
    - FS：输入文件的列分隔符，默认是空格和TAB
    - ORS：输出字段的行分隔符，默认是换行符
    - RS：输入文件的行分隔符，默认是换行符

# 15. Reference

- [十分钟学会 tmux](https://www.cnblogs.com/kaiye/p/6275207.html)
- [Bash快捷键大全](https://linux.cn/article-5660-1.html)
- [Terminator The robot future of terminals](https://gnometerminator.blogspot.com/p/introduction.html)
- [如何在Qt中使用正则表达式](https://blog.csdn.net/Hyc_cheng/article/details/112132963#t5)

