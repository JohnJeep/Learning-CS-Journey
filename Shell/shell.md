<!--
 * @Author: JohnJeep
 * @Date: 2020-10-30 09:38:07
 * @LastEditTime: 2020-11-05 16:19:59
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
-->

<!-- TOC -->

- [1. shell](#1-shell)
  - [1.1. 基本语法](#11-基本语法)
    - [1.1.1. 变量](#111-变量)
    - [1.1.2. 命令代换与通配符](#112-命令代换与通配符)
    - [1.1.3. 引号](#113-引号)
    - [1.1.4. test条件测试](#114-test条件测试)
    - [1.1.5. if 语句](#115-if-语句)
    - [1.1.6. case语句](#116-case语句)
    - [1.1.7. for 语句](#117-for-语句)
    - [1.1.8. while 语句](#118-while-语句)
    - [1.1.9. 函数](#119-函数)
    - [1.1.10. 命令行参数](#1110-命令行参数)
    - [1.1.11. shell调试](#1111-shell调试)
  - [1.2. 用户输入处理](#12-用户输入处理)
  - [1.3. 将脚本的输出重定向到Linux系统的不同位置](#13-将脚本的输出重定向到linux系统的不同位置)
    - [1.3.1. tee 命令](#131-tee-命令)
    - [1.3.2. 文件重定向](#132-文件重定向)
  - [1.4. 正则表达式](#14-正则表达式)
    - [1.4.1. 字符串限定符](#141-字符串限定符)
    - [1.4.2. 数量限定符](#142-数量限定符)
    - [1.4.3. 位置限定符](#143-位置限定符)
    - [1.4.4. 其他特殊字符](#144-其他特殊字符)
  - [1.5. sed用法](#15-sed用法)
  - [1.6. awk用法](#16-awk用法)

<!-- /TOC -->

# 1. shell

## 1.1. 基本语法
- 解释采用哪种shell运行脚本: `!#/bin/sh`
- 多条语句之间使用 `;` 分割开
- 输入的命令采用 `()` 括起来，shell会fork一个新的字shell进程执行括号里面的内容。
- 确定哪些命令是否属于shell内建命令：`type command`
- 数据类型：只有字符串类型。


### 1.1.1. 变量
- 一般自定义的变量名称使用大写来表示；使用 `$` 取出变量的值，使用`()` 取出命令的值。
- 本地变量: `VARNAME=value`。shell中默认的变量类型为字符串类型，定义时不需要指定类型。
- 环境变量: 将本地变量提升为环境变量，`export VARNAME=value`
- 删除已定义的环境变量或本地变量：`unset VARNAME`
- `env | grep VARNAME`: 查看系统中的环境变量 VARNAME


### 1.1.2. 命令代换与通配符
- 命令代换: `$(commmand)` 执行括号里面的命令功能。例如：`$(data)`
- 算术代换: 用于基本的算术计算。
  - `echo $[11+12]` 两个数相加
  - `echo $[2#10+16#12]` 二进制的 10 加上十六进制的 12，结果按照十进制显示

- 通配符
  - `*` : 匹配0个或多个任意的字符
  - `?` : 匹配任意一个字符
  - `[]`: 匹配中括号中任意出现的一个字符 


### 1.1.3. 引号
- 单引号与双引号的区别：被双引号括住的内容表示单一字符串，它防止通配符扩展，但允许变量扩展。被单引号括住的内容只能表示字符串。
  ```
  var=200      # =号两边不能有空格
  echo $var    # 200
  echo '$var'  # $var
  echo "$var"  # 200，打印变量var的内容
  ``` 


### 1.1.4. test条件测试
- `[ -p pipe ]` :左右括号分别表示一个命令，与参数之间需要使用空格隔开，并不是普通的括号。
- 数值比较
  - `-eq`: 等于
  - `-ge`: 大于等于
  - `-le`: 小于等于
  - `-ne`: 不等于
  - `-gt`: 大于
  - `-lt`: 小于
  - 不能在test命令中使用浮点值，bash shell只能处理整数。
- 字符串比较
  - 两个字符串之间可以使用 `>`、`<`、`=`、`!=` 来比较是否相同。
  - `-n str1`: 检查str1的长度是否非0
  - `-z str1`: 检查str1的长度是否为0 
- 文件比较
  - `-d file`: 检查file是否存在并是一个目录
  - `-e file`: 检查file是否存在
  - `-f file`: 检查file是否存在并是一个文件
  - `-r file`: 检查file是否存在并可读
  - `-s file`: 检查file是否存在并非空
  - `-w file`: 检查file是否存在并可写
  - `-x file`: 检查file是否存在并可执行
  - `-O file`: 检查file是否存在并属当前用户所有
  - `-G file`: 检查file是否存在并且默认组与当前用户相同
  - `file1 -nt file2`: 检查file1是否比file2新
  - `file1 -ot file2`: 检查file1是否比file2旧 
- 逻辑比较
  - `expr1 -a expr2`: 逻辑与
  - `expr1 -o expr2`: 逻辑或
  - `expr1 ! expr2` : 逻辑非 


### 1.1.5. if 语句
```
echo "Is it morning? Please answer yes or no."
read YES_OR_NO
if [ "$YES_OR_NO" = "yes" ]; then          # 取值必须使用 ""
    echo "Good moning!"
elif [ "$YES_OR_NO" = "no" ]; then
    echo "Good afternoon!"
else
    echo "Sorry, $YES_OR_NO not recognized. Enter yes or no."
fi
```

- 双括号 `((expression))` 命令允许你在比较过程中使用高级数学表达式。
  - 双括号命令中可以使用的符号：
  ```
  var++
  var--
  ++var
  --var
  !     # 逻辑求反
  !     # 位求反
  **    # 幂运算
  <<    # 左位移
  >>    # 右位移
  &     # 位与
  |     # 位或
  &&    # 逻辑与
  ||    #逻辑或

  val1=10
  if (( $val1 ** 2 > 90 ))
  then
    (( val2 = $val1 ** 2 ))
    echo "The square of $val1 is $val2"
  fi
  ```

### 1.1.6. case语句
- case 可以匹配字符串额通配符，每条分支语句必须以 `;;` 结尾。
- `esac` 表示整个 case 语句块的结束
```
#! /bin/bash
echo "Please input yes or no?"
read TMP     # 从内尺中读输入的变量
case "$TMP" in
    Yes|y|Y|YES)
        echo "It's ok.";;
    [nN]?)
        echo "It's not ok.";;
     *)
         echo "Input error.";;   # 默认执行
esac
return 0;
echo "exec return."   # 该条命令不执行
```

### 1.1.7. for 语句
```
# 利用ls命令判断当前目录下文件的的类型

#! /bin/bash
for name in $(ls); do
  printf "$name "
  if [ -d "$name" ]; then
    echo "It's a dir."
  elif [-f "$name" ]; then
    echo "It's a file."
  else
    echo "others."
  fi
done
```


### 1.1.8. while 语句
```
while [ ... ]
do 
  .....
done 
``` 


### 1.1.9. 函数
- 函数：shell函数体中没有函数参数和返回值，函数参数在运行时传递。
  - 格式
  ```
  // 第一种格式 name为函数名
  name()
  {
    ...
  }

  // 第二种方式: 采用function关键字，name为函数名，后面没有小括号
  function name
  {

  }
  ```
  - 返回值
    - 默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后（即执行完最后一条命令），可以用标准变量 `$?` 来确定函数的退出状态码。
    - 语句执行成功，退出状态码为 0，没有执行成功退出状态码为 1；退出状态码的范围在 0~255之间
    - 使用 `return` 命令来退出函数并返回特定的退出状态码。


### 1.1.10. 命令行参数
- `$0`: 获取shell在命令行启动的脚本名，会包含完整的脚本路径。去掉脚本的路径利用 `basenmae` 关键字实现。
- `$1`: 第一个参数 
- `$2`: 第二个参数 
- `$#`: 统计命令行参数的个数。
- `$*`: 将shell的所有参数当成单个参数。
- `$@`: 单独处理输入的每个参数。
- `$?` :保存上次已执行命令的退出状态码。一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态就是一个正值。无效命令会返回一个退出状态码127。
- `shift`: 默认情况下它会将每个参数变量向左移动一个位置，后面也可以指定移动多个参数的位置。如果某个参数被移出，它的值就被丢弃了，无法再恢复。


### 1.1.11. shell调试
- `. test.sh -n`: 检查test.sh脚本中是否有语法错误，但不执行脚本。
- `. test.sh -x`: 跟踪执行的信息，将执行的每一条结果和命令都打印出来。
 > 注意：需要在脚本的头部中添加 `#! /bin/bash -x` ，跟踪的前后添加 `set -x` 和 `set +x`


## 1.2. 用户输入处理
- `read` 命令
  - 从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后， read 命令会将数据放进一个变量中。
  - `-p` 参数：允许你直接在read命令行指定提示符。
  - `-t`选项: 指定一个计时器，等待输入的秒数，在指定的时间内输入值。当计时器过期后， read命令会返回一个非零退出状态码。
  - `-s` 参数：避免在read命令中输入的数据出现在显示器上，实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样。常常用于用户密码的输入。 `read -s -p "Enter your password: " pass`
 

## 1.3. 将脚本的输出重定向到Linux系统的不同位置
### 1.3.1. tee 命令
- 作用：将从 `STDIN` 过来的数据同时发送到显示器和日志文件中。
- 默认情况下， tee命令会在每次使用时覆盖输出文件内容。想将数据追加到文件中，必须用 `-a` 选项。


### 1.3.2. 文件重定向
- 三个标准文件描述符 
  - `STDIN`: 标准输入 0
  - `STDOUT`: 标准输出 1
  - `STDERR`: 标准错误 2
- `>`: 输出重定向。通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。
- `>>`: 追加
- `<`: 输入重定向。Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。
- 临时重定向：想在脚本中生成错误信息时，使用输出重定向符来将输出信息重定向到 `STDERR` 文件描述符，这种方法会重定向每条设定的语句。`echo "This is an error message" >&2`
- 永久重定向：脚本中用 `exec` 命令告诉shell在脚本执行期间重定向某个特定文件描述符，可以重定向大量的数据。`exec 1>test`


## 1.4. 正则表达式
- 两种流行的正则表达式引擎
  - POSIX基础正则表达式（ basic regular expression， BRE）引擎。例子：sed编辑器。
  - POSIX扩展正则表达式（ extended regular expression， ERE）引擎。例子：gawk工具。


### 1.4.1. 字符串限定符
- `.`: 匹配任意一个字符
- `[]`: 匹配括号中的任意一个字符
- `-`: 在[] 括号内表示字符范围。eg: `[0-9]`
- `^`: 位于[] 括号的开头，匹配除括号中的字符之外的任意一个字符。eg: `[^abf]` 匹配除abf字符以外的所有字符。
- `[[:xxx:]]`: grep工具转给你预定义的一些字符类


### 1.4.2. 数量限定符
- `?`: 匹配零次或一次
- `+`: 匹配一次或多次
- `*`: 匹配零次或多次
- `{N}`: 精确匹配N次
- `{N,}`: 至少匹配N次
- `{,N}`: 最多匹配N次
- `{M,N}`: 至少匹配M次，最多匹配N次


### 1.4.3. 位置限定符
- `^xxx`: 匹配以xxx开始的行
- `$xxx`: 匹配以xxx结束的行
- `xxx\<`: 匹配以xxx字符开头的单词 
- `xxx\>`: 匹配以xxx字符结尾的单词
- `\b`: 匹配以xxx字符开始或结尾的单词
- `\B`: 匹配不包含以xxx字符开始或结尾的单词。eg: \Bth\B----->mythed


### 1.4.4. 其他特殊字符
- `\`: 转义字符，可以将普通字符转义为特殊字符，也可以将特殊字符转义为普通字符。
- `()`: 将正则表达式的一部分使用括号括起来，组成一个单元，对整个单元使用数量限定符。
- `|`: 连接两个子表达式。


## 1.5. sed用法
sed俗称做流编辑器，以行单位进行字符处理。
- 格式
  - `sed 参数 '脚本语句' 带操作文件`
  - `sed 参数 -f '脚本文件' 带操作文件` 
- 脚本语句参数
  - `a(append)`：追加
  - `i(insert)`：插入
  - `d(delete)`：删除
  - `s(substitution)` : ` sed -i 's/echo/printf/g' for_tmp.sh` 将for_tmp.sh脚本文件中的所有echo替换为printf，使用 `-i` 参数并将修改的内容保存，而非仅仅输出显示到标准输出上。
- 选项参数
  - `-n`：默认情况下，脚本执行完后，自动打模式空间中的内容，使用 `-n` 可以屏蔽自动打印。
  - `-i`: 将修改后的源文件保存
  - `-E`：使用扩展正则表达式
  - `-e`: 使用多个脚本语句替换 时，需要用 `-e` 选项。


## 1.6. awk用法
以列单位进行字符处理，默认情况下按照TAB或空格对文件进行拆分。
- 格式
  - `awk 参数 '脚本语句' 带操作文件`。例子：`ps aux | awk '{print $3}'` 打印进程信息中的第三列
  - `awk 参数 -f '脚本文件' 带操作文件` 
- 变量
  - `print`: 打印输出变量，默认打印数据后自动会换行。
  - `printf`: 类似于C语言中的printf函数用法。  
  - 两个特殊的条件：BEGIN、END。例子：统计一个文件中的所有空格数 `awk '/^ *$/ {count=count+1} END {print count}' test.txt`
  - 常用内建变量
    - FILENAME：当前输入文件的文件名
    - NR：当前行的行号，R(record)
    - NF：当前行所拥有的的列数，F(field)
    - OFS：输出字段的列分隔符，默认是空格
    - FS：输入文件的列分隔符，默认是空格和TAB
    - ORS：输出字段的行分隔符，默认是换行符
    - RS：输入文件的行分隔符，默认是换行符

