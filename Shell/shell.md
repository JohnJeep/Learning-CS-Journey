<!--
 * @Author: JohnJeep
 * @Date: 2020-10-30 09:38:07
 * @LastEditTime: 2020-11-05 16:19:59
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
-->

<!-- TOC -->

- [1. shell](#1-shell)
  - [1.1. 常用 Bash终端快捷键](#11-常用-bash终端快捷键)
  - [1.2. Shell命令分为三大类](#12-shell命令分为三大类)
  - [1.3. 基本语法](#13-基本语法)
    - [1.3.1. 变量](#131-变量)
    - [1.3.2. 命令代换与通配符](#132-命令代换与通配符)
    - [1.3.3. 引号](#133-引号)
    - [1.3.4. test条件测试](#134-test条件测试)
    - [1.3.5. if 语句](#135-if-语句)
    - [1.3.6. case语句](#136-case语句)
    - [1.3.7. for 语句](#137-for-语句)
    - [1.3.8. while 语句](#138-while-语句)
    - [1.3.9. 函数](#139-函数)
    - [1.3.10. 命令行参数](#1310-命令行参数)
    - [1.3.11. shell调试](#1311-shell调试)
  - [1.4. 用户输入处理](#14-用户输入处理)
  - [1.5. 将脚本的输出重定向到Linux系统的不同位置](#15-将脚本的输出重定向到linux系统的不同位置)
    - [1.5.1. tee 命令](#151-tee-命令)
    - [1.5.2. 文件重定向](#152-文件重定向)
  - [1.6. 正则表达式](#16-正则表达式)
    - [1.6.1. 字符串限定符](#161-字符串限定符)
    - [1.6.2. 数量限定符](#162-数量限定符)
    - [1.6.3. 位置限定符](#163-位置限定符)
    - [1.6.4. 其他特殊字符](#164-其他特殊字符)
  - [1.7. sed用法](#17-sed用法)
  - [1.8. awk用法](#18-awk用法)

<!-- /TOC -->

# 1. shell


## 1.1. 常用 Bash终端快捷键
- 参考
  - [Bash快捷键大全](https://linux.cn/article-5660-1.html)
  - [Terminator The robot future of terminals](https://gnometerminator.blogspot.com/p/introduction.html)


> Ctrl开头的快捷键一般是针对字符的，而Alt开头的快捷键一般是针对词的。

1. 控制命令
- `Ctrl + d` : 退出当前终端（end of file）
- `Ctrl + c` : 强制终止当前命令，终止的是前台进程
- `Ctrl + z` : 将当前任务暂停并挂在后台
- `Ctrl + s`: 冻结当前terminal的stdin，键盘输入的数据不会马上在terminal显示，而是恢复冻结后，在当前光标之前显示输入的数据。（Suspend）
- `Ctrl +  q`: 恢复当前terminal的stdin（Resume）


- ` stop + job号`: 将前台的进程挂起
- ` fg `: 将后台中的命令调至前台继续运行
  > `fg %job number`: 将放在后台的任务通过指定其 `job number`，让它在前台工作。`%job number`是通过jobs命令查到的后台正在执行的命令的序号(不是pid，数字默认从 1 开始)
- `bg`: 进程转到后台
  > `bg %number` 直接让在后台暂停（stopping）的任务变为运行（running）状态。
- `jobs`：查看放在后台的所有任务。
  - `+` : 代表最近被放到后台的任务号码。
  - `-` : 代表最近第二个被放到后台中的任务号码。从第三个任务开始，每个任务前面不在有 `+` 或者 `-` 符号存在。

- 终止后台进程
  - `kill + job号`
  - `kill + PID`

- nohup:
  - 在用户注销或脱机后，任务还能继续在后天执行，与系统使用的terminal 无关。
  - 一般的任务管理的后台与所使用的terminal有关，terminal终止后，后台任务也就终止了。
  - 想要后台的任务在你注销用户后还能继续执行，可以使用 `nohup 结合 &` 搭配使用。


1. 大小写
- `esc + u:`  将当前光标之后以空格隔开的单词或者字符转换为大写，包括当前光标(upper)
- `esc + l:`  将当前光标之后以空格隔开的单词或者字符转换为大小，包括当前光标(lower)
- `esc + c:`  将当前光标之后以空格隔开的单词首字母转换为大写

3. 编辑
>擦除：输入的数据还在缓冲内存中，没有被删除，可以复制
- `Ctrl + a`：移动光标到命令行首。
- `Ctrl + e`：移动光标到命令行尾。
- `Ctrl + u`: 擦除当前光标之前的字符，不包括当前光标
- `Ctrl + k`: 擦除从当前光标之后到行尾的所有字符，包括当前光标
- `Ctrl + y`: 从当前光标处粘贴之前擦除的字符
- `Ctrl + w`: 删除当前光标之前以空格隔开的任意长度的字符，不包括当前光标
- `Alt + d` : 擦除当前光标之后的一个单词，包括当前光标
- `Ctrl + /`: 撤销之前擦除的所有字符
- `Ctrl + t`: 当前光标处字符与前一个字符交换位置
- `Alt + r` : 取消当前所有改变的操作，若当前命令从历史记录中来，返回上一次历史记录的原始状态，若当前命令是手动输入，则会清空当前行
- `Alt + t` : 当前光标处单词与前一个单词交换位置
- `Ctrl + h`: 删除当前光标前面的字符，每次删除一个字符
- `Ctrl + d`: 删除当前光标后面的字符，每次删除一个字符
- `Ctrl + b`: 光标向后(backward)移动，与 `←` 等价
- `Ctrl + f`: 光标向前移动(forward)，与 `→` 等价

4. 历史记录
- `Ctrl + r` 搜索历史记录
- `Ctrl + g` 退出当前搜索模式（在搜索历史记录下）
- `fc - l`   默认从最后往前显示 16 条历史记录。
- `Ctrl + p` 向上查找历史命令，与 `↑` 等价
- `Ctrl + n` 向下查找历史命令，与 `↓` 等价

5. 其它命令
- `cd - ` 在两个相邻的目录之间进行切换。
- ` ; ` 在一条行中执行多条命令，采用 ; 实现
- ` && ` 仅在上一个命令成功的情况下，才能执行后面的多个命令
- `lsblk` 以树状的格式列出块设备



## 1.2. Shell命令分为三大类
> - 查找某个命令属于哪类：`type -a <命令名称>`
- 内建命令(built-in)
- 外部命令
- 用户定义函数（function）、别名（alias）


## 1.3. 基本语法
- 解释采用哪种shell运行脚本: `!#/bin/sh`
- 多条语句之间使用 `;` 分割开
- 输入的命令采用 `()` 括起来，shell会fork一个新的字shell进程执行括号里面的内容。
- 确定哪些命令是否属于shell内建命令：`type command`
- 数据类型：只有字符串类型。


### 1.3.1. 变量
- 一般自定义的变量名称使用大写来表示；使用 `$` 取出变量的值，使用`()` 取出命令的值。
- 本地变量: `VARNAME=value`。shell中默认的变量类型为字符串类型，定义时不需要指定类型。
- 环境变量: 将本地变量提升为环境变量，`export VARNAME=value`
- 删除已定义的环境变量或本地变量：`unset VARNAME`
- `env | grep VARNAME`: 查看系统中的环境变量 VARNAME


### 1.3.2. 命令代换与通配符
- 命令代换: `$(commmand)` 执行括号里面的命令功能。例如：`$(data)`
- 算术代换: 用于基本的算术计算。
  - `echo $[11+12]` 两个数相加
  - `echo $[2#10+16#12]` 二进制的 10 加上十六进制的 12，结果按照十进制显示

- 通配符
  - `*` : 匹配0个或多个任意的字符
  - `?` : 匹配任意一个字符
  - `[]`: 匹配中括号中任意出现的一个字符 


### 1.3.3. 引号
- 单引号与双引号的区别：被双引号括住的内容表示单一字符串，它防止通配符扩展，但允许变量扩展。被单引号括住的内容只能表示字符串。
  ```
  var=200      # =号两边不能有空格
  echo $var    # 200
  echo '$var'  # $var
  echo "$var"  # 200，打印变量var的内容
  ``` 


### 1.3.4. test条件测试
- `[ -p pipe ]` :左右括号分别表示一个命令，与参数之间需要使用空格隔开，并不是普通的括号。
- 数值比较
  - `-eq`: 等于
  - `-ge`: 大于等于
  - `-le`: 小于等于
  - `-ne`: 不等于
  - `-gt`: 大于
  - `-lt`: 小于
  - 不能在test命令中使用浮点值，bash shell只能处理整数。
- 字符串比较
  - 两个字符串之间可以使用 `>`、`<`、`=`、`!=` 来比较是否相同。
  - `-n str1`: 检查str1的长度是否非0
  - `-z str1`: 检查str1的长度是否为0 
- 文件比较
  - `-d file`: 检查file是否存在并是一个目录
  - `-e file`: 检查file是否存在
  - `-f file`: 检查file是否存在并是一个文件
  - `-r file`: 检查file是否存在并可读
  - `-s file`: 检查file是否存在并非空
  - `-w file`: 检查file是否存在并可写
  - `-x file`: 检查file是否存在并可执行
  - `-O file`: 检查file是否存在并属当前用户所有
  - `-G file`: 检查file是否存在并且默认组与当前用户相同
  - `file1 -nt file2`: 检查file1是否比file2新
  - `file1 -ot file2`: 检查file1是否比file2旧 
- 逻辑比较
  - `expr1 -a expr2`: 逻辑与
  - `expr1 -o expr2`: 逻辑或
  - `expr1 ! expr2` : 逻辑非 


### 1.3.5. if 语句
```
echo "Is it morning? Please answer yes or no."
read YES_OR_NO
if [ "$YES_OR_NO" = "yes" ]; then          # 取值必须使用 ""
    echo "Good moning!"
elif [ "$YES_OR_NO" = "no" ]; then
    echo "Good afternoon!"
else
    echo "Sorry, $YES_OR_NO not recognized. Enter yes or no."
fi
```

- 双括号 `((expression))` 命令允许你在比较过程中使用高级数学表达式。
  - 双括号命令中可以使用的符号：
  ```
  var++
  var--
  ++var
  --var
  !     # 逻辑求反
  !     # 位求反
  **    # 幂运算
  <<    # 左位移
  >>    # 右位移
  &     # 位与
  |     # 位或
  &&    # 逻辑与
  ||    #逻辑或

  val1=10
  if (( $val1 ** 2 > 90 ))
  then
    (( val2 = $val1 ** 2 ))
    echo "The square of $val1 is $val2"
  fi
  ```

### 1.3.6. case语句
- case 可以匹配字符串额通配符，每条分支语句必须以 `;;` 结尾。
- `esac` 表示整个 case 语句块的结束
```
#! /bin/bash
echo "Please input yes or no?"
read TMP     # 从内尺中读输入的变量
case "$TMP" in
    Yes|y|Y|YES)
        echo "It's ok.";;
    [nN]?)
        echo "It's not ok.";;
     *)
         echo "Input error.";;   # 默认执行
esac
return 0;
echo "exec return."   # 该条命令不执行
```

### 1.3.7. for 语句
```
# 利用ls命令判断当前目录下文件的的类型

#! /bin/bash
for name in $(ls); do
  printf "$name "
  if [ -d "$name" ]; then
    echo "It's a dir."
  elif [-f "$name" ]; then
    echo "It's a file."
  else
    echo "others."
  fi
done
```


### 1.3.8. while 语句
```
while [ ... ]
do 
  .....
done 
``` 


### 1.3.9. 函数
- 函数：shell函数体中没有函数参数和返回值，函数参数在运行时传递。
  - 格式
  ```
  // 第一种格式 name为函数名
  name()
  {
    ...
  }

  // 第二种方式: 采用function关键字，name为函数名，后面没有小括号
  function name
  {

  }
  ```
  - 返回值
    - 默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后（即执行完最后一条命令），可以用标准变量 `$?` 来确定函数的退出状态码。
    - 语句执行成功，退出状态码为 0，没有执行成功退出状态码为 1；退出状态码的范围在 0~255之间
    - 使用 `return` 命令来退出函数并返回特定的退出状态码。


### 1.3.10. 命令行参数
- `$0`: 获取shell在命令行启动的脚本名，会包含完整的脚本路径。去掉脚本的路径利用 `basenmae` 关键字实现。
- `$1`: 第一个参数 
- `$2`: 第二个参数 
- `$#`: 统计命令行参数的个数。
- `$*`: 将shell的所有参数当成单个参数。
- `$@`: 单独处理输入的每个参数。
- `$?` :保存上次已执行命令的退出状态码。一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态就是一个正值。无效命令会返回一个退出状态码127。
- `shift`: 默认情况下它会将每个参数变量向左移动一个位置，后面也可以指定移动多个参数的位置。如果某个参数被移出，它的值就被丢弃了，无法再恢复。


### 1.3.11. shell调试
- `. test.sh -n`: 检查test.sh脚本中是否有语法错误，但不执行脚本。
- `. test.sh -x`: 跟踪执行的信息，将执行的每一条结果和命令都打印出来。
 > 注意：需要在脚本的头部中添加 `#! /bin/bash -x` ，跟踪的前后添加 `set -x` 和 `set +x`


## 1.4. 用户输入处理
- `read` 命令
  - 从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后， read 命令会将数据放进一个变量中。
  - `-p` 参数：允许你直接在read命令行指定提示符。
  - `-t`选项: 指定一个计时器，等待输入的秒数，在指定的时间内输入值。当计时器过期后， read命令会返回一个非零退出状态码。
  - `-s` 参数：避免在read命令中输入的数据出现在显示器上，实际上，数据会被显示，只是read命令会将文本颜色设成跟背景色一样。常常用于用户密码的输入。 `read -s -p "Enter your password: " pass`
 

## 1.5. 将脚本的输出重定向到Linux系统的不同位置
### 1.5.1. tee 命令
- 作用：将从 `STDIN` 过来的数据同时发送到显示器和日志文件中。
- 默认情况下， tee命令会在每次使用时覆盖输出文件内容。想将数据追加到文件中，必须用 `-a` 选项。


### 1.5.2. 文件重定向
- 三个标准文件描述符 
  - `STDIN`: 标准输入 0
  - `STDOUT`: 标准输出 1
  - `STDERR`: 标准错误 2
- `>`: 输出重定向。通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。
- `>>`: 追加
- `<`: 输入重定向。Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。
- 临时重定向：想在脚本中生成错误信息时，使用输出重定向符来将输出信息重定向到 `STDERR` 文件描述符，这种方法会重定向每条设定的语句。`echo "This is an error message" >&2`
- 永久重定向：脚本中用 `exec` 命令告诉shell在脚本执行期间重定向某个特定文件描述符，可以重定向大量的数据。`exec 1>test`


## 1.6. 正则表达式
- 两种流行的正则表达式引擎
  - POSIX基础正则表达式（ basic regular expression， BRE）引擎。例子：sed编辑器。
  - POSIX扩展正则表达式（ extended regular expression， ERE）引擎。例子：gawk工具。


### 1.6.1. 字符串限定符
- `.`: 匹配任意一个字符
- `[]`: 匹配括号中的任意一个字符
- `-`: 在[] 括号内表示字符范围。eg: `[0-9]`
- `^`: 位于[] 括号的开头，匹配除括号中的字符之外的任意一个字符。eg: `[^abf]` 匹配除abf字符以外的所有字符。
- `[[:xxx:]]`: grep工具转给你预定义的一些字符类


### 1.6.2. 数量限定符
- `?`: 匹配零次或一次
- `+`: 匹配一次或多次
- `*`: 匹配零次或多次
- `{N}`: 精确匹配N次
- `{N,}`: 至少匹配N次
- `{,N}`: 最多匹配N次
- `{M,N}`: 至少匹配M次，最多匹配N次


### 1.6.3. 位置限定符
- `^xxx`: 匹配以xxx开始的行
- `$xxx`: 匹配以xxx结束的行
- `xxx\<`: 匹配以xxx字符开头的单词 
- `xxx\>`: 匹配以xxx字符结尾的单词
- `\b`: 匹配以xxx字符开始或结尾的单词
- `\B`: 匹配不包含以xxx字符开始或结尾的单词。eg: \Bth\B----->mythed


### 1.6.4. 其他特殊字符
- `\`: 转义字符，可以将普通字符转义为特殊字符，也可以将特殊字符转义为普通字符。
- `()`: 将正则表达式的一部分使用括号括起来，组成一个单元，对整个单元使用数量限定符。
- `|`: 连接两个子表达式。


## 1.7. sed用法
sed俗称做流编辑器，以行单位进行字符处理。
- 格式
  - `sed 参数 '脚本语句' 带操作文件`
  - `sed 参数 -f '脚本文件' 带操作文件` 
- 脚本语句参数
  - `a(append)`：追加
  - `i(insert)`：插入
  - `d(delete)`：删除
  - `s(substitution)` : ` sed -i 's/echo/printf/g' for_tmp.sh` 将for_tmp.sh脚本文件中的所有echo替换为printf，使用 `-i` 参数并将修改的内容保存，而非仅仅输出显示到标准输出上。
- 选项参数
  - `-n`：默认情况下，脚本执行完后，自动打模式空间中的内容，使用 `-n` 可以屏蔽自动打印。
  - `-i`: 将修改后的源文件保存
  - `-E`：使用扩展正则表达式
  - `-e`: 使用多个脚本语句替换 时，需要用 `-e` 选项。


## 1.8. awk用法
以列单位进行字符处理，默认情况下按照TAB或空格对文件进行拆分。
- 格式
  - `awk 参数 '脚本语句' 带操作文件`。例子：`ps aux | awk '{print $3}'` 打印进程信息中的第三列
  - `awk 参数 -f '脚本文件' 带操作文件` 
- 变量
  - `print`: 打印输出变量，默认打印数据后自动会换行。
  - `printf`: 类似于C语言中的printf函数用法。  
  - 两个特殊的条件：BEGIN、END。例子：统计一个文件中的所有空格数 `awk '/^ *$/ {count=count+1} END {print count}' test.txt`
  - 常用内建变量
    - FILENAME：当前输入文件的文件名
    - NR：当前行的行号，R(record)
    - NF：当前行所拥有的的列数，F(field)
    - OFS：输出字段的列分隔符，默认是空格
    - FS：输入文件的列分隔符，默认是空格和TAB
    - ORS：输出字段的行分隔符，默认是换行符
    - RS：输入文件的行分隔符，默认是换行符

