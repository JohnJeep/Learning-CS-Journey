<!--
 * @Author: JohnJeep
 * @Date: 2025-11-01 16:46:49
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-11-20 11:29:00
 * @Description: C++14 新特性
 * Copyright (c) 2025 by John Jeep, All Rights Reserved. 
-->

- [1. C++14整体介绍](#1-c14整体介绍)
  - [1.1. 主要改进方向](#11-主要改进方向)
- [2. 逐个特性详解](#2-逐个特性详解)
  - [2.1. 泛型Lambda表达式](#21-泛型lambda表达式)
  - [2.2. Lambda捕获表达式](#22-lambda捕获表达式)
  - [2.3. 函数返回类型推导](#23-函数返回类型推导)
  - [2.4. 放松的constexpr限制](#24-放松的constexpr限制)
  - [2.5. 变量模板](#25-变量模板)
  - [2.6. 二进制字面量](#26-二进制字面量)
  - [2.7. 数字分位符](#27-数字分位符)
  - [2.8. 标准库用户定义字面量](#28-标准库用户定义字面量)
    - [2.8.1. std::chrono\_literals](#281-stdchrono_literals)
      - [2.8.1.1. 核心概念：它是什么？](#2811-核心概念它是什么)
      - [2.8.1.2. 如何使用：启用与语法](#2812-如何使用启用与语法)
      - [2.8.1.3. 完整的字面量列表](#2813-完整的字面量列表)
      - [2.8.1.4. 代码示例与实践](#2814-代码示例与实践)
        - [2.8.1.4.1. 示例 1：基础用法与线程休眠](#28141-示例-1基础用法与线程休眠)
        - [2.8.1.4.2. 示例 2：定义时间变量与运算](#28142-示例-2定义时间变量与运算)
        - [2.8.1.4.3. 示例 3：在容器和算法中使用](#28143-示例-3在容器和算法中使用)
      - [2.8.1.5. 类型安全与自动转换](#2815-类型安全与自动转换)
      - [2.8.1.6. 最佳实践与注意事项](#2816-最佳实践与注意事项)
      - [2.8.1.7. 总结](#2817-总结)
  - [2.9. std::make\_unique](#29-stdmake_unique)
  - [2.10. 编译时整数序列](#210-编译时整数序列)
  - [2.11. 共享互斥锁（std::shared\_timed\_mutex）](#211-共享互斥锁stdshared_timed_mutex)
  - [2.12. std::exchange](#212-stdexchange)
- [3. 三、综合应用示例](#3-三综合应用示例)
- [4. 四、总结](#4-四总结)


# 1. C++14整体介绍

C++14是C++11之后的一个增量更新版本，官方名称为"ISO/IEC 14882:2014"。它主要目标是完善和优化C++11引入的特性，而不是进行大规模的革命性改变。C++14的核心思想是"完成C++11开始的工作"。


## 1.1. 主要改进方向

1. **增强泛型编程能力**
2. **改进常量表达式支持**
3. **简化代码书写**
4. **增强运行时性能**
5. **修复C++11中的问题和限制**

# 2. 逐个特性详解

## 2.1. 泛型Lambda表达式

C++11中的Lambda表达式参数需要明确指定类型，C++14允许使用`auto`作为参数类型，使Lambda成为真正的泛型。

```cpp
// C++11方式
auto lambda11 = [](int x, int y) { return x + y; };

// C++14泛型Lambda
auto lambda14 = [](auto x, auto y) { return x + y; };

// 使用示例
int main() {
    auto result1 = lambda14(5, 3);        // int + int
    auto result2 = lambda14(3.14, 2.71);  // double + double
    auto result3 = lambda14(std::string("hello"), 
                           std::string(" world")); // string + string
    
    std::cout << result1 << std::endl; // 8
    std::cout << result2 << std::endl; // 5.85
    std::cout << result3 << std::endl; // "hello world"
    
    return 0;
}
```

## 2.2. Lambda捕获表达式

允许在Lambda捕获子句中使用表达式初始化捕获的变量。

```cpp
#include <iostream>
#include <memory>

void lambda_capture_demo() {
    std::unique_ptr<int> ptr(new int(42));
    
    // C++11方式：需要先在外部定义变量
    int value = *ptr;
    auto lambda11 = [value]() { return value; };
    
    // C++14方式：直接在捕获中初始化
    auto lambda14 = [value = *ptr]() { return value; };
    auto lambda_move = [ptr = std::move(ptr)]() { return *ptr; };
    
    std::cout << "Lambda14: " << lambda14() << std::endl;
    std::cout << "Lambda move: " << lambda_move() << std::endl;
}

// 实际应用：在异步编程中捕获移动语义对象
std::future<void> async_demo() {
    auto data = std::make_unique<std::vector<int>>(1000000, 42);
    
    return std::async([data = std::move(data)]() {
        // 在这里安全地使用data，不会发生拷贝
        std::cout << "Data size: " << data->size() << std::endl;
    });
}
```

## 2.3. 函数返回类型推导

允许使用`auto`作为函数返回类型，编译器会自动推导返回类型。

```cpp
// 简单的返回类型推导
auto add(int a, int b) {
    return a + b; // 推导为int
}

auto get_string() {
    return std::string("hello world"); // 推导为std::string
}

// 递归函数需要前向声明
auto factorial(int n) -> int; // 前向声明

auto factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// 模板函数中的返回类型推导
template<typename T, typename U>
auto multiply(T t, U u) {
    return t * u; // 返回类型为T和U的乘积类型
}

// 使用decltype(auto)保持引用语义
template<typename T>
decltype(auto) get_element(T& container, size_t index) {
    return container[index]; // 保持返回类型的引用性质
}

void return_type_demo() {
    auto result1 = add(3, 4);        // int
    auto result2 = multiply(2, 3.5); // double
    auto result3 = get_string();     // std::string
    
    std::vector<int> vec{1, 2, 3};
    auto& elem = get_element(vec, 1); // 返回引用，可以修改原值
    elem = 100;
    
    std::cout << "Vector: " << vec[1] << std::endl; // 输出100
}
```

## 2.4. 放松的constexpr限制

C++14大大放宽了constexpr函数的使用限制，允许更多的语句类型。

`constexpr` 函数的扩展：C++11 中，`constexpr` 函数只允许包含单个 return 语句。C++14 中允许 `constexpr` 函数中有多个 return 语句，也可以包含局部变量。

```cpp
class Point {
private:
    double x, y;
public:
    // constexpr构造函数
    constexpr Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    // constexpr成员函数
    constexpr double getX() const { return x; }
    constexpr double getY() const { return y; }
    
    // C++14允许constexpr函数中有修改操作
    constexpr void setX(double newX) { x = newX; }
    constexpr void setY(double newY) { y = newY; }
};

// constexpr函数中可以包含循环、条件语句等
constexpr int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

// constexpr函数中可以包含局部变量
constexpr double power(double base, int exp) {
    if (exp < 0) return 1.0 / power(base, -exp);
    
    double result = 1.0;
    for (int i = 0; i < exp; ++i) {
        result *= base;
    }
    return result;
}

void constexpr_demo() {
    // 编译时计算
    constexpr int fact5 = factorial(5);        // 120
    constexpr double pow2_10 = power(2.0, 10); // 1024.0
    
    // constexpr对象
    constexpr Point p(3.0, 4.0);
    constexpr double dist = p.getX() * p.getX() + p.getY() * p.getY();
    
    std::cout << "5! = " << fact5 << std::endl;
    std::cout << "2^10 = " << pow2_10 << std::endl;
    std::cout << "Distance squared: " << dist << std::endl;
}
```

## 2.5. 变量模板

允许定义模板化的变量，为元编程和常量定义提供了更多灵活性。

```cpp
#include <type_traits>

// 基本的变量模板
template<typename T>
constexpr T pi = T(3.1415926535897932385);

// 依赖于类型的变量模板
template<typename T>
constexpr bool is_integral_v = std::is_integral<T>::value;

// sizeof() 的变量模板：C++14 允许使用变量模板来获取对象的大小
template <typename T>
constexpr std::size_t size = sizeof(T);

template<typename T>
constexpr bool is_floating_point_v = std::is_floating_point<T>::value;

// 在元编程中的应用
template<typename... Types>
constexpr bool are_all_integral_v = (is_integral_v<Types> && ...);

// 实际应用：数学常数
template<typename T = double>
constexpr T e = T(2.7182818284590452353);

template<typename T = double>
constexpr T golden_ratio = T(1.6180339887498948482);

void variable_template_demo() {
    std::cout << "pi<double> = " << pi<double> << std::endl;
    std::cout << "pi<float> = " << pi<float> << std::endl;
    std::cout << "pi<int> = " << pi<int> << std::endl;
    
    std::cout << "is_integral_v<int> = " << is_integral_v<int> << std::endl;
    std::cout << "is_integral_v<double> = " << is_integral_v<double> << std::endl;
    
    std::cout << "All integral? " 
              << are_all_integral_v<int, long, unsigned> << std::endl;
              
    std::cout << "e = " << e<> << std::endl;
    std::cout << "Golden ratio = " << golden_ratio<> << std::endl;
}
```

1. 数组初始化的简化：C++14 允许在花括号中使用 “等号” 来表示“全部初始化为指定值”，如下所示：

   ```cpp
   int arr[10] = { 0 }; // 所有元素初始化为 0
   ```

2. 容器 `emplace_back()` 函数的改进：C++14 允许使用可变参数模板来调用 `emplace_back()` 函数。



## 2.6. 二进制字面量

引入`0b`或`0B`前缀来表示二进制字面量。

```cpp
void binary_literal_demo() {
    // 二进制字面量
    int binary1 = 0b1010;        // 十进制10
    int binary2 = 0B11110000;    // 十进制240
    unsigned long long binary3 = 0b11111111111111111111111111111111ULL;
    
    std::cout << "0b1010 = " << binary1 << std::endl;
    std::cout << "0B11110000 = " << binary2 << std::endl;
    std::cout << "32-bit mask = " << binary3 << std::endl;
    
    // 实际应用：位标志和掩码
    constexpr int READ = 0b0001;
    constexpr int WRITE = 0b0010;
    constexpr int EXECUTE = 0b0100;
    constexpr int ALL = 0b0111;
    
    int permissions = READ | WRITE;
    if (permissions & READ) {
        std::cout << "Read permission granted" << std::endl;
    }
}
```

## 2.7. 数字分位符

使用单引号作为数字字面量的分位符，提高大数字的可读性。

```cpp
void digit_separator_demo() {
    // 提高大数字的可读性
    long long big_number = 1'000'000'000;
    double pi_precise = 3.14159'26535'89793;
    unsigned int hex_value = 0xDEAD'BEEF;
    unsigned int binary_value = 0b1100'1010'1111'1110;
    
    std::cout << "Big number: " << big_number << std::endl;
    std::cout << "Precise PI: " << pi_precise << std::endl;
    std::cout << "Hex value: 0x" << std::hex << hex_value << std::endl;
    std::cout << "Binary value: 0b" << std::bitset<16>(binary_value) << std::endl;
    
    // 实际应用：金融、科学计算中的大数字
    constexpr double AVOGADRO = 6.022'140'857e23;
    constexpr long long NATIONAL_DEBT = 28'000'000'000'000LL;
    constexpr double LIGHT_YEAR_KM = 9'460'730'472'580.8;
}
```

## 2.8. 标准库用户定义字面量

为标准库类型提供内置的用户定义字面量支持。

```cpp
#include <chrono>
#include <complex>
#include <string>
#include <vector>

using namespace std::chrono_literals;
using namespace std::string_literals;
using namespace std::complex_literals;

void user_defined_literals_demo() {
    // 字符串字面量
    auto str = "hello world"s;  // std::string
    auto u8str = u8"UTF-8 string"s;
    auto wstr = L"wide string"s;
    
    // 时间字面量
    auto seconds = 30s;
    auto minutes = 5min;
    auto milliseconds = 100ms;
    auto hours = 2h;
    
    auto total_seconds = hours + minutes + seconds;
    std::cout << "Total seconds: " << total_seconds.count() << std::endl;
    
    // 复数字面量
    std::complex<double> z1 = 1.0 + 2.0i;
    std::complex<double> z2 = 3.0i;
    auto result = z1 * z2;
    
    std::cout << "Complex result: " << result << std::endl;
    
    // 实际应用：配置文件解析
    auto timeout = 5000ms;  // 5秒超时
    auto message = "Error: timeout occurred"s;
}
```



### 2.8.1. std::chrono_literals

这是一个在C++11引入，并在C++14中得以完善的、极大地提升了时间相关代码可读性和编写效率的特性。

#### 2.8.1.1. 核心概念：它是什么？

`std::chrono_literals` 是定义在 `<chrono>` 头文件中的一个**内联命名空间**，它包含了一系列用户定义字面量运算符，允许您以一种非常直观的方式在代码中表示时间间隔。

简单来说，它让你可以直接在数字后面加上 `s`、`ms`、`us` 等后缀来分别表示秒、毫秒、微秒等时间单位，而无需手动调用复杂的构造函数。

**没有它之前：**

```cpp
#include <chrono>
#include <thread>

// 传统的构造方式，冗长且容易出错
std::this_thread::sleep_for(std::chrono::milliseconds(100));
std::this_thread::sleep_for(std::chrono::seconds(5));
```

**有它之后：**

```cpp
#include <chrono>
#include <thread>

using namespace std::chrono_literals; // 引入字面量运算符

// 使用字面量，直观清晰
std::this_thread::sleep_for(100ms);
std::this_thread::sleep_for(5s);
```

#### 2.8.1.2. 如何使用：启用与语法

要使用这些字面量，你需要做两件事：

1. 包含 `<chrono>` 头文件。
2. **引入命名空间**：这是关键步骤。通常有三种方式：
   - **局部引入（推荐）**：在函数内部使用 `using namespace std::chrono_literals;`，避免污染全局命名空间。
   - **全局引入**：在文件顶部使用 `using namespace std::chrono_literals;`。
   - **显式调用**：不使用 `using`，而是直接通过命名空间调用，如 `auto timeout = std::chrono_literals::operator""s(5);`，但这非常繁琐，不推荐。

**基本语法：**
`数值 + 后缀`

例如：`42ns`, `100ms`, `5s`, `30min`, `24h`， 等等。

#### 2.8.1.3. 完整的字面量列表

下表列出了所有可用的时间字面量后缀及其对应的 `std::chrono::duration` 类型：

| 后缀  | 含义 | 类型 `std::chrono::...` |
| :---- | :--- | :---------------------- |
| `h`   | 小时 | `hours`                 |
| `min` | 分钟 | `minutes`               |
| `s`   | 秒   | `seconds`               |
| `ms`  | 毫秒 | `milliseconds`          |
| `us`  | 微秒 | `microseconds`          |
| `ns`  | 纳秒 | `nanoseconds`           |

**注意**：在C++14中引入了 `h`, `min`, `ms`, `us`, `ns`。`s` 后缀在C++14中也为 `std::chrono` 重载，但在C++11中它可能被解释为字符串字面量，因此C++14是完整使用此特性的最佳起点。

#### 2.8.1.4. 代码示例与实践

让我们通过一系列例子来看看它在实际中的强大之处。

##### 2.8.1.4.1. 示例 1：基础用法与线程休眠

这是最常见的使用场景。

```cpp
#include <iostream>
#include <chrono>
#include <thread>

using namespace std::chrono_literals;

int main() {
    std::cout << "开始等待...\n";
    
    // 清晰明了，无需思考 "1000 是秒还是毫秒？"
    std::this_thread::sleep_for(500ms); // 等待500毫秒
    std::cout << "500ms 过去了\n";
    
    std::this_thread::sleep_for(2s);    // 等待2秒
    std::cout << "2s 过去了\n";
    
    // 甚至可以使用浮点数！
    std::this_thread::sleep_for(1.5s);  // 等待1.5秒
    std::cout << "1.5s 过去了\n";

    return 0;
}
```

##### 2.8.1.4.2. 示例 2：定义时间变量与运算

`chrono_literals` 返回的是 `duration` 对象，它们支持各种算术运算。

```cpp
#include <iostream>
#include <chrono>

using namespace std::chrono_literals;

int main() {
    // 定义时间间隔变量
    auto delay = 250ms;
    auto timeout = 30s;
    auto long_time = 1h + 30min;

    // 时间运算
    auto total_wait = delay * 4 + timeout; // 250ms * 4 + 30s = 31s
    auto half_time = long_time / 2;        // (1h + 30min) / 2 = 45min

    std::cout << "total_wait 是 " << total_wait.count() << " 秒\n"; // 注意：这里输出的是其内部表示，可能不是秒
    // 更好的输出方式：使用 duration_cast
    std::cout << "total_wait 是 " 
              << std::chrono::duration_cast<std::chrono::seconds>(total_wait).count()
              << " 秒\n";

    std::cout << "half_time 是 " 
              << std::chrono::duration_cast<std::chrono::minutes>(half_time).count()
              << " 分钟\n";

    // 比较操作
    if (500ms > 0.4s) { // 自动进行单位转换和比较
        std::cout << "500ms 确实大于 0.4s\n";
    }

    return 0;
}
```

##### 2.8.1.4.3. 示例 3：在容器和算法中使用

```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <algorithm>

using namespace std::chrono_literals;

int main() {
    // 一个时间间隔的列表
    std::vector<std::chrono::milliseconds> timeouts = { 100ms, 200ms, 500ms, 1s, 2s };

    // 查找所有小于1秒的超时设置
    auto count = std::count_if(timeouts.begin(), timeouts.end(),
                              [](auto d) { return d < 1s; }); // 直接与 1s 比较

    std::cout << "有 " << count << " 个超时设置小于1秒。\n";

    // 计算总时间
    std::chrono::milliseconds total{0};
    for (const auto& t : timeouts) {
        total += t;
    }
    std::cout << "总时间是: " << total.count() << "ms\n";
    std::cout << "总时间是: " << std::chrono::duration_cast<std::chrono::seconds>(total).count() << "s\n";

    return 0;
}
```

#### 2.8.1.5. 类型安全与自动转换

`std::chrono` 是一个类型安全的系统。`5s` 和 `5000ms` 在逻辑上是相等的，但它们是不同的类型（`std::chrono::seconds` vs `std::chrono::milliseconds`）。

**隐式转换**：在 `std::chrono` 中，只有当转换不会导致精度丢失时，才会发生隐式转换。例如，从 `毫秒` 到 `秒` 的转换（整数到浮点数或可能丢失精度）需要显式进行，而从 `秒` 到 `毫秒` 的转换（可能会损失精度，例如 1.5s -> 1500ms）也需要显式进行。但 `chrono` 的模板系统会自动处理**公共周期**的转换。

```cpp
auto a = 5s;
auto b = 500ms;

// auto c = a + b; // 错误！在C++17之前，需要显式转换
auto c = a + std::chrono::duration_cast<std::chrono::seconds>(b); // 方法1：显式转换（b被截断为0s）
// 更好的方法：
auto d = a + b; // 正确！从C++17开始，运算符会自动找到公共类型（common_type），结果是 5500ms。
std::cout << d.count() << "ms\n"; // 输出 5500
```

#### 2.8.1.6. 最佳实践与注意事项

1.  **局部使用 `using namespace`**：在函数内部使用 `using namespace std::chrono_literals;`，避免在头文件或全局范围内使用，以防止命名冲突。
2.  **理解类型**：记住你得到的是一个 `duration` 对象，而不是一个简单的数字。使用 `.count()` 来获取其内部的数值表示。
3.  **注意单位**：`.count()` 返回的值是其定义的单位数量。例如，`5s.count()` 返回 `5`（秒），而 `5000ms.count()` 返回 `5000`（毫秒）。
4.  **用于 `std::chrono` API**：这些字面量主要用于接受 `std::chrono::duration` 参数的函数，如 `std::this_thread::sleep_for`, `std::condition_variable::wait_for`, 定时器等。

#### 2.8.1.7. 总结

`std::chrono_literals` 是C++现代化编程中一个“小而美”的典范。它通过简单的语法糖，将时间相关的代码从晦涩的数字和构造函数中解放出来，使其变得**自解释、类型安全且易于维护**。作为一名专业的C++工程师，在编写任何与时间相关的代码时，都应该优先考虑使用它。



## 2.9. std::make_unique

提供与std::make_shared对应的std::make_unique，用于创建unique_ptr。

```cpp
#include <memory>

class Resource {
private:
    std::string name;
    int value;
public:
    Resource(const std::string& n, int v) : name(n), value(v) {
        std::cout << "Resource " << name << " created\n";
    }
    
    ~Resource() {
        std::cout << "Resource " << name << " destroyed\n";
    }
    
    void use() {
        std::cout << "Using resource " << name << " with value " << value << std::endl;
    }
};

void make_unique_demo() {
    // 创建unique_ptr的推荐方式
    auto resource1 = std::make_unique<Resource>("res1", 100);
    auto resource2 = std::make_unique<Resource>("res2", 200);
    
    resource1->use();
    resource2->use();
    
    // 数组支持
    auto array = std::make_unique<int[]>(10);
    for (int i = 0; i < 10; ++i) {
        array[i] = i * i;
    }
    
    // 在容器中使用
    std::vector<std::unique_ptr<Resource>> resources;
    resources.push_back(std::make_unique<Resource>("vector_res1", 300));
    resources.push_back(std::make_unique<Resource>("vector_res2", 400));
    
    for (const auto& res : resources) {
        res->use();
    }
}
```

## 2.10. 编译时整数序列

引入`std::integer_sequence`和  `std::index_sequence`，用于编译时整数序列处理。

```cpp
#include <utility>
#include <array>

template<typename T, T... Ints>
void print_sequence(std::integer_sequence<T, Ints...>) {
    std::cout << "Sequence: ";
    ((std::cout << Ints << " "), ...);
    std::cout << std::endl;
}

// 使用整数序列展开参数包
template<typename Tuple, size_t... Indices>
void print_tuple_impl(const Tuple& t, std::index_sequence<Indices...>) {
    std::cout << "Tuple: ";
    (..., (std::cout << std::get<Indices>(t) << " "));
    std::cout << std::endl;
}

template<typename... Types>
void print_tuple(const std::tuple<Types...>& t) {
    print_tuple_impl(t, std::index_sequence_for<Types...>{});
}

// 创建数组的编译时助手
template<typename T, size_t N, size_t... Indices>
constexpr std::array<T, N> make_array_impl(const T& value, std::index_sequence<Indices...>) {
    return {{(static_cast<void>(Indices), value)...}};
}

template<typename T, size_t N>
constexpr std::array<T, N> make_array(const T& value) {
    return make_array_impl<T, N>(value, std::make_index_sequence<N>{});
}

void integer_sequence_demo() {
    // 基本整数序列
    auto seq1 = std::integer_sequence<int, 1, 2, 3, 4, 5>();
    auto seq2 = std::make_integer_sequence<int, 5>(); // 0,1,2,3,4
    
    print_sequence(seq1);
    print_sequence(seq2);
    
    // 索引序列应用
    auto t = std::make_tuple(1, 3.14, "hello", 'X');
    print_tuple(t);
    
    // 编译时创建数组
    constexpr auto arr = make_array<int, 5>(42);
    std::cout << "Constant array: ";
    for (auto val : arr) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
}
```

## 2.11. 共享互斥锁（std::shared_timed_mutex）

引入读写锁，支持共享读和独占写。

```cpp
#include <shared_mutex>
#include <thread>
#include <vector>

class ThreadSafeCounter {
private:
    mutable std::shared_timed_mutex mutex_;
    int value_ = 0;
public:
    // 多个线程可以同时读
    int get() const {
        std::shared_lock<std::shared_timed_mutex> lock(mutex_);
        return value_;
    }
    
    // 只有一个线程可以写
    void increment() {
        std::unique_lock<std::shared_timed_mutex> lock(mutex_);
        ++value_;
    }
    
    // 带超时的写锁尝试
    bool try_increment() {
        std::unique_lock<std::shared_timed_mutex> lock(mutex_, std::try_to_lock);
        if (lock.owns_lock()) {
            ++value_;
            return true;
        }
        return false;
    }
};

void shared_mutex_demo() {
    ThreadSafeCounter counter;
    std::vector<std::thread> threads;
    
    // 创建多个读线程
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back([&counter, i]() {
            for (int j = 0; j < 10; ++j) {
                std::cout << "Reader " << i << ": " << counter.get() << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
    }
    
    // 创建写线程
    threads.emplace_back([&counter]() {
        for (int i = 0; i < 10; ++i) {
            counter.increment();
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        }
    });
    
    for (auto& t : threads) {
        t.join();
    }
}
```

## 2.12. std::exchange

提供原子性的值交换操作，常用于移动语义和资源管理。

```cpp
#include <utility>

class ResourceManager {
private:
    std::vector<int> data;
public:
    ResourceManager(std::initializer_list<int> init) : data(init) {}
    
    // 使用std::exchange实现移动构造函数
    ResourceManager(ResourceManager&& other) noexcept 
        : data(std::exchange(other.data, {})) {}
    
    // 使用std::exchange实现移动赋值运算符
    ResourceManager& operator=(ResourceManager&& other) noexcept {
        if (this != &other) {
            data = std::exchange(other.data, {});
        }
        return *this;
    }
    
    // 清空并返回原有数据
    std::vector<int> release() {
        return std::exchange(data, {});
    }
    
    void print() const {
        std::cout << "Data: ";
        for (auto val : data) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
};

void exchange_demo() {
    // 基本用法
    int a = 10;
    int b = 20;
    
    std::cout << "Before exchange: a=" << a << ", b=" << b << std::endl;
    
    int old_a = std::exchange(a, b);
    
    std::cout << "After exchange: a=" << a << ", b=" << b 
              << ", old_a=" << old_a << std::endl;
    
    // 在资源管理中的应用
    ResourceManager rm1{1, 2, 3, 4, 5};
    ResourceManager rm2{10, 20, 30};
    
    std::cout << "Before move:" << std::endl;
    rm1.print();
    rm2.print();
    
    rm1 = std::move(rm2);
    
    std::cout << "After move:" << std::endl;
    rm1.print();
    rm2.print();
    
    // 释放资源
    auto released_data = rm1.release();
    std::cout << "Released data size: " << released_data.size() << std::endl;
    rm1.print();
}
```

# 3. 三、综合应用示例

下面是一个综合运用多个C++14特性的完整示例：

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>
#include <numeric>

// 使用变量模板定义数学常数
template<typename T = double>
constexpr T pi = T(3.1415926535897932385);

// 使用constexpr函数进行编译时计算
constexpr double circle_area(double radius) {
    return pi<> * radius * radius;
}

// 使用泛型Lambda和返回类型推导
auto create_multiplier(auto factor) {
    return [factor](auto value) { return value * factor; };
}

// 使用二进制字面量和数字分位符定义标志位
enum class Permissions : uint8_t {
    NONE    = 0b0000,
    READ    = 0b0001,
    WRITE   = 0b0010, 
    EXECUTE = 0b0100,
    ALL     = 0b0111
};

class Shape {
public:
    virtual ~Shape() = default;
    virtual double area() const = 0;
};

class Circle : public Shape {
private:
    double radius_;
public:
    constexpr Circle(double radius) : radius_(radius) {}
    
    constexpr double area() const override {
        return circle_area(radius_);
    }
};

void comprehensive_demo() {
    // 使用make_unique创建对象
    auto shapes = std::vector<std::unique_ptr<Shape>>();
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Circle>(10.0));
    
    // 使用泛型Lambda和算法
    auto multiplier = create_multiplier(2.5);
    std::vector<double> values{1.0, 2.0, 3.0, 4.0, 5.0};
    
    std::cout << "Original values: ";
    for (auto v : values) std::cout << v << " ";
    std::cout << std::endl;
    
    std::transform(values.begin(), values.end(), values.begin(), multiplier);
    
    std::cout << "After transformation: ";
    for (auto v : values) std::cout << v << " ";
    std::cout << std::endl;
    
    // 使用二进制标志
    Permissions user_perms = Permissions::READ | Permissions::WRITE;
    std::cout << "User permissions: " << static_cast<int>(user_perms) << std::endl;
    
    // 编译时计算
    constexpr double computed_area = circle_area(2.0);
    std::cout << "Compile-time computed area: " << computed_area << std::endl;
}

int main() {
    comprehensive_demo();
    return 0;
}
```

# 4. 四、总结

C++14虽然是一个增量版本，但它提供了许多实用的改进：

1. **编码效率提升**：泛型Lambda、返回类型推导、数字分位符等让代码更简洁
2. **编译时能力增强**：放松的constexpr、变量模板等加强了元编程能力
3. **运行时性能优化**：std::make_unique、共享互斥锁等提高了运行时效率
4. **类型安全改进**：用户定义字面量、std::exchange等增强了类型安全性

这些特性使得C++14成为一个更加成熟、易用和强大的版本，为后续的C++17奠定了坚实的基础。



