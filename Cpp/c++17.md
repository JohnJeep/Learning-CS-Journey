# C++17 新特性

## 第一部分：整体认识

C++17的定位是“让C++更简单、更统一、更强大”，它引入了大量提升开发效率的改进。C++17并非像C++11那样颠覆性的革新，而更像是对C++11/14的完善和“查漏补缺”。它的核心思想可以概括为以下几点：

1.  **简化日常编程**：提供了更多“语法糖”，让常见的代码模式写起来更简洁、更安全（如结构化绑定、`if`初始化语句）。
2.  **强化编译期计算**：继续拓展`constexpr`的使用范围，让更多逻辑能在编译期完成（如`constexpr if`、`constexpr lambda`）。
3.  **丰富标准库**：引入了几个至关重要的新类型（`std::optional`, `std::variant`, `std::any`, `std::string_view`）和一套文件系统库。
4.  **提升性能与效率**：通过移动语义的优化、新的内存分配方式等，继续挖掘语言性能潜力。
5.  **增强模板元编程**：折叠表达式等特性让模板代码变得更简洁、更易读。

下面，我们将按照分类逐个详细介绍这些新特性。

---

## 第二部分：逐个特性详解

### 语言核心特性

#### 1. 结构化绑定

**目的**：将一个复合类型（如`std::pair`, `tuple`, 结构体）的成员分解到多个独立的变量中。

**用法**：
```cpp
#include <iostream>
#include <tuple>
#include <map>

std::tuple<int, double, std::string> get_data() {
    return {42, 3.14, "Hello"};
}

struct Point {
    double x, y;
};

int main() {
    // 1. 绑定到 tuple
    auto [id, value, name] = get_data();
    std::cout << id << ", " << value << ", " << name << std::endl;

    // 2. 绑定到结构体
    Point p{1.0, 2.0};
    auto [x_coord, y_coord] = p; // x_coord = p.x, y_coord = p.y
    std::cout << x_coord << ", " << y_coord << std::endl;

    // 3. 在范围for循环中绑定到 map 的键值对 (非常实用!)
    std::map<int, std::string> my_map = {{1, "one"}, {2, "two"}};
    for (const auto& [key, val] : my_map) { // 不再需要 .first 和 .second
        std::cout << key << ": " << val << std::endl;
    }

    return 0;
}
```

#### 2. 类模板参数推导
**目的**：在构造类模板对象时，编译器可以根据构造函数参数自动推导模板参数，无需显式指定。

**用法**：
```cpp
#include <vector>
#include <mutex>

int main() {
    // C++17 之前: std::vector<int> v = {1, 2, 3};
    std::vector v = {1, 2, 3}; // 自动推导为 std::vector<int>

    // C++17 之前: std::pair<int, double> p(1, 3.14);
    std::pair p(1, 3.14); // 自动推导为 std::pair<int, double>

    // 对于锁，推导也非常方便
    std::mutex mtx;
    std::lock_guard lck(mtx); // 自动推导为 std::lock_guard<std::mutex>
    // ... 临界区

    return 0;
}
```
**注意**：CTAD需要类的构造函数能够提供足够的类型信息。你也可以通过提供**推导指引**来定制推导行为。

#### 3. `constexpr if`
**目的**：在编译期进行条件判断，用于简化模板代码和生成不同的代码路径。被舍弃的分支**不会产生任何代码**。

**用法**：
```cpp
#include <iostream>
#include <type_traits>

// 一个经典的模板问题：如何根据T是否为整数类型选择不同实现？
template <typename T>
auto print_type_info(const T& t) {
    // 使用 constexpr if，代码非常清晰
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integral: " << t << std::endl;
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Floating point: " << t << std::endl;
    } else {
        std::cout << "Other type." << std::endl;
    }
    // 注意：不需要多个重载或 SFINAE 技巧！
}

int main() {
    print_type_info(10);    // 输出 "Integral: 10"
    print_type_info(3.14);  // 输出 "Floating point: 3.14"
    print_type_info("abc"); // 输出 "Other type."
    return 0;
}
```
这是模板元编程的一大进步，极大地减少了`std::enable_if`等复杂技巧的使用。

#### 4. 初始化语句的`if`和`switch`
**目的**：允许在`if`和`switch`的条件表达式前增加一条初始化语句，限制变量的作用域。

**用法**：
```cpp
#include <iostream>
#include <map>

std::map<int, std::string> my_map = {{1, "one"}};

void check_and_use(int key) {
    // 初始化语句中声明变量，其作用域仅限于 if 和 else 块
    if (auto it = my_map.find(key); it != my_map.end()) {
        std::cout << "Found: " << it->second << std::endl;
    } else {
        std::cout << "Key " << key << " not found." << std::endl;
        // it 在这里仍然可见，但值是 end()
    }
    // it 在这里不可见
}

int main() {
    check_and_use(1);
    check_and_use(2);

    // 在 switch 中使用
    switch (int status = get_status(); status) {
        case 0: std::cout << "OK"; break;
        case 1: std::cout << "Error"; break;
        default: std::cout << "Unknown"; break;
    }
    return 0;
}
```
这提高了代码的封装性和安全性，避免了不必要的变量泄露到外部作用域。

#### 5. 内联变量
**目的**：允许在头文件中定义（而不仅仅是声明）全局变量或静态成员变量，解决“头文件中定义`constexpr`变量”的ODR（单定义规则）问题。

**用法**：
```cpp
// my_header.h
#ifndef MY_HEADER_H
#define MY_HEADER_H

// C++17 之前，在头文件中定义全局变量会导致多重定义链接错误
// 现在可以了！
inline int global_counter = 0;

class MyClass {
public:
    // 静态成员变量可以直接在类内定义并初始化
    static inline std::string class_name = "MyClass";
    static const inline int version = 1; // constexpr 成员默认是 inline 的
};

#endif
```
这简化了单例模式（如Meyers‘ Singleton）的实现，并且是定义全局编译时常量的推荐方式。

#### 6. 折叠表达式
**目的**：简化对参数包的可变参数模板的展开操作，用更简洁的语法实现对参数包中所有元素进行二元运算。

**用法**：
```cpp
#include <iostream>

// 1. 计算所有参数的和 (二元折叠)
template<typename... Args>
auto sum(Args... args) {
    return (... + args); // 展开为 ((arg1 + arg2) + arg3) + ...
}

// 2. 打印所有参数 (一元折叠)
template<typename... Args>
void print_all(Args&&... args) {
    (std::cout << ... << args) << std::endl; // 折叠方向：(((cout << a) << b) << c)
}

// 3. 用逗号分隔调用函数 (利用逗号运算符)
template<typename... Args>
void call_all(Args... args) {
    (..., (std::cout << args << " ")); // 展开为 (void(cout<<a1<<" "), void(cout<<a2<<" ")), ...
}

int main() {
    std::cout << sum(1, 2, 3, 4, 5) << std::endl; // 输出 15
    print_all(1, " hello ", 3.14); // 输出 "1 hello 3.14"
    call_all(10, 20, 30); // 输出 "10 20 30 "
    return 0;
}
```
折叠表达式让可变参数模板的代码变得异常简洁。

#### 7. 嵌套命名空间定义
**目的**：简化嵌套命名空间的声明语法。

**用法**：
```cpp
// C++17 之前
namespace A {
    namespace B {
        namespace C {
            int var;
        }
    }
}

// C++17 之后
namespace A::B::C {
    int var;
}
```

#### 8. `__has_include` 预处理表达式
**目的**：在编译期检查某个头文件是否可用，便于编写可移植代码。

**用法**：
```cpp
#if __has_include(<optional>)
    #include <optional>
    #define HAVE_OPTIONAL 1
#elif __has_include(<experimental/optional>)
    #include <experimental/optional>
    #define HAVE_OPTIONAL 1
    // 可能需要别名 namespace std { using std::experimental::optional; }
#else
    #define HAVE_OPTIONAL 0
#endif

#if HAVE_OPTIONAL
    std::optional<int> opt;
#endif
```

#### 9. UTF-8 字符字面量
**目的**：用`u8`前缀明确表示UTF-8编码的字符和字符串。

**用法**：
```cpp
char8_t c = u8'a'; // C++17 引入了 char8_t 类型 (C++20 中完善)
const char* utf8_str = u8"UTF-8 字符串";
```

#### 10. 确保拷贝消除
**目的**：在某些情况下（如按值返回纯右值），C++17标准强制要求编译器进行拷贝消除，而不是可选的RVO/NRVO。

**用法**：
```cpp
struct NonCopyable {
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete; // 禁止拷贝
};

NonCopyable create() {
    return NonCopyable{}; // 在 C++17 中合法，保证不会发生拷贝
}

auto obj = create(); // 同样合法
```
这意味着你可以安全地返回不可拷贝/移动的类型。

---

### 标准库新组件

#### 1. `std::optional<T>`
**目的**：表示一个“可能存在的值”。它是`T`的包装器，既可以包含一个`T`类型的值，也可以不包含任何值（处于“空”状态）。完美替代了使用特殊值（如`-1`, `nullptr`）表示“无值”的做法。

**用法**：
```cpp
#include <iostream>
#include <optional>
#include <string>

std::optional<int> find_item(const std::vector<int>& vec, int target) {
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (*it == target) {
            return *it; // 返回包含值的 optional
        }
    }
    return std::nullopt; // 返回空的 optional
}

std::optional<std::string> create_string(bool flag) {
    if (flag) {
        return "Hello, World!";
    }
    return {}; // 隐式返回空
}

int main() {
    std::vector<int> data = {1, 2, 3};
    auto result = find_item(data, 2);

    // 检查是否有值
    if (result.has_value()) { // 或者 if (result)
        std::cout << "Found: " << result.value() << std::endl; // 或者 *result
    }

    // 使用 value_or 提供默认值
    auto no_result = find_item(data, 42);
    std::cout << "Value is: " << no_result.value_or(-1) << std::endl; // 输出 -1

    return 0;
}
```

#### 2. `std::variant<Types...>`

**目的**：类型安全的联合体。可以持有指定类型集合中的任意一种类型的值。

**用法**：
```cpp
#include <iostream>
#include <variant>
#include <string>

int main() {
    std::variant<int, double, std::string> v;

    v = 42;
    std::cout << std::get<int>(v) << std::endl; // 通过类型获取

    v = 3.14;
    // std::cout << std::get<int>(v) << std::endl; // 错误！抛出 std::bad_variant_access
    std::cout << std::get<double>(v) << std::endl;

    v = "hello";
    std::cout << std::get<2>(v) << std::endl; // 通过索引获取

    // 使用 visit 来访问 (最强大的功能)
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, int>) {
            std::cout << "int: " << arg << std::endl;
        } else if constexpr (std::is_same_v<T, double>) {
            std::cout << "double: " << arg << std::endl;
        } else if constexpr (std::is_same_v<T, std::string>) {
            std::cout << "string: " << arg << std::endl;
        }
    }, v);

    return 0;
}
```

#### 3. `std::any`
**目的**：一个类型安全的`void*`。可以存储任意类型的值，并在运行时安全地检索。

**用法**：
```cpp
#include <iostream>
#include <any>
#include <string>

int main() {
    std::any a = 1;
    std::cout << std::any_cast<int>(a) << std::endl; // 输出 1

    a = std::string("hello");
    std::cout << std::any_cast<std::string>(a) << std::endl; // 输出 "hello"

    // 错误类型转换会抛出 std::bad_any_cast
    try {
        std::cout << std::any_cast<int>(a) << std::endl;
    } catch (const std::bad_any_cast& e) {
        std::cout << "Bad any cast: " << e.what() << std::endl;
    }

    // 检查类型
    if (a.type() == typeid(std::string)) {
        std::cout << "a holds a string" << std::endl;
    }

    return 0;
}
```
**对比**：
- `optional`: 有值/无值。
- `variant`: 多个已知类型中的一个。
- `any`: 任意一个未知类型。

#### 4. `std::string_view`
**目的**：提供对字符串数据的**只读、非占有式**视图。避免了不必要的字符串拷贝，极大地提升了性能。

**用法**：
```cpp
#include <iostream>
#include <string>
#include <string_view>

// 接受 string_view 作为参数，高效且灵活
void print_string(std::string_view sv) {
    std::cout << sv << std::endl;
}

int main() {
    std::string str = "Hello, World!";
    const char* cstr = "C-style string";

    // 以下调用都无需创建新的 string 对象
    print_string(str);                // 来自 std::string
    print_string(cstr);               // 来自 C风格字符串
    print_string("String literal");   // 来自字面量
    print_string(std::string_view(str.c_str(), 5)); // 子串 "Hello"

    // string_view 的常用操作
    std::string_view sv = "This is a string view";
    std::cout << "Size: " << sv.size() << std::endl;
    std::cout << "Substr: " << sv.substr(5, 2) << std::endl; // "is"

    // **重要警告**: string_view 不管理生命周期！
    // 它指向的原始字符串必须比 string_view 本身活得更久！
    std::string_view dangerous_view;
    {
        std::string temp = "Temporary string";
        dangerous_view = temp; // 错误！temp 即将被销毁！
    } // temp 被销毁，dangerous_view 成为悬垂视图
    // std::cout << dangerous_view << std::endl; // 未定义行为！

    return 0;
}
```
**最佳实践**：在函数参数中，优先使用`std::string_view`代替`const std::string&`或`const char*`，除非你需要修改字符串或保证以空字符结尾。

#### 5. 文件系统库 (`std::filesystem`)
**目的**：提供一套跨平台的文件和目录操作接口。

**用法**：
```cpp
#include <iostream>
#include <filesystem>
namespace fs = std::filesystem;

int main() {
    // 路径操作
    fs::path p = "/usr/local/bin/my_app";
    std::cout << "Filename: " << p.filename() << std::endl;   // "my_app"
    std::cout << "Extension: " << p.extension() << std::endl; // ""
    std::cout << "Parent: " << p.parent_path() << std::endl;  // "/usr/local/bin"

    // 检查文件状态
    if (fs::exists(p)) {
        std::cout << "File exists." << std::endl;
        if (fs::is_regular_file(p)) {
            std::cout << "Size: " << fs::file_size(p) << " bytes" << std::endl;
        }
    }

    // 遍历目录
    for (const auto& entry : fs::directory_iterator("/tmp")) {
        std::cout << entry.path() << std::endl;
    }

    // 创建目录和文件
    fs::create_directories("/tmp/my_new_dir");
    std::ofstream("/tmp/my_new_dir/file.txt") << "content";

    // 拷贝、重命名、删除
    fs::copy("/tmp/my_new_dir/file.txt", "/tmp/backup.txt");
    fs::rename("/tmp/backup.txt", "/tmp/backup_renamed.txt");
    fs::remove("/tmp/backup_renamed.txt");

    return 0;
}
```

#### 6. 并行算法
**目的**：为标准库中的许多算法（如`std::sort`, `std::for_each`, `std::transform`）提供并行执行版本。

**用法**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <execution> // 引入执行策略

int main() {
    std::vector<int> data(1000000);

    // 顺序执行 (默认)
    std::sort(data.begin(), data.end());

    // 并行执行
    std::sort(std::execution::par, data.begin(), data.end());

    // 向量化并行执行 (如果硬件支持)
    std::sort(std::execution::par_unseq, data.begin(), data.end());

    // 其他支持并行化的算法
    std::for_each(std::execution::par, data.begin(), data.end(), [](int& n) {
        n *= 2;
    });

    return 0;
}
```
**执行策略**：
- `seq`： 顺序执行。
- `par`： 并行执行。
- `par_unseq`： 并行且向量化执行。

---

### 其他重要特性

- **`std::byte`**: 表示原生内存的类型，取代`char`或`unsigned char`进行位操作，更语义化。
- **`std::scoped_lock`**: 用于同时锁定多个互斥量而不死锁，比`std::lock_guard`更强大。
- **`std::shared_mutex` / `std::shared_lock`**: 实现读写锁，允许多个读或一个写。
- **`splicing for maps and sets`**: 允许在无需拷贝/移动元素的情况下，在同类容器之间移动节点。
- **数学特殊函数**: 如`std::beta`, `std::legendre`等。

---

## 总结

C++17是一个“实用性”极强的版本，它没有引入特别复杂的新概念，而是专注于解决实际开发中的痛点。通过引入`optional`, `variant`, `string_view`等工具，以及结构化绑定、`constexpr if`等语法糖，它让C++代码变得更安全、更高效、更易于编写和维护。

作为一名C++工程师，熟练掌握C++17特性是现代C++开发的必备技能。建议在实践中逐步引入这些特性，它们将极大地提升你的代码质量和开发效率。
