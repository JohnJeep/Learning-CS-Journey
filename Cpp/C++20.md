<!--
 * @Author: JohnJeep
 * @Date: 2025-11-01 16:46:49
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-11-20 11:48:07
 * @Description: C++20 æ–°ç‰¹æ€§
 * Copyright (c) 2025 by John Jeep, All Rights Reserved. 
-->

C++20 æ–°ç‰¹æ€§

- [1. æ•´ä½“æ¦‚è¿°](#1-æ•´ä½“æ¦‚è¿°)
  - [1.1. ğŸ¯ å››å¤§æ”¯æŸ±ç‰¹æ€§](#11--å››å¤§æ”¯æŸ±ç‰¹æ€§)
  - [1.2. ğŸ”§ è¯­è¨€æ ¸å¿ƒæ”¹è¿›](#12--è¯­è¨€æ ¸å¿ƒæ”¹è¿›)
  - [1.3. ğŸ“š æ ‡å‡†åº“å¢å¼º](#13--æ ‡å‡†åº“å¢å¼º)
- [2. æ¨¡å—ï¼ˆModulesï¼‰](#2-æ¨¡å—modules)
  - [2.1. è§£å†³çš„é—®é¢˜](#21-è§£å†³çš„é—®é¢˜)
  - [2.2. åŸºæœ¬ç”¨æ³•](#22-åŸºæœ¬ç”¨æ³•)
  - [2.3. æ¨¡å—åˆ†åŒº](#23-æ¨¡å—åˆ†åŒº)
  - [2.4. ä¼˜åŠ¿](#24-ä¼˜åŠ¿)
- [3. åç¨‹ï¼ˆCoroutinesï¼‰](#3-åç¨‹coroutines)
  - [3.1. æ ¸å¿ƒæ¦‚å¿µ](#31-æ ¸å¿ƒæ¦‚å¿µ)
  - [3.2. åç¨‹å…³é”®å­—](#32-åç¨‹å…³é”®å­—)
  - [3.3. ç”Ÿæˆå™¨ç¤ºä¾‹](#33-ç”Ÿæˆå™¨ç¤ºä¾‹)
  - [3.4. å¼‚æ­¥ä»»åŠ¡ç¤ºä¾‹](#34-å¼‚æ­¥ä»»åŠ¡ç¤ºä¾‹)
- [4. æ¦‚å¿µï¼ˆConceptsï¼‰](#4-æ¦‚å¿µconcepts)
  - [4.1. ä»€ä¹ˆæ˜¯æ¦‚å¿µï¼Ÿ](#41-ä»€ä¹ˆæ˜¯æ¦‚å¿µ)
  - [4.2. åŸºæœ¬è¯­æ³•](#42-åŸºæœ¬è¯­æ³•)
  - [4.3. å¤æ‚æ¦‚å¿µç¤ºä¾‹](#43-å¤æ‚æ¦‚å¿µç¤ºä¾‹)
  - [4.4. æ¦‚å¿µä¸auto](#44-æ¦‚å¿µä¸auto)
- [5. èŒƒå›´ï¼ˆRangesï¼‰](#5-èŒƒå›´ranges)
  - [5.1. è§†å›¾ï¼ˆViewsï¼‰](#51-è§†å›¾views)
  - [5.2. èŒƒå›´ç®—æ³•](#52-èŒƒå›´ç®—æ³•)
  - [5.3. è‡ªå®šä¹‰èŒƒå›´è§†å›¾](#53-è‡ªå®šä¹‰èŒƒå›´è§†å›¾)
- [6. ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦](#6-ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦)
  - [6.1. åŸºæœ¬ç”¨æ³•](#61-åŸºæœ¬ç”¨æ³•)
  - [6.2. æ¯”è¾ƒç±»åˆ«](#62-æ¯”è¾ƒç±»åˆ«)
- [7. constexpr å¢å¼º](#7-constexpr-å¢å¼º)
  - [7.1. constexpr å®¹å™¨å’Œç®—æ³•](#71-constexpr-å®¹å™¨å’Œç®—æ³•)
  - [7.2. constexpr è™šå‡½æ•°](#72-constexpr-è™šå‡½æ•°)
- [8. åˆå§‹åŒ–è¯­å¥å¢å¼º](#8-åˆå§‹åŒ–è¯­å¥å¢å¼º)
  - [8.1. èŒƒå›´forå¾ªç¯ä¸­çš„åˆå§‹åŒ–](#81-èŒƒå›´forå¾ªç¯ä¸­çš„åˆå§‹åŒ–)
  - [8.2. if/switchä¸­çš„åˆå§‹åŒ–å¢å¼º](#82-ifswitchä¸­çš„åˆå§‹åŒ–å¢å¼º)
- [9. å…¶ä»–é‡è¦ç‰¹æ€§](#9-å…¶ä»–é‡è¦ç‰¹æ€§)
  - [9.1. std::format - ç°ä»£åŒ–æ ¼å¼åŒ–](#91-stdformat---ç°ä»£åŒ–æ ¼å¼åŒ–)
  - [9.2. std::span - å®‰å…¨çš„è§†å›¾](#92-stdspan---å®‰å…¨çš„è§†å›¾)
  - [9.3. æ—¥å†å’Œæ—¶åŒº](#93-æ—¥å†å’Œæ—¶åŒº)
  - [9.4. æ–°çš„å±æ€§](#94-æ–°çš„å±æ€§)
- [10. æ€»ç»“](#10-æ€»ç»“)


## 1. æ•´ä½“æ¦‚è¿°

C++20 æ˜¯ç»§ C++11 ä¹‹åæœ€é‡è¦çš„æ ‡å‡†æ›´æ–°ï¼Œå¸¦æ¥äº†**é©å‘½æ€§**çš„å˜åŒ–ã€‚æˆ‘ä»¬å¯ä»¥å°†ä¸»è¦ç‰¹æ€§åˆ†ä¸ºå‡ ä¸ªæ ¸å¿ƒé¢†åŸŸï¼š

### 1.1. ğŸ¯ å››å¤§æ”¯æŸ±ç‰¹æ€§
1. **æ¨¡å—ï¼ˆModulesï¼‰** - æ›¿ä»£å¤´æ–‡ä»¶includeçš„ç°ä»£åŒ–æ„å»ºæ–¹å¼
2. **åç¨‹ï¼ˆCoroutinesï¼‰** - å¼‚æ­¥ç¼–ç¨‹çš„é©å‘½æ€§ç‰¹æ€§
3. **æ¦‚å¿µï¼ˆConceptsï¼‰** - æ¨¡æ¿å…ƒç¼–ç¨‹çš„ç±»å‹çº¦æŸç³»ç»Ÿ
4. **èŒƒå›´ï¼ˆRangesï¼‰** - ç°ä»£åŒ–çš„ç®—æ³•å’Œè§†å›¾åº“

### 1.2. ğŸ”§ è¯­è¨€æ ¸å¿ƒæ”¹è¿›
- ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦
- constexpr çš„æå¤§å¢å¼º
- åˆå§‹åŒ–è¯­å¥çš„æ‰©å±•
- æ–°çš„å±æ€§å’Œç‰¹æ€§

### 1.3. ğŸ“š æ ‡å‡†åº“å¢å¼º

- æ ¼å¼åŒ–åº“ï¼ˆstd::formatï¼‰
- æ—¥æœŸæ—¶é—´åº“
- è·¨åº¦ï¼ˆspanï¼‰
- åŒæ­¥åº“å¢å¼º

ç°åœ¨è®©æˆ‘ä»¬é€ä¸ªæ·±å…¥è®²è§£æ¯ä¸ªç‰¹æ€§ã€‚

---

## 2. æ¨¡å—ï¼ˆModulesï¼‰

### 2.1. è§£å†³çš„é—®é¢˜
ä¼ ç»Ÿçš„ `#include` æœºåˆ¶å­˜åœ¨çš„é—®é¢˜ï¼š
- æ–‡æœ¬æ›¿æ¢ï¼Œç¼–è¯‘æ…¢
- å®æ±¡æŸ“
- é¡ºåºä¾èµ–
- å°è£…æ€§å·®

### 2.2. åŸºæœ¬ç”¨æ³•

```cpp
// math.ixx (æ¨¡å—æ¥å£æ–‡ä»¶)
export module math;

export int add(int a, int b) {
    return a + b;
}

export double pi = 3.14159;

// ä¸å¯¼å‡ºï¼Œæ¨¡å—å†…éƒ¨ä½¿ç”¨
int internal_helper() { return 42; }
```

```cpp
// main.cpp
import math;  // å¯¼å…¥æ¨¡å—

int main() {
    int result = add(5, 3);  // ä½¿ç”¨å¯¼å‡ºå‡½æ•°
    double circle_area = pi * 10 * 10;
    return 0;
}
```

### 2.3. æ¨¡å—åˆ†åŒº
```cpp
// math-impl.ixx (æ¨¡å—å®ç°åˆ†åŒº)
export module math:impl;

export int multiply(int a, int b) {
    return a * b;
}
```

```cpp
// math.ixx (ä¸»æ¨¡å—æ¥å£)
export module math;
export import :impl;  // é‡æ–°å¯¼å‡ºåˆ†åŒº

export int add(int a, int b);
```

### 2.4. ä¼˜åŠ¿
- **ç¼–è¯‘é€Ÿåº¦æå‡**ï¼šæ¨¡å—åªç¼–è¯‘ä¸€æ¬¡
- **æ›´å¥½çš„å°è£…**ï¼šåªæœ‰å¯¼å‡ºçš„ç¬¦å·å¯è§
- **æ— å®æ±¡æŸ“**ï¼šæ¨¡å—å†…å®ä¸å½±å“å¯¼å…¥è€…
- **æ¶ˆé™¤é‡å¤**ï¼šä¸åƒå¤´æ–‡ä»¶ä¼šè¢«å¤šæ¬¡åŒ…å«

---

## 3. åç¨‹ï¼ˆCoroutinesï¼‰

### 3.1. æ ¸å¿ƒæ¦‚å¿µ
åç¨‹æ˜¯å¯ä»¥åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æš‚åœå’Œæ¢å¤çš„å‡½æ•°ï¼Œç”¨äºç®€åŒ–å¼‚æ­¥ç¼–ç¨‹ã€‚

### 3.2. åç¨‹å…³é”®å­—
- `co_await` - æš‚åœæ‰§è¡Œç›´åˆ°æ“ä½œå®Œæˆ
- `co_yield` - äº§ç”Ÿå€¼å¹¶æš‚åœ
- `co_return` - å®Œæˆåç¨‹æ‰§è¡Œ

### 3.3. ç”Ÿæˆå™¨ç¤ºä¾‹
```cpp
#include <coroutine>
#include <iostream>
#include <generator>

// C++23 çš„ std::generatorï¼Œå±•ç¤ºåŸç†
template<typename T>
struct Generator {
    struct promise_type {
        T value_;
        
        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { std::terminate(); }
        
        std::suspend_always yield_value(T value) {
            value_ = value;
            return {};
        }
        void return_void() {}
    };

    std::coroutine_handle<promise_type> coro_;
    
    explicit Generator(std::coroutine_handle<promise_type> h) : coro_(h) {}
    ~Generator() { if (coro_) coro_.destroy(); }
    
    T operator()() {
        coro_.resume();
        return coro_.promise().value_;
    }
};

Generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        auto next = a + b;
        a = b;
        b = next;
    }
}

int main() {
    auto fib = fibonacci();
    for (int i = 0; i < 10; ++i) {
        std::cout << fib() << " ";
    }
    // è¾“å‡º: 0 1 1 2 3 5 8 13 21 34
}
```

### 3.4. å¼‚æ­¥ä»»åŠ¡ç¤ºä¾‹
```cpp
#include <coroutine>
#include <iostream>
#include <thread>
#include <chrono>

struct AsyncTask {
    struct promise_type {
        AsyncTask get_return_object() {
            return AsyncTask{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { std::terminate(); }
        void return_void() {}
    };

    std::coroutine_handle<promise_type> coro_;
    
    AsyncTask(std::coroutine_handle<promise_type> h) : coro_(h) {}
    ~AsyncTask() { if (coro_) coro_.destroy(); }
    
    void await_resume() {}
    bool await_ready() { return false; }
    void await_suspend(std::coroutine_handle<>) {
        std::thread([this] {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            coro_.resume();
        }).detach();
    }
};

AsyncTask async_operation() {
    std::cout << "å¼€å§‹å¼‚æ­¥æ“ä½œ..." << std::endl;
    co_await AsyncTask{};
    std::cout << "å¼‚æ­¥æ“ä½œå®Œæˆ!" << std::endl;
}
```

---

## 4. æ¦‚å¿µï¼ˆConceptsï¼‰

### 4.1. ä»€ä¹ˆæ˜¯æ¦‚å¿µï¼Ÿ
æ¦‚å¿µæ˜¯å¯¹æ¨¡æ¿å‚æ•°çš„çº¦æŸï¼Œè®©æ¨¡æ¿ç¼–ç¨‹æ›´å®‰å…¨ã€é”™è¯¯ä¿¡æ¯æ›´å‹å¥½ã€‚

### 4.2. åŸºæœ¬è¯­æ³•
```cpp
#include <concepts>
#include <type_traits>

// å®šä¹‰æ¦‚å¿µ
template<typename T>
concept Arithmetic = std::is_arithmetic_v<T>;

template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

// ä½¿ç”¨æ¦‚å¿µ
template<Arithmetic T>
T square(T x) {
    return x * x;
}

template<Addable T>
T add_twice(T a, T b) {
    return a + b + b;
}
```

### 4.3. å¤æ‚æ¦‚å¿µç¤ºä¾‹
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <iterator>

// å®šä¹‰å®¹å™¨æ¦‚å¿µ
template<typename C>
concept Container = requires(C c) {
    typename C::value_type;
    typename C::size_type;
    typename C::iterator;
    typename C::const_iterator;
    { c.begin() } -> std::same_as<typename C::iterator>;
    { c.end() } -> std::same_as<typename C::iterator>;
    { c.size() } -> std::same_as<typename C::size_type>;
};

// å¯æ’åºæ¦‚å¿µ
template<typename C>
concept Sortable = Container<C> && 
    requires(typename C::value_type a, typename C::value_type b) {
        { a < b } -> std::convertible_to<bool>;
    };

// ä½¿ç”¨æ¦‚å¿µçº¦æŸ
template<Sortable Container>
void sort_and_print(Container& c) {
    std::sort(c.begin(), c.end());
    for (const auto& item : c) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
}

// ç®€å†™è¯­æ³•
void print_container(const Container auto& c) {
    for (const auto& item : c) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
}
```

### 4.4. æ¦‚å¿µä¸auto
```cpp
// æ¦‚å¿µå¯ä»¥ç”¨äºçº¦æŸauto
Arithmetic auto multiply(Arithmetic auto a, Arithmetic auto b) {
    return a * b;
}

// ç­‰ä»·äº
template<Arithmetic T, Arithmetic U>
auto multiply(T a, U b) {
    return a * b;
}
```

---

## 5. èŒƒå›´ï¼ˆRangesï¼‰

### 5.1. è§†å›¾ï¼ˆViewsï¼‰
è§†å›¾æ˜¯æƒ°æ€§æ±‚å€¼çš„èŒƒå›´ï¼Œä¸æ‹¥æœ‰æ•°æ®ã€‚

```cpp
#include <ranges>
#include <vector>
#include <iostream>
#include <algorithm>

namespace rv = std::views;

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // ç®¡é“æ“ä½œç¬¦ | 
    auto result = numbers 
        | rv::filter([](int n) { return n % 2 == 0; })     // è¿‡æ»¤å¶æ•°
        | rv::transform([](int n) { return n * n; })       // å¹³æ–¹
        | rv::take(3);                                     // å–å‰3ä¸ª
    
    for (int n : result) {
        std::cout << n << " ";  // è¾“å‡º: 4 16 36
    }
}
```

### 5.2. èŒƒå›´ç®—æ³•
```cpp
#include <algorithm>
#include <ranges>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {5, 3, 8, 1, 9, 2};
    
    // ä¼ ç»Ÿç®—æ³•
    std::sort(vec.begin(), vec.end());
    
    // èŒƒå›´ç®—æ³•
    std::ranges::sort(vec);
    
    // å¸¦æŠ•å½±çš„ç®—æ³•
    struct Person {
        std::string name;
        int age;
    };
    
    std::vector<Person> people = {
        {"Alice", 30}, {"Bob", 25}, {"Charlie", 35}
    };
    
    // æŒ‰å¹´é¾„æ’åºï¼Œä½¿ç”¨æŠ•å½±
    std::ranges::sort(people, std::ranges::less{}, &Person::age);
    
    for (const auto& person : people) {
        std::cout << person.name << ": " << person.age << std::endl;
    }
}
```

### 5.3. è‡ªå®šä¹‰èŒƒå›´è§†å›¾
```cpp
#include <ranges>
#include <iostream>

// åˆ›å»ºè‡ªå®šä¹‰è§†å›¾ï¼šç›¸é‚»å·®å€¼è§†å›¾
class adjacent_diff_view : public std::ranges::view_interface<adjacent_diff_view> {
private:
    std::ranges::viewable_range auto range_;
    
public:
    adjacent_diff_view(std::ranges::viewable_range auto r) : range_(std::move(r)) {}
    
    auto begin() {
        return std::ranges::begin(range_);
    }
    
    auto end() {
        return std::ranges::end(range_);
    }
};

// è§†å›¾é€‚é…å™¨
inline constexpr auto adjacent_diff = []<std::ranges::viewable_range R>(R&& r) {
    return adjacent_diff_view{std::forward<R>(r)};
};
```

---

## 6. ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦

### 6.1. åŸºæœ¬ç”¨æ³•
```cpp
#include <compare>
#include <iostream>

class Point {
public:
    int x, y;
    
    // è‡ªåŠ¨ç”Ÿæˆæ‰€æœ‰æ¯”è¾ƒè¿ç®—ç¬¦
    auto operator<=>(const Point&) const = default;
};

class CaseInsensitiveString {
public:
    std::string value;
    
    // è‡ªå®šä¹‰ä¸‰è·¯æ¯”è¾ƒ
    std::strong_ordering operator<=>(const CaseInsensitiveString& other) const {
        return compare_insensitive(value, other.value);
    }
    
    bool operator==(const CaseInsensitiveString& other) const {
        return std::is_eq(*this <=> other);
    }
    
private:
    static std::strong_ordering compare_insensitive(const std::string& a, const std::string& b) {
        // å®ç°å¤§å°å†™ä¸æ•æ„Ÿæ¯”è¾ƒ
        auto it1 = a.begin(), it2 = b.begin();
        while (it1 != a.end() && it2 != b.end()) {
            char c1 = std::tolower(*it1);
            char c2 = std::tolower(*it2);
            if (c1 != c2) return c1 <=> c2;
            ++it1; ++it2;
        }
        return a.length() <=> b.length();
    }
};
```

### 6.2. æ¯”è¾ƒç±»åˆ«
- `std::strong_ordering` - å®Œå…¨å¯æ›¿æ¢ï¼ˆå¦‚æ•´æ•°ï¼‰
- `std::weak_ordering` - å¯æ¯”è¾ƒä½†ä¸å¯æ›¿æ¢ï¼ˆå¦‚ä¸åŒºåˆ†å¤§å°å†™çš„å­—ç¬¦ä¸²ï¼‰
- `std::partial_ordering` - éƒ¨åˆ†æœ‰åºï¼ˆå¦‚æµ®ç‚¹æ•°ï¼Œæœ‰NaNï¼‰

```cpp
class Rational {
public:
    int numerator, denominator;
    
    std::strong_ordering operator<=>(const Rational& other) const {
        return numerator * other.denominator <=> other.numerator * denominator;
    }
    
    bool operator==(const Rational& other) const = default;
};
```

---

## 7. constexpr å¢å¼º

### 7.1. constexpr å®¹å™¨å’Œç®—æ³•
```cpp
#include <array>
#include <algorithm>
#include <vector>

consteval int compile_time_computation() {
    // C++20 å…è®¸åœ¨ constexpr ä¸­ä½¿ç”¨åŠ¨æ€å†…å­˜åˆ†é…ï¼ˆç¼–è¯‘æ—¶ï¼‰
    std::vector<int> vec = {1, 5, 3, 2, 4};
    std::sort(vec.begin(), vec.end());
    
    // constexpr ç®—æ³•
    std::array<int, 5> arr = {1, 5, 3, 2, 4};
    std::sort(arr.begin(), arr.end());
    
    return vec[0] + arr[0];  // è¿”å› 2
}

constexpr auto result = compile_time_computation();  // ç¼–è¯‘æ—¶è®¡ç®—
```

### 7.2. constexpr è™šå‡½æ•°
```cpp
struct Shape {
    constexpr virtual double area() const = 0;
    constexpr virtual ~Shape() = default;
};

struct Circle : Shape {
    double radius;
    
    constexpr Circle(double r) : radius(r) {}
    
    constexpr double area() const override {
        return 3.14159 * radius * radius;
    }
};

constexpr double compute_total_area() {
    Circle c{2.0};
    Shape& s = c;
    return s.area();  // ç¼–è¯‘æ—¶å¤šæ€è°ƒç”¨
}
```

---

## 8. åˆå§‹åŒ–è¯­å¥å¢å¼º

### 8.1. èŒƒå›´forå¾ªç¯ä¸­çš„åˆå§‹åŒ–
```cpp
#include <vector>
#include <map>
#include <string>

int main() {
    std::map<int, std::string> data = {{1, "one"}, {2, "two"}};
    
    // åœ¨èŒƒå›´forå¾ªç¯ä¸­åˆå§‹åŒ–
    for (auto [key, value] = *data.begin(); key <= 2; ++key) {
        std::cout << key << ": " << value << std::endl;
    }
    
    // å¸¦åˆå§‹åŒ–çš„èŒƒå›´for
    for (std::vector<int> temp = {1, 2, 3}; auto& item : temp) {
        std::cout << item << " ";
    }
}
```

### 8.2. if/switchä¸­çš„åˆå§‹åŒ–å¢å¼º
```cpp
#include <iostream>
#include <optional>
#include <memory>

std::optional<int> get_data() { return 42; }

int main() {
    // if å¸¦åˆå§‹åŒ– + æ¡ä»¶
    if (auto data = get_data(); data.has_value() && data.value() > 0) {
        std::cout << "Positive data: " << data.value() << std::endl;
    }
    
    // switch å¸¦åˆå§‹åŒ–
    switch (auto x = get_data(); x.value_or(0)) {
        case 42:
            std::cout << "The answer!" << std::endl;
            break;
        default:
            std::cout << "Something else" << std::endl;
    }
}
```

---

## 9. å…¶ä»–é‡è¦ç‰¹æ€§

### 9.1. std::format - ç°ä»£åŒ–æ ¼å¼åŒ–
```cpp
#include <format>
#include <iostream>
#include <numbers>

int main() {
    std::string name = "World";
    int value = 42;
    double pi = std::numbers::pi;
    
    // ç±»å‹å®‰å…¨çš„æ ¼å¼åŒ–
    auto message = std::format("Hello, {}! The answer is {}. Ï€ = {:.2f}", 
                              name, value, pi);
    std::cout << message << std::endl;
    
    // ä½ç½®å‚æ•°
    auto positioned = std::format("{1} comes before {0}", "second", "first");
    std::cout << positioned << std::endl;
    
    //  chrono æ”¯æŒ
    auto time_msg = std::format("Current time: {:%H:%M}", 
                               std::chrono::system_clock::now());
    std::cout << time_msg << std::endl;
}
```

### 9.2. std::span - å®‰å…¨çš„è§†å›¾
```cpp
#include <span>
#include <iostream>
#include <vector>

void process_data(std::span<const int> data) {
    // span æä¾›å¯¹è¿ç»­æ•°æ®çš„å®‰å…¨è§†å›¾
    for (auto item : data) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
    
    // å­è§†å›¾
    auto subview = data.subspan(1, 3);
    for (auto item : subview) {
        std::cout << item << " ";
    }
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    int arr[] = {6, 7, 8, 9, 10};
    
    process_data(vec);  // ä»vectoråˆ›å»ºspan
    process_data(arr);  // ä»æ•°ç»„åˆ›å»ºspan
}
```

### 9.3. æ—¥å†å’Œæ—¶åŒº
```cpp
#include <chrono>
#include <iostream>

int main() {
    using namespace std::chrono;
    
    // æ—¥å†æ“ä½œ
    auto today = floor<days>(system_clock::now());
    year_month_day ymd{today};
    
    std::cout << "Today: " << ymd << std::endl;
    
    // æ—¶åŒºæ”¯æŒ
    auto zoned_time = zoned_time{current_zone(), system_clock::now()};
    std::cout << "Local time: " << zoned_time << std::endl;
    
    // æ—¥æœŸè¿ç®—
    auto tomorrow = ymd + days{1};
    std::cout << "Tomorrow: " << tomorrow << std::endl;
}
```

### 9.4. æ–°çš„å±æ€§
```cpp
#include <iostream>

[[nodiscard("ä¸è¦å¿½ç•¥è¿”å›å€¼ï¼")]] int important_function() {
    return 42;
}

void example() {
    important_function();  // ç¼–è¯‘å™¨è­¦å‘Šï¼šå¿½ç•¥è¿”å›å€¼
}

class [[nodiscard]] CriticalResource {
public:
    CriticalResource() { std::cout << "èµ„æºè·å–" << std::endl; }
    ~CriticalResource() { std::cout << "èµ„æºé‡Šæ”¾" << std::endl; }
};

CriticalResource get_resource() {
    return CriticalResource{};
}

void test() {
    get_resource();  // è­¦å‘Šï¼šä¸´æ—¶èµ„æºç«‹å³é”€æ¯
}
```

---

## 10. æ€»ç»“

C++20 æ˜¯ä¸€ä¸ª**å˜é©æ€§**çš„ç‰ˆæœ¬ï¼Œå®ƒï¼š

1. **ç°ä»£åŒ–æ„å»ºç³»ç»Ÿ** - æ¨¡å—æ›¿ä»£äº†ä¼ ç»Ÿçš„å¤´æ–‡ä»¶
2. **é©å‘½æ€§å¼‚æ­¥ç¼–ç¨‹** - åç¨‹ç®€åŒ–äº†å¤æ‚å¼‚æ­¥é€»è¾‘
3. **å®‰å…¨çš„æ³›å‹ç¼–ç¨‹** - æ¦‚å¿µæä¾›äº†ç¼–è¯‘æœŸç±»å‹çº¦æŸ
4. **å£°æ˜å¼ç®—æ³•** - èŒƒå›´åº“è®©ä»£ç æ›´ç®€æ´è¡¨è¾¾æ„å›¾
5. **ç®€åŒ–å¸¸ç”¨æ“ä½œ** - ä¸‰è·¯æ¯”è¾ƒã€æ ¼å¼åŒ–ç­‰å‡å°‘æ ·æ¿ä»£ç 

è¿™äº›ç‰¹æ€§è®©C++åœ¨ç°ä»£ç³»ç»Ÿç¼–ç¨‹ã€é«˜æ€§èƒ½è®¡ç®—å’ŒåŸºç¡€åº“å¼€å‘ä¸­ä¿æŒäº†å¼ºå¤§çš„ç«äº‰åŠ›ï¼ŒåŒæ—¶æ˜¾è‘—æé«˜äº†å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ã€‚

å»ºè®®åœ¨å®é™…é¡¹ç›®ä¸­é€æ­¥é‡‡ç”¨è¿™äº›ç‰¹æ€§ï¼Œç‰¹åˆ«æ˜¯æ¨¡å—ã€æ¦‚å¿µå’ŒèŒƒå›´åº“ï¼Œå®ƒä»¬èƒ½æ˜¾è‘—æ”¹å–„ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ã€‚