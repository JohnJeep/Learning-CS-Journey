# 1. Move Semantics(移动语义)

**移动语义** 是 C++11 引入的一种革命性特性，允许将一个对象的资源（如动态内存、文件句柄等）从一个对象转移到另一个对象，而不是进行深拷贝。这通常比拷贝更高效，因为它避免了复制大量数据和分配新内存的开销。

### 1.0.1. 拷贝语义

在移动语义出现之前，所有对象的传递都是拷贝。

- **行为**：创建一个资源的完整、独立的副本。
- **代价**：高昂。如果对象管理着大量数据（例如 `std::vector` 或 `std::string`），深拷贝需要分配新内存并将所有数据逐个复制过去，时间复杂度为 O(n)。

```cpp
std::vector<int> source = {1, 2, 3, 4, 5};
std::vector<int> destination = source; // 拷贝构造发生！
```

### 1.0.2. 移动语义

移动语义解决了不必要的拷贝问题，特别是在处理临时对象时。

- **行为**：转移资源的所有权。源对象放弃其资源，“交给”目标对象。之后，源对象处于一个**有效但通常为空的状态**（例如，其内部指针为 `nullptr`）。
- **代价**：低廉。通常只涉及复制几个指针或句柄，然后将源对象的指针置空。时间复杂度为 O(1)。

### 1.0.3. 技术实现机制

移动语义在语言层面通过两个新特性实现：

1. **右值引用**：
   - 语法：`T&&`
   - 它主要绑定到**临时对象（右值）**，例如函数返回值、字面量、或者通过 `std::move` 强制转换的对象。
   - 它是实现移动语义的“许可证”，告诉编译器：“这个对象是临时的，我可以拿走它的资源”。
2. **移动构造函数和移动赋值运算符**：
   - 它们是特殊的成员函数，接受右值引用作为参数。
   - 它们的实现通常是“偷”走源对象的资源，然后把源对象置空。

**移动语义的核心价值在于性能优化。** 它使得以值传递和返回大型对象变得高效，从而鼓励更清晰、更安全的代码风格，而无需像以前那样过度依赖指针和引用来避免拷贝。

## 1.1. 何为左值(lvalue reference)

在C++中，左值是指有名字的、可以取地址的表达式。比如变量、函数返回的左值引用等。

- 左值为引用时，返回的是变量的本身。
- 左值：有持久状态的对象，可以取地址

```cpp
int a = 10;        // a 是左值
int& ref = a;      // 左值引用，ref=10

int&& rref = 20;   // 20 是右值，rref 是右值引用
```

## 1.2. 何为右值引用(rvalue reference)

右值引用是C++11中引入的一种新的引用类型，它用于绑定到临时对象（右值）。

右值引用的语法是使用两个`&`符号，例如`T&&`。

```cpp
int&& rref = 42;           // 右值引用绑定到字面量
std::string&& sref = std::string("hello"); // 右值引用绑定到临时对象
```

右值通常是**临时对象**。比如字面量、表达式计算结果、函数返回的非引用类型等。右值引用的主要目的是转移临时对象中的资源，而不是进行深拷贝。

注意点：

1. 右值引用可以绑定到右值（如临时对象、字面量等），但不能绑定到左值（具有持久状态的变量）。
2. 可以使用`std::move`函数将一个左值转换为右值引用，从而允许我们使用移动语义（move semantics）。

## 1.3. Move constructor(移动构造)

Move constructor 是 C++11 引入的重要特性，它是一种特殊的构造函数。它接受一个同类型的右值引用作为参数，并从该右值引用中转移资源，而不是复制资源。移动构造函数通常不会抛出异常，因此通常被标记为`noexcept`，并在移动后置空源对象（比如：指针设为 nullptr，int 值设为0）。

```cpp
class MyString {
private:
    char* data;
    size_t size;
    
public:
    // 移动构造函数
    MyString(MyString&& other) noexcept 
        : data(other.data), size(other.size) {
        // 将原对象置于可析构状态
        other.data = nullptr;
        other.size = 0;
    }
    
    // 拷贝构造函数（作为对比）
    MyString(const MyString& other) 
        : size(other.size) {
        data = new char[size];
        std::copy(other.data, other.data + size, data);
    }
    
    ~MyString() {
        delete[] data;
    }
};
```

关键点理解

1. move constructor 是对资源所有权的转移，并不对数据本身进行拷贝。堆上的数据**原地不动**，只是改变哪个对象拥有它。
2. 使用移动构造后，源对象被置于"空状态"（空壳），但仍然是有效的对象，需要重新赋值或析构后，才能重新使用。

### 1.3.1. 移动构造和右值引用的关系

移动构造函数依赖于右值引用来实现。通过右值引用，移动构造函数能够识别出传入的对象是一个临时对象（或显式转换为右值的对象），从而安全地转移其资源。

当我们使用一个临时对象来初始化同一个类的新对象时，编译器会自动选择移动构造函数（如果存在）而不是拷贝构造函数，因为临时对象是右值，可以绑定到右值引用。

```cpp
MyClass createObject() {
    return MyClass(); // 返回一个临时对象
}

MyClass obj = createObject(); // 这里会调用移动构造函数（如果存在）
```

如果没有移动构造函数，那么就会调用拷贝构造函数。但是，如果类中包含了动态分配的内存或其他资源，移动构造函数可以通过直接转移指针的所有权来避免深拷贝，从而提高性能。

### 1.3.2. 移动 vs. 拷贝

| 特性           | 拷贝构造函数               | 移动构造函数                   |
| :------------- | :------------------------- | :----------------------------- |
| **参数**       | `const T&` (常量左值引用)  | `T&&` (非常量右值引用)         |
| **资源操作**   | 深拷贝，创建资源的完整副本 | 浅拷贝，接管源对象的资源       |
| **性能**       | 昂贵，`O(n)` 或更高        | 廉价，通常是 `O(1)`            |
| **源对象状态** | 保持不变                   | 被“掏空”，处于有效但未指定状态 |
| **使用场景**   | 需要独立副本时             | 源对象是临时对象或不再需要时   |

**总结：使用移动构造的目的，高效转移资源，避免不要的深拷贝。**



## 1.4. Move Assignment Operator(移动赋值)

移动赋值操作符是C++11引入的一个重要特性，用于在对象之间转移资源所有权，不是复制资源，避免不必要的深度拷贝。

###  1.4.1. 基本概念

- 移动赋值操作符（Move Assignment Operator）是一个特殊的成员函数，用于将另一个对象的资源“移动”到当前对象，同时使源对象处于有效但未定义的状态。
- 它通常接受一个同类型的右值引用参数（T&&），并返回当前对象的左值引用（T&）。

### 1.4.2. 语法

```cpp
class_name& operator=(class_name&& other) noexcept; // 典型声明
```

- `operator=`：函数名。
- `class_name&& other`：参数是一个指向同类型的**右值引用**（`&&`）。这是识别移动操作的关键。
- 返回类型为 `class_name&`：通常返回 `*this`，以支持链式赋值（如 `a = b = c`）。
- `noexcept`：**强烈建议**标记为 `noexcept`。这是因为许多标准库操作（如 `std::vector::reallocate`）在知道移动操作不会抛出异常时，会优先使用移动而非拷贝，以获得更好的性能和安全保障。

### 1.4.3. 实现原理

1. **释放当前对象的资源**：在窃取新资源之前，必须妥善释放当前对象已持有的资源，防止内存泄漏。
2. **窃取源对象的资源**：将源对象（`other`）的资源（如指针、文件句柄等）直接“移动”到当前对象。
3. **将源对象置于有效但可析构的状态**：这是移动语义的**关键契约**。被移动后的源对象（`other`）必须仍然处于一个可以被安全析构的状态。通常这意味着将其成员变量设置为“空”状态（例如，将指针设为 `nullptr`，将整数设为 `0`）。
4. **处理自赋值**：虽然“移动一个右值给自己” (`x = std::move(x)`) 听起来很荒谬，但理论上可能发生。一个健壮的实现应该处理这种情况。

示例

```cpp
class MyVector {
private:
    int* m_data;
    size_t m_size;

public:
    // ... 构造函数，析构函数，拷贝操作等 ...

    // 移动赋值操作符
    MyVector& operator=(MyVector&& other) noexcept {
        // 1. 检查自赋值
        if (this != &other) {
            // 2. 释放当前对象的资源
            delete[] m_data;

            // 3. 窃取源对象的资源
            m_data = other.m_data;
            m_size = other.m_size;

            // 4. 将源对象置于可析构状态
            other.m_data = nullptr;
            other.m_size = 0;
        }
        return *this;
    }
};
```



### 1.4.4. 与拷贝赋值操作符的区别

| 特性           | copy assignment operator             | move assignment operator                 |
| :------------- | :----------------------------------- | :--------------------------------------- |
| **参数**       | `const class_name&` (常左值引用)     | `class_name&&` (右值引用)                |
| **语义**       | **深拷贝**：创建资源的一个独立副本。 | **资源转移**：转移源对象的资源。         |
| **源对象状态** | 源对象保持不变，完全独立。           | 源对象被“掏空”，处于有效但未指定的状态。 |
| **性能**       | 通常昂贵（O(n)）。                   | 通常廉价（O(1)）。                       |
| **`noexcept`** | 通常不保证（因为分配可能失败）。     | **通常应该**是 `noexcept`。              |

### 1.4.5. 编译器自动生成的条件

如果你没有声明**拷贝构造函数**、**拷贝赋值操作符**、**移动构造函数**和**析构函数**中的任何一个，编译器会为你自动生成一个移动赋值操作符（称为 **Rule of Zero/Five**）。

这个自动生成的移动赋值操作符会：

- 对内置类型（如指针、`int`）进行**逐成员拷贝**（这很危险，因为它会导致两个对象指向同一块内存）。
- 对类类型的成员，调用其自身的**移动赋值操作符**。

一旦你显式声明了上述任何函数，编译器将**不会**再自动生成移动赋值操作符。这是为了兼容老代码，避免 silent breaking change。这时，你需要根据 **Rule of Five** 来决定是否手动实现它们。

### 1.4.6. 注意事项

1. **被移动后的对象不应再使用**：除了赋值给它一个新值或安全地析构它之外，你不应该对被移动后的对象的状态做任何假设。使用它是未定义行为的常见来源。
2. **强烈标记为 `noexcept`**：如前所述，这能最大化移动语义带来的性能优势。
3. **遵循 Rule of Five/Zero**：
   - **Rule of Five**：如果一个类需要自定义析构函数、拷贝构造函数、拷贝赋值操作符、移动构造函数或移动赋值操作符中的任何一个，那么它很可能需要全部五个。
   - **Rule of Zero**：理想情况下，让你的类不直接管理资源，而是使用 `std::vector`, `std::string`, `std::unique_ptr` 等智能对象作为成员。这样，编译器自动生成的特殊成员函数就是正确且高效的，你无需手动定义任何一个。



### 1.4.7. Move Constructor 和 Move Assignment Operator 区别

1. Move Constructor 是在 构造新对象时被调用，而 Move Assignment Operator 是对已经存在的对象赋值时被调用。
2. 使用 Move Assignment Operator 之前，须先释放自己的资源，然后从源对象转移资源，并将源对象置于可析构状态。使用 Move Constructor时：因为对象是新建的，所以通常不需要释放已有资源（因为新建对象通常没有资源），但是必须确保将源对象置于可析构状态。

```cpp
MyVector a;
MyVector b = std::move(a); // 移动构造函数：用a初始化b，a被移动后处于有效但未指定状态
MyVector c;
c = std::move(b); // 移动赋值运算符：将b的值移动给c，b被移动后处于有效但未指定状态
```



## 1.5. std::move

### 1.5.1. 什么是 std::move

`std::move`是一个函数模板，它将一个左值强制转换为右值引用，从而允许使用移动语义。

注意，`std::move`本身并不移动任何东西，它只是一个类型转换工具，告诉编译器：“这个对象可以被移动，因为我不再需要它了”。

```cpp
template<typename T>
constexpr std::remove_reference_t<T>&& move(T&& arg) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(arg);
}
```

### 1.5.2. 为什么要用 std::move

移动语义通常只适用于右值（临时对象）。如果我们有一个左值，我们想把它当作右值来使用（即我们不再需要这个左值，可以将其资源转移走），那么我们就可以使用 `std::move` 将其转换为右值引用。这样，编译器就会调用接受右值引用的函数（如移动构造函数或移动赋值运算符）。

使用 `std::move` 的主要目的是**将左值转换为右值引用**，从而允许使用移动语义（如移动构造函数[move constructor] 和移动赋值运算符[move assignment operator=]）来转移资源，避免不必要的拷贝，提高程序性能。

**一句话概括：通过资源转移，避免不必要的资源拷贝，提升性能，做性能优化。**

### 1.5.3. 用法

举个例子：

```cpp
// 假设我们有一个String类，它管理一个动态分配的字符数组。

// 没有移动语义时，我们只能进行深拷贝：
String s1("hello");
String s2 = s1; // 调用拷贝构造函数，进行深拷贝

// 有了移动语义后，我们可以定义移动构造函数和移动赋值运算符，从而在适当的时候转移资源：
 String s1("hello");
 String s2 = std::move(s1); // 调用 move constructor，s1 的资源被转移到s2，s1不再拥有原来的资源
```

在这个例子中，我们使用 std::move 将s1转换为右值引用，从而触发了移动构造函数。移动构造函数将s1的资源指针复制到s2，然后将s1的指针设置为nullptr。这样，s1就不再拥有原来的字符串，而s2拥有了原来的字符串。这避免了深拷贝，提高了效率。

### 1.5.4. 注意点

1. 使用 `std::move` 后，原来的左值对象处于一种**有效但未指定的状态**，最好将源对象置于一个**已知的空状态**（如将指针设为 `nullptr`）。
2. 在调用 `std::move` 后，原来的对象不应该再被使用，因为它的资源已经被转移，除非重新给它赋值或析构。在其被重新赋值前，不应该对其做任何的操作。

### 1.5.5. 主要用途

1. **性能优化** - 避免昂贵的拷贝操作
2. **资源转移** - 转移动态内存、文件句柄等资源的所有权
3. **启用移动语义** - 让不支持拷贝的类型（如 unique_ptr）能够转移所有权
4. **与只能移动的类型交互** - 如 std::unique_ptr, std::thread 等

### 1.5.6. 关键点

- `std::move` 只是类型转换，不执行实际移动。移动只是指针交换，而没有内存分配。
- 移动后源对象不应再被使用，除非重新赋值。
- 在适当的地方使用 `std::move` 可以显著提升性能。

