<!--
 * @Author: JohnJeep
 * @Date: 2025-11-25 21:31:19
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-11-25 21:39:50
 * @Description: ABI Usage
 * Copyright (c) 2025 by John Jeep, All Rights Reserved. 
-->

## ABI (Application Binary Interface)

在 Linux 生态系统中，ABI 的稳定性是基石。它确保了即使底层软件（内核、库）不断更新，上层庞大的二进制应用生态系统依然能够平稳运行。**ABI 是二进制程序与操作系统/其他二进制程序之间的约定。**

ABI定义了：

- 函数调用约定
- 异常处理机制
- 虚函数表布局
- 数据类型大小和对齐



**ABI**：**应用程序二进制接口**

- **层次**：**二进制/机器代码级别**。
- **关注点**：函数调用时参数如何传递（放在哪个寄存器或堆栈的什么位置）？系统调用号是多少？数据类型的字节大小和对齐方式是什么？符号名如何修饰（Name Mangling）？
- **作用**：保证编译好的二进制程序能正确**链接**和**运行**。
- **例子**：一个用 GCC 4.8 编译的程序，能否调用一个用 GCC 11 编译的 `libc.so.6` 库？这取决于它们是否遵守相同的 ABI。
- **变更影响**：破坏 ABI 会导致已有的二进制程序崩溃或无法链接。例如，如果一个库的新版本改变了结构体的内存布局，所有依赖旧布局的已编译程序都会出错。



## ABI 构成

在 Linux 下，ABI 是一个综合体，主要由以下几部分构成：

1. **处理器架构的 ABI**
   这定义了特定 CPU 架构（如 x86-64, ARM64）的底层规则。最著名的文档是 **System V ABI**，它规定了在 x86-64 等系统上：
   - **调用约定**：函数调用时，前几个整数参数放在 `rdi`, `rsi`, `rdx, rcx, r8, r9` 寄存器，浮点参数放在 `xmm0-xmm7` 寄存器，多余的参数如何压栈。
   - **数据类型**：`int`、`long`、`double`、结构体等的大小、对齐方式和在内存中的布局。
   - **符号修饰**：C++ 因为函数重载，需要将函数名和参数类型信息编码成一个独特的链接器符号（例如 `_Z3foov`），这个规则就是 ABI 的一部分。
   - **进程初始化和内存布局**：程序启动时堆栈的设置，`.text`, `.data`, `.bss` 段的位置等。
2. **Linux 内核的 ABI**
   这是应用程序与内核通信的接口，主要通过 **系统调用** 进行。
   - **系统调用号**：每个系统调用（如 `read`, `write`, `open`）都有一个唯一的数字编号。在 x86-64 上，`write` 的系统调用号是 1。
   - **系统调用约定**：如何触发一个系统调用（通常使用 `syscall` 指令），系统调用号放在哪个寄存器（`rax`），参数放在哪里（`rdi`, `rsi`, `rdx` 等），返回值放在哪里（`rax`）。
   - **重要提示**：**内核的系统调用 ABI 被认为是极其稳定的**。一旦一个系统调用被加入稳定内核，它就不会被改变或移除，以确保旧的二进制程序永远能在新内核上运行。
3. **库和运行时的 ABI**
   这指的是核心库（尤其是 **GNU C Library, glibc**）提供的二进制接口。
   - 它实现了 C 标准库的函数（如 `printf`, `malloc`），并封装了系统调用。
   - `glibc` 会保证在同一个主版本号内（如 `libc.so.6`）的 ABI 向前兼容。这意味着用 `glibc 2.30` 编译的程序，可以在装有 `glibc 2.35` 的系统上运行，因为 `glibc 2.35` 会兼容 `glibc 2.30` 的 ABI。

## ABI 能做什么

ABI 的核心作用是 **实现二进制兼容性**，这带来了巨大的便利和生态稳定性。

1. **允许二进制程序的分布式发行**
   - 软件开发商（如 Steam, Spotify）可以编译一个二进制包（如 `.deb` 或 `.rpm`），然后分发给所有使用相同架构（如 x86-64）和兼容 ABI 的 Linux 发行版（如 Ubuntu, Fedora, Arch）的用户。用户**无需从源代码重新编译**即可运行该软件。
2. **实现动态链接**
   - 你的程序在运行时可以动态地链接到系统的共享库（如 `libc.so.6`, `libgtk-3.so.0`）。正是因为所有程序和被链接的库都遵守相同的 ABI，这种“即插即用”才成为可能。
3. **保证内核升级的向后兼容性**
   - 你可以将 Linux 内核从 5.10 升级到 6.1，而不用担心你所有的旧软件会立即崩溃。因为内核维护者庄严承诺：**不会破坏系统调用层的 ABI**。
4. **允许混合使用不同编译器/语言编写的代码**
   - 只要它们遵守相同的 ABI，一个用 C 语言编写的程序可以调用一个用 C++ 编译的库，或者用 Rust 编写的库（只要它们使用 `extern "C"` 来遵循 C ABI）。这使得语言间的互操作成为可能。

## ABI 不兼容的例子

**C++ ABI 问题**：这是最常见的问题。GCC 在 5.1 版本中引入了一个新的 `libstdc++` ABI，以修复 `std::string` 和 `std::list` 的实现。这导致：

- 用 GCC 5.1 及以上版本编译的程序，如果链接到新的 `libstdc++.so.6`，**无法**与用 GCC 4.x 编译的、期望旧 ABI 的第三方库一起工作。
- 错误信息可能包含 `undefined symbol: _ZNSt7__cxx1112...`，这明确指向了新的 C++11 ABI（`cxx11`）。
- 解决方案通常是：要么全部用新编译器重新编译所有组件，要么让第三方库提供兼容新旧 ABI 的版本。