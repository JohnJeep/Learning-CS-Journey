<!--

 * @Author: JohnJeep
 * @Date: 2020-08-06 22:20:12
 * @LastEditTime: 2023-06-09 18:54:00
 * @LastEditors: JohnJeep
 * @Description: 设计模式学习
-->

<!-- TOC -->

- [1. 思考](#1-思考)
- [2. 设计模式概括](#2-设计模式概括)
- [3. 设计模式原则](#3-设计模式原则)
- [4. Creational patterns(创建型模式)](#4-creational-patterns创建型模式)
  - [4.1. **Singleton(单例模式)**](#41-singleton单例模式)
    - [4.1.1. 什么是单例模式？](#411-什么是单例模式)
    - [4.1.2. 实现的步骤](#412-实现的步骤)
    - [4.1.3. 单例模式实现](#413-单例模式实现)
      - [4.1.3.1. 饿汉式](#4131-饿汉式)
      - [4.1.3.2. 懒汉式](#4132-懒汉式)
      - [4.1.3.3. C++ 中多线程安全问题？](#4133-c-中多线程安全问题)
    - [4.1.4. 单例模式内存释放](#414-单例模式内存释放)
    - [4.1.5. 单例模式优缺点](#415-单例模式优缺点)
    - [4.1.6. 参考](#416-参考)
  - [4.2. **Factory Method(工厂模式)**](#42-factory-method工厂模式)
    - [4.2.1. 什么是 Factory Method？](#421-什么是-factory-method)
    - [4.2.2. 优点](#422-优点)
    - [4.2.3. 缺点](#423-缺点)
  - [4.3. **Abstract Factory(抽象工厂模式)**](#43-abstract-factory抽象工厂模式)
    - [4.3.1. 什么是抽象工厂模式？](#431-什么是抽象工厂模式)
    - [4.3.2. UML图](#432-uml图)
    - [4.3.3. 优点](#433-优点)
    - [4.3.4. 缺点](#434-缺点)
    - [4.3.5. 工厂模式与抽象工厂模式的区别](#435-工厂模式与抽象工厂模式的区别)
  - [4.4. **Builder(建造者模式)**](#44-builder建造者模式)
    - [4.4.1. 什么是建造者模式?](#441-什么是建造者模式)
    - [4.4.2. 适用性](#442-适用性)
    - [4.4.3. UML图](#443-uml图)
    - [4.4.4. 优点](#444-优点)
    - [4.4.5. 缺点](#445-缺点)
  - [4.5. Prototype(原型模式)](#45-prototype原型模式)
    - [4.5.1. 什么是原型模式？](#451-什么是原型模式)
    - [4.5.2. 优点](#452-优点)
    - [4.5.3. 缺点](#453-缺点)
- [5. Structural patterns(结构型模式)](#5-structural-patterns结构型模式)
  - [5.1. Composite(组合模式)](#51-composite组合模式)
    - [5.1.1. 什么是组合模式？](#511-什么是组合模式)
  - [5.2. **Proxy(代理模式)**](#52-proxy代理模式)
    - [5.2.1. 什么是代理模式？](#521-什么是代理模式)
    - [5.2.2. 优点](#522-优点)
    - [5.2.3. 缺点](#523-缺点)
  - [5.3. **Decorator装饰器模式)**](#53-decorator装饰器模式)
    - [5.3.1. 什么是装饰器模式？](#531-什么是装饰器模式)
  - [5.4. **Adapter(适配器)**](#54-adapter适配器)
    - [5.4.1. 什么是适配器模式？](#541-什么是适配器模式)
    - [5.4.2. 优点](#542-优点)
  - [5.5. **Bridge(桥接模式)**](#55-bridge桥接模式)
    - [5.5.1. 什么是桥接模式？](#551-什么是桥接模式)
  - [5.6. Facade(外观模式)](#56-facade外观模式)
    - [5.6.1. 什么是外观模式？](#561-什么是外观模式)
    - [5.6.2. Facade模式概述](#562-facade模式概述)
    - [5.6.3. 优点](#563-优点)
    - [5.6.4. 缺点](#564-缺点)
  - [5.7. Flyweight(享元模式)](#57-flyweight享元模式)
    - [5.7.1. 什么是享元模式？](#571-什么是享元模式)
    - [5.7.2. 优点](#572-优点)
    - [5.7.3. 缺点](#573-缺点)
- [6. Behavioural patterns(行为型模式)](#6-behavioural-patterns行为型模式)
  - [6.1. **Template Method(模板方法模式)**](#61-template-method模板方法模式)
    - [6.1.1. 模板模式概述](#611-模板模式概述)
    - [6.1.2. 什么是模板方法模式？](#612-什么是模板方法模式)
    - [6.1.3. UML图](#613-uml图)
    - [6.1.4. 优点](#614-优点)
    - [6.1.5. 缺点](#615-缺点)
    - [6.1.6. 应用场景](#616-应用场景)
  - [6.2. **command(命令模式)**](#62-command命令模式)
    - [6.2.1. 命令行模式概述](#621-命令行模式概述)
    - [6.2.2. 什么是命令模式？](#622-什么是命令模式)
    - [6.2.3. UML图](#623-uml图)
    - [6.2.4. 优点](#624-优点)
    - [6.2.5. 缺点](#625-缺点)
    - [6.2.6. 应用场景](#626-应用场景)
  - [6.3. **strategy(策略模式)**](#63-strategy策略模式)
    - [6.3.1. 什么是策略模式？](#631-什么是策略模式)
  - [6.4. **mediator(中介者模式)**](#64-mediator中介者模式)
    - [6.4.1. 什么是中介者模式？](#641-什么是中介者模式)
  - [6.5. **observer(观察者模式)**](#65-observer观察者模式)
    - [6.5.1. 什么是观察者模式？](#651-什么是观察者模式)
    - [6.5.2. 为什么要用observer？](#652-为什么要用observer)
    - [6.5.3. 怎样去使用observer？](#653-怎样去使用observer)
    - [6.5.4. UML图](#654-uml图)
    - [6.5.5. 执行步骤](#655-执行步骤)
    - [6.5.6. 优点](#656-优点)
    - [6.5.7. 缺点](#657-缺点)
    - [6.5.8. 使用时注意事项？](#658-使用时注意事项)
    - [6.5.9. Relations with Other Patterns](#659-relations-with-other-patterns)
  - [6.6. **iterator(迭代器模式)**](#66-iterator迭代器模式)
    - [6.6.1. 什么是迭代器模式？](#661-什么是迭代器模式)
    - [6.6.2. UML图](#662-uml图)
    - [6.6.3. 优点](#663-优点)
    - [6.6.4. 缺点](#664-缺点)
    - [6.6.5. 应用场景](#665-应用场景)
  - [6.7. **visitor(访问者模式)**](#67-visitor访问者模式)
    - [6.7.1. 访问者模式概述](#671-访问者模式概述)
    - [6.7.2. 什么是访问者模式？](#672-什么是访问者模式)
    - [6.7.3. UML图](#673-uml图)
    - [6.7.4. 优点](#674-优点)
    - [6.7.5. 缺点](#675-缺点)
    - [6.7.6. 应用场景](#676-应用场景)
  - [6.8. chain of responsibility(责任链模式)](#68-chain-of-responsibility责任链模式)
    - [6.8.1. 什么是责任链模式？](#681-什么是责任链模式)
  - [6.9. memento(备忘录模式)](#69-memento备忘录模式)
    - [6.9.1. 什么是备忘录模式？](#691-什么是备忘录模式)
  - [6.10. state(状态模式)](#610-state状态模式)
    - [6.10.1. 什么是状态模式？](#6101-什么是状态模式)
  - [6.11. interpreter(解释器模式)](#611-interpreter解释器模式)
    - [6.11.1. 什么是解释器模式？](#6111-什么是解释器模式)
- [7. 参考](#7-参考)

<!-- /TOC -->

# 1. 思考

---------------

* Elements of Reusable Object-Oriented Software(可复用面向对象软件)
* 只有理解了模式，你才能清楚代码中的运行时刻结构。
* 建立一套思维和一套模型
* 设计模式：在变化和稳定中寻找一个平衡点。
* 设计模式之间应该相互配合，共同解决问题。
* 《The Timeless Way of Building》 Christopher Alexander著作
* 层次：分析、设计实现。

---------------

1. 设计模式是做什么的？
2. 它的基本原理和意图是什么？
3. 它解决的是什么样的特定设计问题？
4. 什么时候、什么地方去使用该设计模式？
5. 该设计模式可用来改良哪些不良的设计？
6. 你怎样识别这些情况？
7. 参与者：设计模式中的类或对象以及它们各自的职责？
8. 模式的参与者怎样协作以及实现它们的职责？
9. 模式怎样支持它们的目标？
10. 使用设计模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？
11. 实现设计模式时需要知道的提示、技术要点及应避免的缺陷？以及是否存在某些特定于实现语言的问题。
12. 与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个应与其它的哪些模式一起使用？

# 2. 设计模式概括

三大类型设计模式，共23种。按照目的准则可将设计模式分为下面三大类。

- 创建型模式(Creational patterns)：共5种；
  
  > 提供对象创建机制，以提高灵活性和现有代码的重用性，在系统的某个地方实例化具体的类。通过抽象对象的创建过程，创建型模式提供不同的方式在实例化时建立接口和实现的透明连接。创建型模式确保你的系统是针对接口的方式书写的，而不是针对实现而书写的。
  
  - 工厂方法模式（factory method pattern）
  - 抽象工厂模式（abstract factory pattern）
  - 建造者模式（builder pattern）
  - 单例模式（singleton pattern）
  - 原型模式（prototype pattern） 

- 结构型模式(Structural patterns)：如何将对象和类组装为更大的结构，同时保持结构的灵活性和效率，共7种。
  
  - 代理模式（proxy pattern）  
  - 装饰者模式（decorator pattern）
  - 适配器模式（adapter pattern）
  - 桥接模式（bridge pattern）
  - 组合模式（composite pattern）
  - 外观模式（facade pattern）
  - 享元模式（flyweight pattern）

- 行为型模式(Behavioural patterns)：对类或对象怎样交互和怎样分配职责，共11种。
  
  - 模板方法模式（template method pattern） 
  - 命令模式（command pattern）
  - 责任链模式（chain of responsibility pattern）
  - 策略模式（strategy pattern）
  - 中介者模式（mediator pattern）
  - 观察者模式（observer pattern）
  - 备忘录模式（memento pattern）
  - 访问者模式（visitor pattern）
  - 状态模式（state pattern）
  - 解释模式（interpreter pattern）
  - 迭代模式（iterator pattern）

# 3. 设计模式原则

使用设计模式的最终目的：高内聚，低耦合。

8种基本原则

- 依赖倒置原则（DIP: dependence inversion principle）：依赖于抽象接口，不要依赖于具体的类，即针对接口编程。

- 开放封闭原则（OCP）：类的改动是通过增加代码来进行的，而不是修改源代码。

- 迪米特原则（LOD：low of demeter）：一个对象应该对其它的对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。
  
  > 例如：在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现，使其它的模块不需要了解另一个模块的内部实现，这样当一个模块发生改变时，其它的模块不会受到影响。

- 单一责任原则（SRP）：一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任。

- 替换原则（LSP）：子类必须能够替换它们的基类。

- 接口隔离原则（ISP）：不应该强迫客户程序依赖它们不用的方法。

- 优先使用对象组合而不是类继承：继承在某种程度上破坏了封装性，子类父类耦合度高；对象组合则只要求被组合的对象具有良好定义的接口，耦合度较低。

- 封装变化点：使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

- 针对接口编程，而不是针对实现编程。
  
  * 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
  * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
  * 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

# 4. Creational patterns(创建型模式)

## 4.1. **Singleton(单例模式)**

### 4.1.1. 什么是单例模式？

<font color=red>
保证一个类只能生成一个唯一的实例对象，同时提供该实例访问的全局方法。
</font>

### 4.1.2. 实现的步骤

- 构造函数可见性设置为 `private`，禁止类创建额外的实例，只能创建一个实例。
- 提供一个全局的静态（static）方法，作为外部类共享的唯一实例。
- 在类中定义一个静态（static）指针，指向该类变量的静态变量指针。

代码示例

```cpp
class Singleton
{
public:
    static Singleton* getInstance();                 // 提供一个全局的静态方法

private:
    static Singleton* m_Instance;                    // 静态指针 
    Singleton();                                     // 构造函数私有化，禁止他人创建
    ~Singleton();
};

// 类外部初始化静态变量
Singleton* Singleton::m_Instance = nullptr   
```

注意代码中 `getInstance()` 方法的修饰符：`public` 和 `static`。`public` 修饰表示它是一个公共的方法，以便供外界其他对象使用；`static` 关键字表示它是一个静态方法，在类的外部可以直接通过类名（`Singleton::getInstance()`）来访问，而无须创建 `Singleton` 对象，事实上在类的外部也无法创建类的对象，因为构造函数是私有的。

在类的外部我们无法直接创建新的 Singleton 对象，但可以通过类的成员方法 `Singleton::getInstance()` 来访问实例对象，第一次调用 `getInstance()` 方法时将创建唯一实例，再次调用时将返回第一次创建的实例，从而确保实例对象的唯一性。

### 4.1.3. 单例模式实现

#### 4.1.3.1. 饿汉式

饿汉式就是在类刚加载的时候就创建了类的实例，是一个全局对象，生命周期一直到程序退出，其申请的内存空间才被释放。若对象创建的实例一直没有被使用，即程序中没有地方去调用，则存在申请的内存空间浪费的情况。这种以空间换时间的方式，虽然浪费了一些内存空间，但在多线程中保证了线程访问的安全，不会造成多线程之间资源竞争的问题。

代码实现

```cpp
#include <iostream>
#include <stdlib.h>

using namespace std;

class Singleton
{
public:
    static Singleton* getInstance();                 // 提供一个全局的静态方法
    static Singleton* freeInstance();                // 释放内存

private:
    static Singleton* m_Instance;                    // 静态指针 
    Singleton();                                     // 构造函数私有化，禁止他人创建
    ~Singleton();
};

Singleton* Singleton::m_Instance = new Singleton;    // 静态全局变量创建对象

Singleton::Singleton()
{
    cout << "执行构造函数" << endl;
}

Singleton::~Singleton()
{
    cout << "执行析构函数" << endl;
}

Singleton* Singleton::getInstance()
{
    return m_Instance;
}

Singleton* Singleton::freeInstance()
{
    if (m_Instance != nullptr) {
        delete m_Instance;
        m_Instance = nullptr;
        cout << "释放对象内存" << endl;
    }
    return m_Instance;
}

int main(int argc, char *argv[])
{
    cout << "执行饿汉式的单例模式" << endl;

    Singleton *s1 = Singleton::getInstance();
    Singleton *s2 = Singleton::getInstance();
    if (s1 == s2) {
        cout << "是同一个对象" << endl;
    }
    else {
        cout << "不是同一个对象" << endl;
    }

    Singleton::freeInstance();

    return 0;
}
```

执行结果：

```
执行构造函数
执行饿汉式的单例模式
是同一个对象
执行析构函数
释放对象内存
```

执行 `main` 函数之前就创建了一个对象，一直到程序的生命周期结束，被创建对象的内存才会得到释放。若多线程访问时，在线程还没开始启动之前，类的实例就被创建完成了，因此就不会存在多线程安全的问题。

使用场景

- 适用于单例对象较少的情况。这样可以保证绝对线程安全、执行效率比较高。
- 如果系统中有很多的地方使用了饿汉单例模式，系统初始化时就创建很多的单例对象，会导致大量的内存浪费。即无论对象用与不用都占着空间，浪费了内存空间。

#### 4.1.3.2. 懒汉式

懒汉式就是代码中需要调用类的实例时，才会创建类的实例。比如，第一次在调用 `getInstace()`  的方法时，会去创建类的实例，给实例分配内存空间，而不是在类加载的时候就创建类的实例和分配空间，这种技术又称为 **延迟加载(Lazy Load)** 技术。

普通懒汉式代码实现

```cpp
#include <iostream>
#include <unistd.h>

using namespace std;

class Singleton
{
public:
    static Singleton* getInstance() {
        if (m_Instance == nullptr) {
            m_Instance = new Singleton;     
        }
        return m_Instance;
    }

    // 手动释放内存
    static Singleton* freeInstance() {
        if (m_Instance != nullptr) {
            delete m_Instance;
            m_Instance = nullptr;
            cout << "Free instance memory." << endl;
        }
        return m_Instance;
    }
private:
    Singleton() { cout << "Execute constructor." << endl; }
    ~Singleton() { cout << "Execute destructor." << endl; }
    static Singleton* m_Instance;           // 静态指针    
};

// 静态全局变量初始化
Singleton* Singleton::m_Instance = nullptr; 
```

这种以时间换空间的方式，节约了效率，但最重要的问题是：在多线程访问时单例模式可能存在线程安全的问题。

多线程访问懒汉单例模式，代码实现，支持 C++11 风格。

```cpp
#include <unistd.h>
#include <stdlib.h>
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

using namespace std;

class Singleton
{
public:
    static Singleton* getInstace(const std::string& value);

    /**
     * Singletons should not be cloneable.
     */
    Singleton(Singleton& other) = delete;

    /**
     * Singletons should not be assignable.
     */
    void operator=(const Singleton&) = delete;

    std::string getValue() {
        return m_value;
    }

private:
    Singleton(const std::string value);     // constructor
    ~Singleton();                           // destructor
    static Singleton* m_singleton;          // 静态成员指针
    std::string m_value;
};

// 静态变量外部初始化
Singleton* Singleton::m_singleton = nullptr;

// 没有加锁，存在多个线程访问时资源竞争的问题
Singleton* Singleton::getInstace(const std::string& value)
{
    if (m_singleton == nullptr) {
        m_singleton = new Singleton(value);
    }
    return m_singleton;
}

Singleton::Singleton(const std::string value)
    : m_value(value)
{
}

Singleton::~Singleton()
{
}

// 第一个线程处理函数
void ThreadFirst()
{
    std::this_thread::sleep_for(chrono::milliseconds(1000));
    Singleton* singleton = Singleton::getInstace("First");
    std::cout << singleton->getValue() << std::endl;
}

// 第二个线程处理函数
void ThreadSecond()
{
    std::this_thread::sleep_for(chrono::milliseconds(1000));
    Singleton* singleton = Singleton::getInstace("Second");
    std::cout << singleton->getValue() << std::endl;
}

int main(int argc, char *argv[]) 
{
    std::thread t1(ThreadFirst);
    std::thread t2(ThreadSecond);
    t1.join();                          // 回收创建的线程，避免资源浪费
    t2.join();

    return 0;
}
```

实现结果：有时出现下面第一种情况，有时出现下面第二中情况。因此存在多个线程访问时，有资源竞争的问题。

```
// 第一种情况
Second
First
```

```
// 第二种情况
First
First
```

针对上面的两种情况，我们知道第二种结果肯定是我们期望的，但为什么会产什么第一种结果呢？

因为： 假如在某一瞬间线程 A 和线程 B 都在调用 `getInstance()` 方法，此时实例对象为 `nullptr` 值，均能通过 `m_Instance == nullptr` 的判断。当线程 1   `new` 一个对象的过程还没有完成时，线程 2 也通过了判断，需要去 `new` 一个对象，现在程序中存在两个不同的对象，违背了单例模式的原则，因此是多线程不安全的。 至于哪个先被创建，则取决于线程抢占的时机。

现在我们思考下，要怎么去解决多线程访问不安全的问题？下面我们来一一探讨。

#### 4.1.3.3. C++ 中多线程安全问题？

- 第一种：牺牲内存空间，采用饿汉式单例模式，用法见上面的饿汉式的实现过程。

- 第二种：加锁。既然多个线程访问时，不能确定同一时间内有多少个线程同时访问，导致资源竞争（race condition）的问题。那么就给线程加把锁，让每个线程每次访问的时候，同一时间内只有一个线程在创建对象，其它的线程需要等锁的资源被释放后，才能工作。这样就保证了多个线程访问时，线程是安全的。
  
  首先我们在实例是否被创建之前就去加锁。
  
  ```cpp
  #include <iostream>
  #include <stdlib.h>
  #include <pthread.h>
  #include <mutex>
  #include <unistd.h>
  
  using namespace std;
  std::mutex m_mutex;
  
  class Singleton
  {
  public:
      static Singleton* getInstance() {
          m_mutex.lock();
          if (m_Instance == nullptr) {
              m_Instance = new Singleton;     
          }
          m_mutex.unlock();
          return m_Instance;
      }
  
      // 手动释放内存    
      static Singleton* freeInstance() {
          if (m_Instance != nullptr) {
              delete m_Instance;
              m_Instance = nullptr;
              cout << "Free instance memory." << endl;
          }
          return m_Instance;
      }
  private:
      Singleton() { cout << "Execute constructor." << endl; }
      ~Singleton() { cout << "Execute destructor." << endl; }
      static Singleton* m_Instance;           // 静态指针    
  };
  
  // 静态全局变量初始化
  Singleton* Singleton::m_Instance = nullptr; 
  ```
  
  上述代码虽然解决了线程安全问题，但是每次调用 `getInstance()` 时都需要进行锁的判断。假设当线程 1 在执行 `m_instance = new Singleton()` 的时候，线程 2 也在调用 `getInstance()`，线程 2 一定会被阻塞在加锁处，等待线程 1 执行结束后释放这个锁，最后再去执行线程 2。在多线程高并发访问环境中，频繁的进行加锁和解锁，将会导致系统性能大大降低，因为加锁和解锁都是一个耗时的过程。
  
  那如何既解决线程安全问题又不影响系统性能呢？下面我们继续对懒汉式单例进行改进。
  
  ```cpp
  static Singleton* getInstance() {
      if (m_Instance == nullptr) {
          m_mutex.lock();              // 加锁
          if (m_Instance == nullptr) {
              m_Instance = new Singleton;     
          }
          m_mutex.unlock();
      }
      return m_Instance;
  }
  ```
  
  加锁和解锁的步骤只有在第一次执行 `new Singleton()` 才是有必要的，只要 `m_instance` 实例被创建出来了，就没必要加锁解锁了，直接返回这个对象的指针。以后不管多少线程同时访问，使用 `if (m_instance == nullptr) `进行判断就行了（只是读操作，不需要加锁），没有线程安全问题，加了锁之后反而存在性能问题。因此我们在加锁之前再进行一次实例是否存在的判断。两次进行加锁判断的这种方式称为**双重检查锁定(Double Check Locking)**。
  
  是不是觉得这样就完美啦？其实在一段时间内，大家都以为这是正确的、有效的做法。实际上却不是这样的。幸运的是，后来有大牛们发现了DCL中的问题，避免了这样错误的写法在更多的程序代码中出现。原因是内存读写的乱序执行造成的（编译器的问题）。
  
  那么到底错在哪里？
  
  我们看 `m_instance = new Singleton()` 这句话，是创建对象的过程。其实这个过程可以分成三个步骤来执行：
  
  1. 分配了一个 `Singleton` 类型对象所需要的内存。
  2. 在分配的内存处构造 `Singleton` 类型的对象。
  3. 把分配的内存的地址赋给指针 `m_instance`。
  
  主观上，我们会觉得计算机在会按照1、2、3 的步骤来执行的，但是问题就出在这。实际上只能确定步骤 1 最先执行，而步骤 2、3 的执行顺序却是不一定的。假如某个线程 A 在调用执行`m_instance = new Singleton()` 的时候是按照 `1, 3, 2` 的顺序的，那那么当刚刚执行完步骤 3 的时候发生线程切换，计算机开始执行另外一个线程 B。因为第一次 check 没有上锁保护，那么在线程 B 中调用 `getInstance` 的时候，不会在第一次 check 上等待，而是执行后面的语句，而此时发现 `m_instance` 已经被赋值了，就会直接返回 `m_instance`，但是在线程 A 中步骤 2 还没有执行，对象没有被构造！也就是说在线程 B 中通过 `getInstance` 返回的对象还没有被构造就被拿去使用了！这样就会发生一些难以debug的灾难问题。

- 加锁的过程中，需要思考的问题？
  
  **类中资源的初始化可能有顺序问题，一些资源依赖于其他资源的初始化，可能会导致一些资源释放的问题。**

- 第三种：静态局部变量。
  
  `java` 和 `c#` 发现这个问题后，就加了一个关键字 `volatile`，在声明 `m_instance`变量的时候，要加上`volatile`修饰，编译器看到之后，就知道这个地方不能够 reorder（一定要先分配内存，在执行构造器，都完成之后再赋值）。而对于 `c++` 标准却一直没有改正，所以 `VC++` 在 `2005` 版本也加入了这个关键字，但是这并不能够跨平台（只支持微软平台）。不过在新的 C++11 中，这个问题得到了解决。因为新的 C++11 规定了新的内存模型，保证了执行上述 3 个步骤的时候不会发生线程切换，相当这个初始化过程是“原子性”的的操作，DCL 又可以正确使用了。不过在 C++11 下却有更简洁的多线程 Singleton 写法了，比如用局部静态变量（local static variable）。
  
   C++11 以上，其设置为 `static`，再将该单例对象这样运行时确保只调用一次静态构造函数，实现的代码量不仅少。
  
  ```cpp
  #include <iostream>
  #include <unistd.h>
  
  using namespace std;
  
  class Singleton
  {
  public:
      static Singleton& getInstance() {
          static Singleton instance;
          return instance;
      }  
  
  private:
      Singleton() { cout << "Execute constructor." << endl; }
      ~Singleton() { cout << "Execute destructor." << endl; } 
  };
  ```
  
  原因在于在C++11之前的标准中并没有规定local static变量的内存模型，所以很多编译器在实现local static变量的时候仅仅是进行了一次check，但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。
  
  不过有些编译器在C++11之前的版本就支持这种模型，例如g++，从g++4.0开始，meyers singleton就是线程安全的，不需要 C++11。其他的编译器就需要具体的去查相关的官方手册了。

### 4.1.4. 单例模式内存释放

大多数时候，使用上面第一种或第二种方法获取实例，不去手动释放内存，这种实现都不会出现问题，因为程序结束时，操作系统会负责自动回收资源，替代了人为的实现的过程。但有经验的读者可能会问，`m_Instance` 指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？如果在类的析构中执行一些必须的操作，比如关闭文件描述符，销毁锁的资源等。那么上面的代码无法实现这个要求，我们需要一种方法，正常的删除该实例。

单例模式中释放用 new 申请的内存，有两种方式可以实现。

第一种：在类中定义一个属性为 `public` 的内存销毁的方，使用 `delete` 关键字实现去释放内存。给外部类提供接口，去销毁对象。 

```cpp
static Singleton* freeInstance() {
    if (m_Instance != nullptr) {
        delete m_Instance;
        m_Instance = nullptr;
        cout << "Free instance memory." << endl;
    }
    return m_Instance;
}
```

第一种方式可以实现内存的释放，但有时候忘记去写销毁内存的方法了，程序可能会出现问题。那么有没有一种方式：单例模式运行的生命周期结束时，自动去释放申请的内存，不用在类的外部额外的手动销毁，有一点类似于垃圾回收机制，这就是第二种方式。

我们知道，程序在结束的时候，系统会自动析构所有的全局变量。事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样。利用这个特征，我们可以在单例类中定义一个这样的静态成员变量，而它的唯一工作就是在析构函数中删除单例类的实例。

```cpp
class Singleton
{
public:
    static Singleton* getInstace(const std::string& value);               // 懒汉式
    Singleton(Singleton& other) = delete;                                 // 禁止拷贝操作
    const Singleton& operator=(const Singleton&) = delete;                // 禁止赋值操作

    std::string getValue() {
        return m_value;
    }

private:
    // GC 类：程序结束时，进入析构函数销毁 Singleton 类的实例
    class GC
    {
    public:
        GC() {}
        ~GC() {
            if (m_Instance != nullptr) {
                delete m_Instance;
                m_Instance = nullptr;
                cout << "Exec GC dector, delete m_Instance.\n";
            }
        }
    };

    static GC gc;                           // 定义静态成员变量，当程序结束时，会调用 GC 类的析构函数

private:
    Singleton(const std::string value);     // constructor
    ~Singleton();                           // destructor

    static Singleton* m_Instance;           // 静态成员指针
    std::string m_value;
};

// 静态变量外部初始化
Singleton::GC Singleton::gc; 
Singleton* Singleton::m_Instance = nullptr;

Singleton::Singleton(const std::string value)
    : m_value(value)
{
    cout << "Exec Singleton ctor.\n";
}

Singleton::~Singleton()
{
    cout << "Exec Singleton dector.\n";
}

// 懒汉式单例，存在多个线程访问时资源竞争的问题
Singleton* Singleton::getInstace(const std::string& value)
{
    if (m_Instance == nullptr) {
        m_Instance = new Singleton(value);
    }
    return m_Instance;
}


// 第一个线程处理函数
void ThreadFirst()
{
    std::this_thread::sleep_for(chrono::milliseconds(1000));
    Singleton* singleton = Singleton::getInstace("First");
    std::cout << singleton->getValue() << std::endl;
}

// 第二个线程处理函数
void ThreadSecond()
{
    std::this_thread::sleep_for(chrono::milliseconds(1000));
    Singleton* singleton = Singleton::getInstace("Second");
    std::cout << singleton->getValue() << std::endl;
}

int main(int argc, char *argv[]) 
{
    std::thread t1(ThreadFirst);
    std::thread t2(ThreadSecond);
    t1.join();                          // 回收创建的线程，避免资源浪费
    t2.join();

    return 0;
}
```

执行结果

```
Exec Singleton ctor.
First
Exec Singleton ctor.
Second
Exec Singleton dector.
Exec GC dector, delete m_Instance.
```

### 4.1.5. 单例模式优缺点

优点

- 在内存中只有一个对象，节省内存空间。
- 避免频繁的创建销毁对象，可以提高性能。
- 避免对共享资源的多重占用，简化访问。
- 为整个系统提供一个全局访问点。

缺点

- 单例模式中没有抽象层，单例类的可扩展性差。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。

### 4.1.6. 参考

- [java单例模式](https://blog.csdn.net/czqqqqq/article/details/80451880)
- [设计模式之单例模式](https://segmentfault.com/a/1190000015950693)：segmentfault 上面使用C++实现的单例模式。
- [C++中多线程与Singleton的那些事儿](https://www.cnblogs.com/liyuan989/p/4264889.html)：写的很详细。
- [《C++ and the Perils of Double-Checked Locking》](http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf)

## 4.2. **Factory Method(工厂模式)**

**简单工厂模式**

简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

- 举例：
  简单工厂模式像一个代工厂，一个工厂可以生产多种产品。举个例子，一个饮料加工厂同时帮百事可乐和可口可乐生产，加工厂根据输入参数``Type``来生产不同的产品。

- 优点
  
  * 使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。
    * 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。

- 缺点
  
  * 如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的。
  * 在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况。

### 4.2.1. 什么是 Factory Method？

工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。<font color=red>Factory Method 将类的实例化推迟到子类中。</font>

举例子：工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。

### 4.2.2. 优点

* 用户只需要关心其所需产品对应的具体工厂是哪一个即可，不需要关心产品的创建细节，也不需要知道具体产品类的类名。
* 当系统中加入新产品时，不需要修改抽象工厂和抽象产品提供的接口，也无须修改客户端和其他的具体工厂和具体产品，而只要添加一个具体工厂和与其对应的具体产品就可以了，符合了开闭原则。

### 4.2.3. 缺点

* 当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类。因此系统中类的个数将成对增加，增加了系统的复杂度。

## 4.3. **Abstract Factory(抽象工厂模式)**

### 4.3.1. 什么是抽象工厂模式？

<font color=red>
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。它封装了一组相关的工厂。
</font>

--------------------

举例子：抽象工厂和工厂方法不同的地方在于：生产产品的工厂是抽象的。举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。

### 4.3.2. UML图

<img src="./figures/Abstract_factory_UML.svg">

### 4.3.3. 优点

* 具体产品在应用层代码隔离，不需要关心产品细节。只需要知道自己需要的产品是属于哪个工厂的即可。当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。

### 4.3.4. 缺点

* 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。

### 4.3.5. 工厂模式与抽象工厂模式的区别

<font color=red>
工厂模式只能生产一个产品；而抽象工厂模式可以产生一列的产品。
</font>

## 4.4. **Builder(建造者模式)**

### 4.4.1. 什么是建造者模式?

<font color=red>
将一个复杂对象的构建与它的表示进行分离，使得同样的构建过程可以创建不同的表示。
</font>

### 4.4.2. 适用性

- 创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式。
- 构造过程必须允许被构造的对象有不同的表示

### 4.4.3. UML图

<img src="./figures/Builder_UML_class_diagram.svg">

### 4.4.4. 优点

* 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
* 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
* 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

### 4.4.5. 缺点

* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
* 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

## 4.5. Prototype(原型模式)

### 4.5.1. 什么是原型模式？

<font color=red>
指定类的原型实例，拷贝该实例来创建新的对象。
</font>

原型模式为每个对象提供一个接口，让一个复杂的对象具有自我复制的功能，统一一套接口。举例子：原型模式就像复印技术，根据原对象复印出一个新对象，并根据需求对新对象进行微调。

### 4.5.2. 优点

* 可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。
* 可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。

### 4.5.3. 缺点

* 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。

# 5. Structural patterns(结构型模式)

## 5.1. Composite(组合模式)

### 5.1.1. 什么是组合模式？

<font color=red>
组合模式是将对象组合成树型结构以表示“部分-整体”的层次结构。 Composite使得客户对单个对象和复合对象的使用具有一致性。
</font>

## 5.2. **Proxy(代理模式)**

### 5.2.1. 什么是代理模式？

<font color=red>
为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。
</font>

- 举例子：代理模式像一个房屋中介，买家只能通过中介来买房，代理具备被代理类的所有功能，就像房东有卖房功能，中介也具有卖房功能。此外代理实例还可以帮助被代理实例进行一些额外处理，比如中介可以帮助房东筛选优质买家的功能，帮助房东pass掉一些不符合条件的买家。还有消息队列也是该模式。

### 5.2.2. 优点

* 降低系统的耦合度：代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
* 不同类型的代理可以对客户端对目标对象的访问进行不同的控制：
  * 远程代理,使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
  * 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。
  * 保护代理可以控制客户端对真实对象的使用权限。

### 5.2.3. 缺点

* 由于在客户端和被代理对象之间增加了代理对象，因此可能会让客户端请求的速度变慢。

## 5.3. **Decorator装饰器模式)**

### 5.3.1. 什么是装饰器模式？

<font color=red>
装饰模式是动态地给一个对象添加一些额外的职责。就扩展功能而言， Decorator 模式比生成子类方式更为灵活。
</font>

## 5.4. **Adapter(适配器)**

### 5.4.1. 什么是适配器模式？

<font color=red>
适配器模式是将一个类的接口转换成另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
</font>

### 5.4.2. 优点

将一些旧的接口放到新的接口中使用，但新接口的功能是旧接口所不包含的。在遗留代码、类库迁移中是非常有用的。

## 5.5. **Bridge(桥接模式)**

### 5.5.1. 什么是桥接模式？

<font color=red>
桥接模式是将抽象部分与它的实现部分进行分离，使它们都可以独立地变化。
</font>

## 5.6. Facade(外观模式)

### 5.6.1. 什么是外观模式？

<font color=red>
为子系统中的一组接口提供统一的高层次接口。
</font>

### 5.6.2. Facade模式概述

- Facade模式描述了怎样用对象表示完整的子系统。
- 定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。
- 外观模式提供了简单明确的接口，将内部众多子系统功能进行整合。像图片缓存，内部包含了涉及到其他子系统的如缓存、下载等处理，外观模式将这些复杂的逻辑都隐藏了。

### 5.6.3. 优点

- 实现了客户端与子系统间的解耦：客户端无需知道子系统的接口，简化了客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。
- 符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可，而且他的接口则可以隐藏起来。

### 5.6.4. 缺点

- 违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的代码。

## 5.7. Flyweight(享元模式)

### 5.7.1. 什么是享元模式？

<font color=red>
描述了如何支持大量的最小粒度的对象。运用共享技术复用大量细粒度的对象，降低程序内存的占用，提高程序的性能。
</font>
享元模式保证共享内部状态，而外部状态根据不同需求定制如各种访问权限，使用中不能去改变内部状态，以达到共享的目的。

---------------

例子

> 音乐服务根据收费划分出免费用户和会员用户，免费用户只能听部分免费音乐，会员用户可以听全部的音乐，并且可以下载。虽然权限上二者间有一些区别，但是他们所享受的音乐来是自于同一个音乐库，这样所有的音乐都只需要保存一份就可以了。另外如果出现音乐库里没有的音乐时，则需要新增该音乐，然后其他服务也可以享受新增的音乐，相当于享元池或缓存池的功能。

### 5.7.2. 优点

- 使用享元模可以减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低系统的使用内存，也可以提性能。
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

### 5.7.3. 缺点

- 使用享元模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 对象在缓冲池中的复用需要考虑线程问题。

# 6. Behavioural patterns(行为型模式)

## 6.1. **Template Method(模板方法模式)**

### 6.1.1. 模板模式概述

模板方法模式是最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。

### 6.1.2. 什么是模板方法模式？

<font color=red>
定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义（override: 重写）该算法的某些特定步骤。延迟：子类实现父类的虚函数。
</font>

### 6.1.3. UML图

<img src="./figures/TemplatePattern.jpg">

### 6.1.4. 优点

(1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。

(2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。

(3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。

(4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。

### 6.1.5. 缺点

- 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。

### 6.1.6. 应用场景

(1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。

(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。

参考

- [Six common uses of the Template Design Pattern: Design Pattern series](https://www.codeproject.com/Articles/307452/common-use-of-Template-Design-pattern-Design-pat)

## 6.2. **command(命令模式)**

### 6.2.1. 命令行模式概述

在软件开发中，我们经常需要向某些对象发送请求（调用其中的某个或某些方法），但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，此时，我们特别希望能够以一种松耦合的方式来设计软件，使得请求发送者与请求接收者能够消除彼此之间的耦合，让对象之间的调用关系更加灵活，可以灵活地指定请求接收者以及被请求的操作。命令模式为此类问题提供了一个较为完美的解决方案。

### 6.2.2. 什么是命令模式？

<font color=red>
将一个请求或操作封装成一个对象，用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。
</font>
命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。

命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。例如遥控器是一个调用者，不同按钮代表不同的命令，而电视是接收者。

### 6.2.3. UML图

<img src="./figures/CommandPattern.jpg">

### 6.2.4. 优点

- 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。
- 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。
- 可以比较容易地设计一个命令队列或宏命令（组合命令）。
- 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。

### 6.2.5. 缺点

- 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。

### 6.2.6. 应用场景

(1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。

(2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。

(3) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。

(4) 系统需要将一组操作组合在一起形成宏命令。

## 6.3. **strategy(策略模式)**

### 6.3.1. 什么是策略模式？

<font color=red>
定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
</font>

将抽象部分与它的实现部分进行分离，使它们都可以独立的变化。相同的接口，不同的实现类，同一方法结果不同，实现的策略也不同。比如一个配置文件，是放在 xml 里，还是放在 json 文件里，实现的策略是不同的。

## 6.4. **mediator(中介者模式)**

### 6.4.1. 什么是中介者模式？

<font color=red>
用一个中介对象来封装一系列的对象交互。
</font>
中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

## 6.5. **observer(观察者模式)**

### 6.5.1. 什么是观察者模式？

<font color=red>
定义对象之间的一种一对多的依赖关系，以便每当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
</font>
观察者模式也叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。

-------

在观察者模式中，发生改变的对象称为观察目标（Subject），而被通知的对象称为观察者（Observer），一个 Subject 可以对应无数个 Observer，而且这些 Observer 相互之间可以没有的任何联系，一旦 Subject 的状态发生改变 , 所有的 Observer 都得到通知。作为对这个通知的响应，每个观察者都将查询观察目标，使其状态与目标的状态同步。

<p> 使用一个图来简单说明 <br>
<img src="./figures/observer.png">
</p>

### 6.5.2. 为什么要用observer？

- 一般的设计是将一个系统分割成一系列相互协作的类，这样做有一个常见的副作用：需要维护相关对象间的一致性。但是我们不希望为了维持这种一致性而使各个类紧密耦合，这样做降低了它们的可重用性。而使用观察者模式降低了耦合度，观察目标不必要了解正在观察自己的观察者的具体类型，只需要知道基本接口（基类）即可。
- 可以根据需要增加和删除观察者，使得系统更易于扩展。
- 对象维护一个它所依赖的对象（观察者）列表，并通过调用观察者的方法通知观察者。

### 6.5.3. 怎样去使用observer？

- 当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中，使它们可以各自独立地改变和复用。
- 当对一个对象的改变需要同时改变其它的对象, 但是不知道具体有多少对象要被改变。
- 当一个对象必须通知其它对象时，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象之间是紧密耦合的。

### 6.5.4. UML图

<img src="./figures/ObserverPattern.jpg">

- Subject（观察目标）
  - 观察目标知道它有哪些观察者，它可以有任意多个观察者观察同一个目标。
  - 保存一个观察者列表，将观察者注册进来，以便获得通知。
  - 支持添加或删除观察者对象，而且还能通知所有已注册的观察者。
- Observe（观察者）
  - 为那些在观察目标发生改变时需获得通知的对象定义一个更新接口。
- ConcreteSubject（具体的观察目标）
  - 将有关状态存入各个 ConcreteObserver 对象。
  - 当它的状态发生改变时, 向它的各个观察者发出通知。
- ConcreteObserver（具体的观察者）
  - 维护一个指向 ConcreteSubject 对象的引用。
  - 存储有关状态，这些状态应与观察目标的状态保持一致。
  - 实现 Observer 更新接口以使自身状态与观察目标的状态保持一致。

### 6.5.5. 执行步骤

- 当 ConcreteSubject 发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者。

- 在得到一个具体观察目标的改变通知后, ConcreteObserver 对象可向观察目标对象查询信息。ConcreteObserver 使用这些信息让它的状态与观察目标对象的状态一致。
  
  <img src="./figures/ObserverPatternConcrete.jpg">

> 注意发出改变请求的 Observer 对象并不立即更新 ,而是将其推迟到它从目标得到一个通知之后。Notify 不总是由目标对象调用。它也可被一个观察者或其它对象调用。

### 6.5.6. 优点

Observer 模式允许你独立的改变目标和观察者。你可以单独复用目标对象而无需同时复用其观察者, 反之亦然。它也使你可以在不改动目标和其他的观察者的前提下增加观察者。

- 观察目标和观察者间的抽象耦合。一个观察目标所知道的仅仅是它有一系列观察者, 每个都符合抽象 Observer 类的简单接口，观察目标并不知道任何一个观察者是属于哪一个具体的类，这样观察目标和观察者之间的耦合是抽象的、也是最小的。
  
  > 因为观察目标和观察者不是紧密耦合的, 它们属于一个系统中的不同抽象层次。一个处于较低层次的观察目标对象可与一个处于较高层次的观察者通信并通知它, 这样就保持了系统层次的完整性。如果观察目标和观察者混在一块 , 那么得到的对象要么横贯两个层次 (违反了层次性), 要么必须放在这两层的某一层中(这可能会损害层次抽象)。

- 支持广播通信。不像通常的请求, 观察目标发送的通知不需指定它的接收者，通知被自动广播给所有已向该观察目标对象登记的有关对象。观察目标对象并不关心到底有多少对象对自己有用，它唯一的责任就是通知它的各个观察者。这给了你在任何时刻增加和删除观察者的自由，处理还是忽略一个通知取决于观察者。

### 6.5.7. 缺点

- 意外的更新。一个观察者并不知道还有其它的观察者存在, 它可能对改变观察目标的最终代价一无所知。在观察目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。如果依赖准则的定义或维护不当，常常会引起错误的更新, 这种错误通常很难捕捉。 
- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 6.5.8. 使用时注意事项？

- 创建观察目标到其观察者之间的映射。一个观察目标对象跟踪它应通知的观察者的最简单的方法是显式地在观察目标中保存对它们的引用。然而, 当观察目标很多而观察者较少时, 这样存储可能代价太高。一个解决办法是用时间换空间, 用一个关联查找机制 (例如一个 hash 表)来维护观察目标到观察者的映射。这样一个没有观察者的观察目标就不产生存储开销。但另一方面, 这一方法增加了访问观察者的开销。

- 观察多个观察目标。在某些情况下, 一个观察者依赖于多个观察目标可能是有意义的。例如, 一个表格对象可能依赖于多个数据源。在这种情况下, 必须扩展 Update 接口以使观察者知道是哪一个观察目标送来的通知。观察目标对象可以简单地将自己作为 Update 操作的一个参数, 让观察者知道应去检查哪一个观察目标。

- 谁触发更新。 观察目标和它的观察者依赖于通知机制来保持一致。但到底哪一个对象调用 Notify 来触发更新? 此时有两个选择:
  
  - 由观察目标对象的状态设定操作在改变观察目标对象的状态后自动调用 Notify。这种方法的优点是客户不需要记住要在观察目标对象上调用 Notify，缺点是多个连续的操作会产生多次连续的更新, 可能效率较低。
  - 让客户负责在适当的时候调用 Notify。这样做的优点是客户可以在一系列的状态改变完成后再一次性地触发更新，避免了不必要的中间更新。缺点是给客户增加了触发更新的责任。由于客户可能会忘记调用 Notify，这种方式较易出错。

- 对已删除观察目标的悬挂引用。 删除一个观察目标时应注意不要在其观察者中遗留对该观察目标的悬挂引用。一种避免悬挂引用的方法是：当一个目标被删除时，让它通知它的观察者将对该观察目标的引用复位。一般来说, 不能简单地删除观察者, 因为其他的对象可能会引用它们 , 或者也可能它们还在观察其他的观察目标。

- 在发出通知前确保观察目标的状态自身是一致的。在发出通知前确保状态自身一致这一点很重要, 因为观察者在更新其状态的过程中需要查询观察目标的当前状态。

- 避免特定于观察者的更新协议：推/拉模型。观察者模式的实现经常需要让观察目标广播关于其改变的其他一些信息。观察目标将这些信息作为 Update 操作一个参数传递出去。这些信息的量可能很小，也可能很大。
  
  - 一个极端情况是，观察目标向观察者发送关于改变的详细信息, 而不管它们需要与否，我们称之为推模型(push model)。另一个极端是拉模型(pull model)： 观察目标除最小通知外什么也不送出 ,而在此之后由观察者显式地向目标询问细节。
  - 拉模型强调的是观察目标不知道它的观察者 , 而推模型假定观察目标知道一些观察者的需要的信息。推模型可能使得观察者相对难以复用，因为观察目标对观察者的假定可能并不总是正确的。另一方面，拉模型可能效率较差, 因为观察者对象需在没有观察目标对象帮助的情况下确定什么改变了。

- 显式地指定感兴趣的改变。 你可以扩展目标的注册接口 ,让各观察者注册为仅对特定事件感兴趣，以提高更新的效率。当一个事件发生时, 观察目标仅通知那些已注册为对该事件感兴趣的观察者。支持这种做法一种途径是，对使用目标对象的方面（aspects）的概念。可用如下代码将观察者对象注册为对观察目标对象的某特定事件感兴趣：
  `void Subject::Attach(Observer*, Aspect& interest);`
  此处 interests 指定感兴趣的事件。在通知的时刻, 观察目标将这方面的改变作为 Update 操作的一个参数提供给它的观察者，例如 :`void Observer::Update(Subject*, Aspect& interest);`

- 封装复杂的更新语义。当观察目标和观察者间的依赖关系特别复杂时, 可能需要一个维护这些关系的对象，我们称这样的对象为更改管理器（ChangeManager）。它的目的是尽量减少观察者反映其观察目标的状态变化所需的工作量。例如, 如果一个操作涉及到对几个相互依赖的目标进行改动, 就必须保证仅在所有的观察目标都已更改完毕后，才一次性地通知它们的观察者 ,而不是每个观察目标都通知观察者。ChangeManager有三个责任:
  
  - 它将一个观察目标映射到它的观察者并提供一个接口来维护这个映射。这就不需要由观察目标来维护对其观察者的引用, 反之亦然。
  - 它定义一个特定的更新策略。
  - 根据一个观察目标的请求, 它更新所有依赖于这个目标的观察者。

### 6.5.9. Relations with Other Patterns

- Chain of Responsibility(责任链模式)、 Command(命令模式)、 Mediator(中介者模式)和 Observer(观察者模式)用于处理请求发送者和接收者之间的不同连接方式：
  
  - 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。
  - 命令在发送者和请求者之间建立单向连接。
  - 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。
  - 观察者允许接收者动态地订阅或取消接收请求。

- 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
  
  - 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。
  
  - 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。
  
  - 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。
  
  - 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。

## 6.6. **iterator(迭代器模式)**

### 6.6.1. 什么是迭代器模式？

在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。

<font color=red>
迭代模式是提供一种方法来顺序遍历聚合对象中的各个元素，而不用暴露这个对象的内部结构。
</font>

### 6.6.2. UML图

<p><img src="./figures/IteratorPattern.jpg"></p>
### 6.6.3. 优点

- 通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。
- 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

### 6.6.4. 缺点

- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
- 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。

### 6.6.5. 应用场景

(1) 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。

(2) 需要为一个聚合对象提供多种遍历方式。

(3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。

## 6.7. **visitor(访问者模式)**

### 6.7.1. 访问者模式概述

访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。例如处方单中的各种药品信息就是被访问的元素，而划价人员和药房工作人员就是访问者。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。

在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。

### 6.7.2. 什么是访问者模式？

<font color=red>
封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。
</font>
访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。

> 注意：Visitor接口必须反映出visitor能访问的对象的所有类。

### 6.7.3. UML图

<img src="./figures/VisitorPattern.jpg">

### 6.7.4. 优点

(1) 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。

(2) 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。

(3) 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。

### 6.7.5. 缺点

(1) 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。

(2) 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。

### 6.7.6. 应用场景

(1) 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。

(2) 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。

(3) 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。

## 6.8. chain of responsibility(责任链模式)

### 6.8.1. 什么是责任链模式？

<font color=red>
为解除请求的发送者和接收者之间耦合，使多个对象有机会处理来自发送者对象的请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
</font>

## 6.9. memento(备忘录模式)

### 6.9.1. 什么是备忘录模式？

<font color=red>
捕获对象内部的状态，以便将来可将该对象恢复到保存的状态。
</font>
它规定了Memento对象必须定义两个接口：一个是允许客户保持和复制Memento的限制接口；另一个是只有原对象才能使用的用来存储和提取Memento中状态的特权接口。

## 6.10. state(状态模式)

### 6.10.1. 什么是状态模式？

<font color=red>
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
</font>

## 6.11. interpreter(解释器模式)

### 6.11.1. 什么是解释器模式？

<font color=red>
指定如何对某种语言的语句进行表示和判断。
</font>

# 7. 参考

- [Wiki解释设计模式](https://en.wikipedia.org/wiki/Software_design_pattern)：具有权威性和系统性。
- [refactoring.guru](https://refactoring.guru/design-patterns): 这是一本关于设计模式及其背后原则的电子书籍。比较详细的介绍了设计模式的用法，很通俗易懂。
- [设计模式：可复用面向对象软件的基础](https://en.wikipedia.org/wiki/Design_Patterns)：Wiki中关于GOF这本设计模式数据的描述，很有权威性。
- [GoF Design Patterns reference](http://w3sdesign.com/index0100.php): Learning Object-Oriented Design & Programming。
- [史上最全设计模式导学目录（完整版）](https://blog.csdn.net/lovelion/article/details/17517213)：刘伟老师力作，讲的非常好，通俗易懂，而且举例的应用场景也非常恰当。
- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/#) 利用许多的图例去描述每一种设计模式的过程，值得参考学习。
- [Github: 学习并理解 23 种设计模式](https://github.com/xietao3/Study-Plan/tree/master/DesignPatterns) Github上笔者记录自己学习设计模式的笔记。
- [Trip-to-iOS-Design-Patterns](https://github.com/skyming/Trip-to-iOS-Design-Patterns)：Github上笔者从设计模式、架构、实践三个方面梳理了 iOS 架构的设计，推荐了许多不错的学习设计模式的书籍和诸多实战的项目。
- [JAVA设计模式总结之23种设计模式](https://www.cnblogs.com/pony1223/p/7608955.html)
- [JAVA设计模式总结之六大设计原则](https://www.cnblogs.com/pony1223/p/7594803.html)
