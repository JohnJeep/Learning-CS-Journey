<!--
 * @Author: JohnJeep
 * @Date: 2020-08-06 22:20:12
 * @LastEditTime: 2020-09-10 16:14:46
 * @LastEditors: Please set LastEditors
 * @Description: 设计模式学习
-->
<!-- TOC -->

- [0.1. 参考](#01-参考)
- [0.2. 设计模式概括](#02-设计模式概括)
- [0.3. 创建型 - 设计模式](#03-创建型---设计模式)
  - [0.3.1. 单例模式](#031-单例模式)
  - [0.3.2. 简单工厂模式](#032-简单工厂模式)
  - [0.3.3. 工厂模式](#033-工厂模式)
  - [0.3.4. 抽象工厂模式](#034-抽象工厂模式)
  - [0.3.5. 建造者模式](#035-建造者模式)
  - [0.3.6. 原型模式](#036-原型模式)
- [0.4. 结构型 - 设计模式](#04-结构型---设计模式)

<!-- /TOC -->
## 0.1. 参考
- [史上最全设计模式导学目录（完整版）](https://blog.csdn.net/lovelion/article/details/17517213)：推荐指数五颗星；刘伟老师力作，讲的非常好，通俗易懂，而且举例的应用场景也非常恰当。
- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/#) 推荐指数四颗星；利用许多的图例去描述每一种设计模式的过程，值得参考学习。
- [Github: 学习并理解 23 种设计模式](https://github.com/xietao3/Study-Plan/tree/master/DesignPatterns) 推荐指数四颗星；Github上笔者记录自己学习设计模式的笔记。
- [Trip-to-iOS-Design-Patterns](https://github.com/skyming/Trip-to-iOS-Design-Patterns)：推荐指数三颗星；Github上笔者从设计模式、架构、实践三个方面梳理了 iOS 架构的设计，推荐了许多不错的学习设计模式的书籍和诸多实战的项目。



## 0.2. 设计模式概括
三大类型设计模式，共22种
- 创建型模式：处理对象的创建过程，共5种。
  - 工厂方法模式（factory method pattern）
  - 抽象工厂模式（abstract factory pattern）
  - 建造者模式（builder pattern）
  - 单例模式（singleton pattern）
  - 原型模式（prototype pattern） 
- 结构型模式：让类和类的象进行组合以获得更大的结构，共7种。
  - 代理模式（proxy pattern）  
  - 装饰者模式（decorator pattern）
  - 适配器模式（adapter pattern）
  - 桥接模式（bridge pattern）
  - 组合模式（composite pattern）
  - 外观模式（facade pattern）
  - 享元模式（flyweight pattern）
- 行为型模式：对类或对象怎样交互和怎样分配职责进行描述，共11种。
  - 模板模式（template pattern） 
  - 命令模式（command pattern）
  - 责任链模式（chain of responsibility pattern）
  - 策略模式（strategy pattern）
  - 中介者模式（mediator pattern）
  - 观察者模式（observer pattern）
  - 备忘录模式（memento pattern）
  - 访问者模式（visitor pattern）
  - 状态模式（state pattern）
  - 解释模式（interpreter pattern）
  - 迭代模式（iterator pattern）

- 使用设计模式的最终目的：高内聚，低耦合。
- 基本原则
  - 开放封闭原则（OCP）：类的改动是通过增加代码来进行的，而不是修改源代码。
  - 依赖倒置原则（DIP: dependence inversion principle）：依赖于抽象接口，不要依赖于具体的类，即针对接口编程。
  - 迪米特原则（LOD：low of demeter）：一个对象应该对其它的对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。
    > 例如：在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现，使其它的模块不需要了解另一个模块的内部实现，这样当一个模块发生改变时，其它的模块不会受到影响。


## 0.3. 创建型 - 设计模式

### 0.3.1. 单例模式
- 参考
  - [java单例模式](https://blog.csdn.net/czqqqqq/article/details/80451880)
  - [设计模式之单例模式](https://segmentfault.com/a/1190000015950693)：segmentfault上面使用C++实现的单例模式。


- 定义：保证一个类只能生成一个唯一的实例对象，同时提供该实例访问的全局方法。
- 实现的步骤
  - 构造函数私有化，禁止他人创建
  - 提供一个全局的静态方法
  - 在类中定义一个静态指针，指向该类变量的静态变量指针
- 单例模式优点
  - 在内存中只有一个对象，节省内存空间；
  - 避免频繁的创建销毁对象，可以提高性能；
  - 避免对共享资源的多重占用，简化访问；
  - 为整个系统提供一个全局访问点。
- 注意事项
  - 在使用单例模式时，我们必须使用单例类提供的公有工厂方法得到单例对象，而不应该使用反射来创建，否则将会实例化一个新对象。此外，在多线程环境下使用单例模式时，应特别注意线程安全问题
  - 想要实现高效率的多线程安全的单例模式，应注意
    - 尽量减少同步块的作用域；
    - 尽量使用细粒度的锁


- 单线程下实现单例模式
  - 懒汉式：等到真正使用的时候才去创建实例，不用时不去主动创建
  - 饿汉式：在类加载初始化的时候就主动创建实例


- 多线程下实现单例模式
  - 多线程下，懒汉式的实现时不安全的，饿汉式方法实现是安全的。
  - Java中如何解决线程不安全的问题？
    - Java中使用 `synchronized方法`
      ```
      // 线程安全的懒汉式单例
      public class Singleton2 {
          private static Singleton2 singleton2;
          private Singleton2(){}
          // 使用 synchronized 修饰，临界资源的同步互斥访问
          public static synchronized Singleton2 getSingleton2(){
              if (singleton2 == null) {
                  singleton2 = new Singleton2();
              }
              return singleton2;
          }
      }

      // 优缺点
         1、运行效率低，因为同步块的作用域很大，锁的粒度有点粗
         2、保证了对临界资源的同步访问
      ```
    - Java中使用 `synchronized块`
      ```
      // 线程安全的懒汉式单例
      public class Singleton2 {
          private static Singleton2 singleton2;
          private Singleton2(){}
          public static Singleton2 getSingleton2(){
              synchronized(Singleton2.class){  // 使用 synchronized 块，临界资源的同步互斥访问
                  if (singleton2 == null) { 
                      singleton2 = new Singleton2();
                  }
              }
              return singleton2;
          }
      }

      // 行效率仍然比较低，事实上，和使用synchronized方法的版本相比，基本没有任何效率上的提高。
      ```
    - 使用 `内部类的懒汉式`
      ```
      // 线程安全的懒汉式单例
      public class Singleton5 {
          // 私有内部类，按需加载，用时加载，也就是延迟加载
          private static class Holder {
              private static Singleton5 singleton5 = new Singleton5();
          }
          private Singleton5() {
      
          }
          public static Singleton5 getSingleton5() {
              return Holder.singleton5;
          }

        // 效率比较高
      ```
    - 使用 `双重检测机制`
    ```
      // 线程安全的懒汉式单例
      public class Singleton3 {
      
          //使用volatile关键字防止重排序，因为 new Instance()是一个非原子操作，可能创建一个不完整的实例
          private static volatile Singleton3 singleton3;
      
          private Singleton3() {
          }
      
          public static Singleton3 getSingleton3() {
              // Double-Check idiom
              if (singleton3 == null) {
                  synchronized (Singleton3.class) {       // 1
                      // 只需在第一次创建实例时才同步
                      if (singleton3 == null) {       // 2
                          singleton3 = new Singleton3();      // 3
                      }
                  }
              }
              return singleton3;
          }
      }

      // 保证了单例，提高了效率
      // 必须使用volatile关键字修饰单例引用。目的：解决指令重排序的问题
    ``` 
  - 借助 ` ThreadLocal`
    ```
    // 线程安全的懒汉式单例
    public class Singleton4 {
    
      // ThreadLocal 线程局部变量
      private static ThreadLocal<Singleton4> threadLocal = new ThreadLocal<Singleton4>();
      private static Singleton4 singleton4 = null;

      private Singleton4(){}

      public static Singleton4 getSingleton4(){
          if (threadLocal.get() == null) {        // 第一次检查：该线程是否第一次访问
              createSingleton4();
          }
          return singleton4;
      }

      public static void createSingleton4(){
          synchronized (Singleton4.class) {
              if (singleton4 == null) {          // 第二次检查：该单例是否被创建
                  singleton4 = new Singleton4();   // 只执行一次
              }
          }
          threadLocal.set(singleton4);      // 将单例放入当前线程的局部变量中 
      }
    }

    // 作用：将临界资源线程局部化
    // 使用ThreadLocal的实现在效率上还不如双重检查锁定。
    ``` 

  几种方式实现单例模式的对比
  单例模式  | 是否线程安全 | 是否懒加载  | 是否防止反射构建
  --- | --- | --- | ---
  双重锁检测 | 是 | 是 | 否
  静态内部类 | 是 | 是 | 否
  枚举       | 是 | 否 | 是


### 0.3.2. 简单工厂模式
> 简单工厂模式(Simple Factory Pattern)：专门定义一个类（工厂类）来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

- 举例：
  简单工厂模式像一个代工厂，一个工厂可以生产多种产品。举个例子，一个饮料加工厂同时帮百事可乐和可口可乐生产，加工厂根据输入参数``Type``来生产不同的产品。

- 优点
   * 使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。
  * 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。
  
- 缺点
  * 如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的。
  * 在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况。


### 0.3.3. 工厂模式
> 工厂方法模式(Factory Method Pattern)又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。

- 举例子：工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。

- 优点
  * 用户只需要关心其所需产品对应的具体工厂是哪一个即可，不需要关心产品的创建细节，也不需要知道具体产品类的类名。
  * 当系统中加入新产品时，不需要修改抽象工厂和抽象产品提供的接口，也无须修改客户端和其他的具体工厂和具体产品，而只要添加一个具体工厂和与其对应的具体产品就可以了，符合了开闭原则。

- 缺点
  * 当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类。因此系统中类的个数将成对增加，增加了系统的复杂度。


### 0.3.4. 抽象工厂模式
> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

- 举例子：抽象工厂和工厂方法不同的地方在于，生产产品的工厂是抽象的。举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。

- 优点
  * 具体产品在应用层代码隔离，不需要关心产品细节。只需要知道自己需要的产品是属于哪个工厂的即可 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
  
- 缺点
  * 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。

- 工厂模式与抽象工厂模式的区别
  >工厂模式只能生产一个产品；而抽象工厂模式可以产生一列的产品。


### 0.3.5. 建造者模式
> 它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 优点
  * 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
  * 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
  * 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
  * 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

- 缺点
  * 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
  * 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。


### 0.3.6. 原型模式
> 原型模式（Prototype Pattern）: 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。原型模式为每个对象提供一个接口，让一个复杂的对象具有自我复制的功能，统一一套接口。

- 举例子：原型模式就像复印技术，根据原对象复印出一个新对象，并根据需求对新对象进行微调。

- 优点
  * 可以利用原型模式简化对象的创建过程，尤其是对一些创建过程繁琐，包含对象层级比较多的对象来说，使用原型模式可以节约系统资源，提高对象生成的效率。
  * 可以很方便得通过改变值来生成新的对象：有些对象之间的差别可能只在于某些值的不同；用原型模式可以快速复制出新的对象并手动修改值即可。

- 缺点
  * 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂。


## 0.4. 结构型 - 设计模式 

### **代理模式**
> 代理模式(Proxy Pattern) ：为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。

- 举例子：代理模式像一个房屋中介，买家只能通过中介来买房，代理具备被代理类的所有功能，就像房东有卖房功能，中介也具有卖房功能。此外代理实例还可以帮助被代理实例进行一些额外处理，比如中介可以帮助房东筛选优质买家的功能，帮助房东pass掉一些不符合条件的买家。还有消息队列也是该模式。

- 优点
  * 降低系统的耦合度：代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
  * 不同类型的代理可以对客户端对目标对象的访问进行不同的控制：
    * 远程代理,使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
    * 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。
    * 保护代理可以控制客户端对真实对象的使用权限。

- 缺点
  * 由于在客户端和被代理对象之间增加了代理对象，因此可能会让客户端请求的速度变慢。


### **装饰模式**
不同的类之间可以自己的组合


### **适配器**

### **桥接模式**


