<!--
 * @Author: JOhnJeep
 * @Date: 2020-05-27 10:12:26
 * @LastEditTime: 2020-06-08 08:52:53
 * @LastEditors: Please set LastEditors
 * @Description: C++基础学习笔记
-->  

<!-- TOC -->

- [1. C++基础](#1-c基础)
  - [1.1. 基本概念](#11-基本概念)
  - [1.2. class类](#12-class类)
  - [1.3. 引用（reference）](#13-引用reference)
    - [1.3.1. 普通引用](#131-普通引用)
    - [1.3.2. 常量引用](#132-常量引用)
  - [1.4. 函数](#14-函数)
    - [1.4.1. 内联函数（inline）](#141-内联函数inline)
    - [1.4.2. 函数参数](#142-函数参数)
    - [1.4.3. 模板函数（建立一个通用函数）](#143-模板函数建立一个通用函数)
  - [1.5. 命名空间（namespace）](#15-命名空间namespace)
  - [1.6. 头文件](#16-头文件)
  - [1.7. 构造函数](#17-构造函数)
    - [1.7.1. 拷贝构造（copy construction）](#171-拷贝构造copy-construction)
    - [1.7.2. 拷贝赋值（copy assignment operator）](#172-拷贝赋值copy-assignment-operator)
  - [1.8. 析构函数（destructor）](#18-析构函数destructor)
  - [1.9. new和delete](#19-new和delete)
  - [1.10. 重载（overloading）](#110-重载overloading)
  - [1.11. const](#111-const)
  - [1.12. static](#112-static)
  - [1.13. 参数传递与返回值传递](#113-参数传递与返回值传递)
  - [1.14. friend（友元）](#114-friend友元)
  - [1.15. this](#115-this)
  - [1.16. 操作运算符重载（operator overloading）](#116-操作运算符重载operator-overloading)
  - [1.17. 模板（template）](#117-模板template)
    - [1.17.1. class template](#1171-class-template)
    - [1.17.2. function template](#1172-function-template)
    - [1.17.3. vector(向量)](#1173-vector向量)

<!-- /TOC -->


# 1. C++基础
编程----写出大家风范。

## 1.1. 基本概念
- C语言中，表达式的返回值是一个数值。C++中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。
- `endl` 与 `\n` 区别：
  - endl：换行和清除缓冲区到输出屏幕上
  - \n：仅仅只是换行
- float：有效数字是6~7位
- double：有效数字是15位
- char：8个bit，占一个字节空间
- 取模场景：
  - 取一个数的个位数
  - 多少天是一个月的第几天 
- `<<`左移运算符：右侧空位补0
- `>>` 右移运算符：左侧空位补符号位，符号位正数部0，符号位为负数补1
- switch语句后的表达式只能为整型或字符类型
- break语句：执行循环体后，调出循环。可用于switch结构或者循环结构
- continue：只能用于循环结构，调出循环
- 计算数组大小：对基本类型（不包括String类型）：`sizeof(array_var) / sizeof(array_type)`
  >   sizeof(nums) / sizeof(int) 
- 指针：
  - `int *ptr`  整型指针，结果是一个值
  - `int *ptr  int*`：指向整型的指针，结果是一个地址
  - 所有的指针都要初始化
  - `void* `指针存放一个内存地址，地址的内容是什么类型不能确定 

## 1.2. class类
- class without pointer members：类中的成员不带有指针。
- class with pointer members：class类中的成员带有指针。


## 1.3. 引用（reference）
### 1.3.1. 普通引用
- 给对象起了一个别名，使用 `&` 符号表示
- 单独定义的引用时，必须要 `初始化`。
- 引用作为函数的参数声明时，`不` 需要进行初始化。
- 效率比指针高
- 直接传递对象，不是把复制对象
- 函数内部的引用参数值可能会改变，一般需要加const解决
- 不要返回局部变量的引用，全局变量和静态变量可以作为返回值的引用。 
- C++编译器在编译时使用一个常量指针作为引用的内部实现。因此，引用占用的内存空间大小与指针占用空间大小相同。
  > type& name <==> type* const name
- 从使用者的角度，引用类似是一个别名，没有自己的内存空间，这是因为C++为了实用性，隐藏了相关细节。实质上引用有自己的内存空间。
- `引用` 作为 `左值`时，返回的是变量的本身，是变量而不是值（value）。变量只能是全局变量或静态变量，不能是局部变量，否则会出现 `Segmentation fault`。
- 函数的返回值作为一个 `左值`时，应该返回的是一个引用`(reference)`。
- 指针的引用 
  - 格式 `const int* &a`
  - 指针的引用做函数参数
  - 函数二级指针作为输出变量


### 1.3.2. 常量引用
- 让变量的引用拥有只读的属性。
  ```
  int x = 10;
  const int &y = x;   // 不能通过y去修改x的值 
  ```
- 初始化
  - 用变量初始化常引用。`int x = 10; const int &y = x;`
  - 用自变量初始化常引用。`const int &a = 100;` 
- 使用常量引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为当前分配空间的别名。


## 1.4. 函数
- C++对函数的检查更严格
- C++支持bool类型：C++中的bool，只占 1 个字节；java中使用 `boolean`；采用 `boolalpha`显示True或False；
### 1.4.1. 内联函数（inline）
- 函数定义时，加 `inline` 关键字 `inline void func(){}`
- 内联函数与函数体的实现在一起，不需额外的声明。 
- C++编译器直接将函数体插入函数调用的地方。
- 什么时候用 `inline`
  - 函数在class类里面定义 
- 限制
  - 函数体不能过大。
  - 函数声明必须在调用之前声明。
  - 不能对函数进行取值地址操作。 
  - 不能存在任何形式的循环语句（for、while）。
  - 内联函数省去了普通函数调用时的压栈、跳转、返回操作。


### 1.4.2. 函数参数
- 默认参数
  - 函数的参数有一个默认的值。
  - 函数带有参数列表，参数列表的右边必须有默认的值，左边可以不给默认参数赋值。
- 占位参数
 - 只有函数类型声明，没有函数变量声明。`int func(int a, int b, int)`


### 1.4.3. 模板函数（建立一个通用函数）
  - 函数定义时不指定具体的数据类型
  - 函数调用时，根据实际参数反推数据类型，即类型的参数化
  

## 1.5. 命名空间（namespace）
- C中的命名空间
  - 只有一个全局的作用域，所有的全局标识符共用一个作用域。同名的标识符之间会发生冲突。
- C++的命名空间
  - 将全局的作用域分成不同的部分，不同命名空间的标识符可以同名而不会发生冲突。
  - 全局作用域也叫默认命名空间
  - 命名空间之间可以相互嵌套

- 语法
```
// 使用标准库中封装的内容。标准库中定义的所有名字都在命名空间 std 中
using namespace std
{
  .....
}
```
- `::` 作用域运算符
  ```
  std::out 从标准库中输出读取的内容，即编译器从操作符左侧名字的作用域中去寻找右侧的名字。
  ```
- 一般有三种方式去实现命名空间
  - 全部打开标准库中的内容。`using namespace std;`
  - 只打开标准库的部分内容。
    ```
    using std::cout;

    int main()
    {
      cout << ...;
      std::cin << ...;
      
      return 0;
    }
    ```
  - 在使用的时候根据需要打开
    ```
    int main()
    {
      std::cout << ...;
      std::cin  << ...;
     
      return 0;
    }


## 1.6. 头文件
- 头文件采用防御式声明 
    ```
    #ifndef __TEST_H
    #define __TEST_H
      ...
      
    #endif
    ```


## 1.7. 构造函数
- 为什么要用构造函数？
  - 被用来创建类  
  - 初始化对象的数据
  - 类对象被创建时，编译器为对象(object)分配内存空间，并自动调用构造函数，完成成员的初始化 
- 构造函数的 `函数名称` 与 `类的名称` 一样。
- **函数没有返回值**
- 函数参数有默认值。
  - 创建的对象有默认值时，应传入创建的对象默认值；
  - 创建的对象没有默认值时，应传入的默认值为 `0`；
- 构造函数是一个成员函数，有一个 `this pointer`
- 应在构造函数里面的第一行设置初始列表 `initialize list`，即初始化。
  - 语法：`: re(r), im(i)` 将变量设置为：`re=r, im=i`
- 构造函数的访问属性可以放在 `private` 中。在单例模式（singleton）中就采用这种用法。
- 构造函数分类
  - 无参构造：一般为栈内存空间，自动释放内存空间。调用时不用 `加括号`。
  - 带参数构造(重载构造)
    - 一般为堆内存空间，需要使用delete释放内存空间；使用 `new` 关键字创建空间
    - 一般需要初始化构造的参数
  - 拷贝构造
    ```
    // 声明一个类
    class String()
    {
      private:
        ...
      public:
        ...
    }
    // 实例化一个对象
    String st_one;

    // 拷贝构造
    String st_two = st_one;   // 方法一：= 是拷贝一个对象不是赋值运算

    String st_three(st_one)   // 方法二：初始化拷贝构造

    函数的返回值是一个复杂的类型，会返回一个新的匿名对象。
    匿名对象什么时候留下？什么时候被析构？
      1、用匿名对象初始化一个同类型的对象，则匿名对象转化为有名字的对象。
      2、用匿名对象赋值给另外一个对象，则匿名对象被析构。
    ```
  - 默认构造函数
    - 默认无参数构造：当类中没有定义构造函数时，C++编译器会默认提供一个无参数构造函数，构造函数的函数体为空。
    - 默认拷贝构造：当类中没有定义拷贝构造函数时，C++编译器会默认提供一个拷贝构造函数，简单的进行成员变量的值拷贝操作。
- `构造函数` 与 `析构函数` 在类中声明了 ，必须要通过类的方法去实现，即声明了不、必须要用。


### 1.7.1. 拷贝构造（copy construction）
- 浅拷贝
  ```
  没有做任何的说明，C++编译默认使用的是浅拷贝。
  
  People obj_2 = obj_1;   将obj_1对象的内容拷贝到obj_2对象中，不是拷贝的指针。
  ```
- 深拷贝：copy content 


### 1.7.2. 拷贝赋值（copy assignment operator） 
  ```
  将s1拷贝赋值给s2，分3步：
  // 在拷贝之前需要进行自我赋值检测。即自己把值赋给自己，保证在执行第二步操作时，指针有指向的位置。
  if (this == str)
  {
    return *this
  }

  1、将s2自己清空
  2、分配 s2大小的内存空间存放s1
  3、执行拷贝动作
  ``` 

## 1.8. 析构函数（destructor）
  - 表示：在类名称之前加 `~`。例如：`string::~string()` 
  - 位置：在class类的之外去定义。
  - 作用：在类死亡之前的前一刻调用，用于清除类中的内容（比如：释放内存）


## 1.9. new和delete
- windows 下内存显示总是 `16` 的倍数，不是 16 的倍数，则填充为最靠近 16 的倍数的大小。 
- `new` 动态分配内存 
  - 先分配空间，再调用构造函数 
  - new创建一维动态数组
    ```
    // 数组类型
    typeName* pointer_name = new typeName[num_elements];
    例如：int *p = new int[10];

    // 普通类型
    typeName* pointer_name = new typeName 
    例如：int *p = new int;
    ```  
  - 创建二维数组
    ```
    格式：typeName (*ptr)[col_num] = new typeName[row_num][col_num];
    例子：int (*ptr)[2] = new int[4][2];
    ```
  - 创建对象
    ```
    class Airplane
    {
      ...
    }

    Airplane ap = new Airplane();
    ```

- `delete` 释放内存，与new配对使用 
  - 先调用析构函数，再释放空间  
  - 注意
    - 不要尝试释放已经释放的内存块 
    - 不是用new分配的动态内存空间，不能用delete释放

- 注意：
  - 采用 `array new` 的方式创建一块内存空间，则一定要采用 ` array delete` 方式去释放内存，否则在涉及指针的时候可能会导致内存泄漏。泄漏的并不是整个分配的内存空间，而是分配的空间中数组没有被释放的部分。
  - 不配对地使用new和delete，将发生内存泄漏（memory leak），被分配的内存再也无法使用了，如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。

- 静态链编：数组是在编译时加入到程序中，必须在编写程序时指定数组的长度。
- 动态链编：程序在运行阶段是否需要创建数组，在程序运行时选择数组的长度


## 1.10. 重载（overloading）
- 常常发生在构造函数中。
- 函数名称相同，函数参数不同（参数个数，参数类型）。
- 函数的返回值不是函数重载判断的标准。
- 编译器在编译时，根据函数的 `参数列表` 进行重命名。


## 1.11. const
- C语言中，`const` 是只读的变量，有自己的存储空间。
- C++中，`const` 可能分配存储空间，也可能不分配存储空间。
  - 当 `const` 作为全局变量，并在其它的文件中到调用时，会分配存储空间。
  - 采用 `&` 地址运算符去取 `const` 变量的地址时，会分配存储空间。
- 加 `const` 后，不会改变数据的内容，不加`const`，则会改变数据的内容，一般数据的内容定义在 `private`中。
- 在类中采用 `const`修饰函数，需要在类调用时必须加 `const`
  ```
  声明：
  double real() const
  {
      return re;
  }

  调用：
  const complex fx(1, 2);
  ```
- `const` 常量由 `编译器`处理的，提供作用域检查和类型检查。而 `宏定义（#define）` 仅仅只是单纯的文本替换，在 `预处理` 阶段处理的。


## 1.12. static
- 一个类的成员变量为静态成员变量（即含有`static` 关键字）时，这个类中无论有多少个对象被创建，这些对象都共享这个 `static` 成员。
- 静态成员函数中不能使用非静态成员变量和非静态成员函数。
- C++中的成员函数和成员变量是分开存储的。

- 继承中使用 `static`，需要在类的外部进行初始化，并且C++编译器在外部初始化的同时还给变量分配内存空间，只有在使用时才分配内存空间，不调用不分配内存空间。


## 1.13. 参数传递与返回值传递
- pass by value 和 pass by reference
  - 传值是将整个的数据传递给调用者
  - 传引用本质是 `传指针`。
    - 采用一个 `&` 符号表示。
    - 希望调用者对传递的数据不能进行修改，在数据前加 `const` 限制。
- 参数传递时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。`传引用` 的速度比 `传值` 速度快。
- 函数返回 `值传递` 时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。 


- 什么情况下不能使用 `引用传递（reference）`？
  - 当一个函数参数的变量为局部变量时，不能使用传引用。因为变量在函数结束时，变量就被销毁了，不存在，若再传递引用，调用者则不能得到值，会出错。


## 1.14. friend（友元）
  - 在一个类中使用 friend，当前类中未定义的函数可以去拿当前类中的数据。
  - 同一个 class 中的各个 object 互为友元。
    ```
    函数定义：
    int func(const complex& param)
    {
        return value;
    }

    声明对象:
    complex c1;
    complex c2;
    c2.func(c2);   // 采用友元方式实现，通过对象参数访问私有成员数据
    ```
  - 在类（class）的外部函数访问类的私有成员，需要将函数设置为类的 `friend` 属性。

- 友元类
  - 若B类是A类的友元类，则B类的所有成员函数都是A类的友元函数。
  - 通常是为设计一种数据操作或类之间传递消息的辅助类。


- 友元函数
  - 为什么要设计友元类？


## 1.15. this
- 什么叫成员函数：在类（class）中声明的函数。
- 什么叫非成员函数：没有在类（class）中声明的函数，非成员函数也叫全局函数。
- 哪个对象调用非静态成员函数，`this` 就指向哪个对象。 
- 静态成员函数中不包含 `this` 指针，非静态成员函数中包含 `this` 指针
- 成员函数中 `const` 修饰的是谁？
  ```
  class TT
  {
  private:
    ......
  public:
    void func(int a, int b) const
    {}
  }

  // 由C++面向对象模型知，上面的函数等价于
  void func(TT *this, int a, int b) const
  {}
  
  // const修饰的是this指针指向的内存空间。
  ```

- 类名后直接加括号，不创建一个对象，代表一个临时对象（temp object）。
    ```
    //声明类
    class complex
    {
        public:
            // 主要放置函数
            ........

        private:
            // 定义数据
            ........
    }

    // 调用临时对象
    complex();
    ```


## 1.16. 操作运算符重载（operator overloading）
- 为什么要操作符重载？
  > 普通的运算规则不能满足复杂的数据类型，像 `类（class）`数据类型，需要编程人员自定义运算规则去实现。
- 操作运算符重载的本质是个 `函数`。


- 操作符重载有两种实现的方式
  - 非成员函数方式，即全局函数（全域）的方式。
    - 通常与 `friend` 友元函数结合在一起使用。
    - 应用场景：重载不同类之间的操作符。例如，重载 `<<` 和 `>>`，编程人员自定义的类与C++编译器中 `ostream` 或 `istream` 类中的数据进行操作符重载。
  - 成员函数方式。
    - 函数的参数有一个隐藏的 `this` pointer，可以在函数里面去调用。


- 分析重载的步骤？
  - 确定函数名称
  - 确定函数参数
  - 根据业务，确定函数的返回值类型（是返回引用还是返回值？）以及函数体的实现。  




## 1.17. 模板（template）
### 1.17.1. class template
- `template<typename T>`


### 1.17.2. function template
- `template<class T>`
- 编译器会做 `引数推导`


### 1.17.3. vector(向量)
- 模板：`template <typename T> void Show(T arrNum[], int len);`
- 动态数组，在运行阶段执行。
- 操作接口
  - `size()`: 返回容器中元素的个数
  - `get(r)`:获取秩（索引）为r的元素
  - `put(r, e)`:用e替换秩为r元素的数值
  - `insert(r, e)`:向秩为r的元素处插入数值e，后面元素依次后移
  - `remove(r)`:初除秩为r癿元素，迒回诠元素中原存放癿对象
  - `disordered()`:判断所有元素是否已按升序序排列
  - `sort()`:调整各元素癿位置，使按照升序序排列
  - `deduplicate()`:删除重复元素   ---向量
  - `uniquify()`:删除重复元素 ---有序向量
  - `traverse()`:遍历向量幵统一处理所有元素，处理斱法由函数对象指定
  - `empty()`:判断容器是否为空
  - `at(index)`:返回索引为index的元素
  - `erase(p)`:删除p位置处的元素
  - `erase(beg, end)`:删除区间`[beg, end)`的数据
  - `pop_back()`:删除最后一个元素
  - `push_back()`:在容器末尾插入一个元素
  - `begin(), end()`:返回容器收尾元素的迭代器
  - `clear()`:移除容器中所有的元素
  - `swap()`:交换两个容器的内容


****
作业
-fexec-charset=GBK -finput-charset=UTF-8
- string
- 实现复合、继承、委托三种方式
