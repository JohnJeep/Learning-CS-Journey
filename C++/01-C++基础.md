<!--
 * @Author: your name
 * @Date: 2020-05-27 10:12:26
 * @LastEditTime: 2020-06-01 08:59:33
 * @LastEditors: your name
 * @Description: C++基础学习笔记
-->  

<!-- TOC -->

- [1. C++基础](#1-c基础)
  - [1.1. 基本概念](#11-基本概念)
  - [1.2. 引用（reference）](#12-引用reference)
    - [1.2.1. 普通引用](#121-普通引用)
    - [1.2.2. 常量引用](#122-常量引用)
  - [1.3. 函数](#13-函数)
    - [1.3.1. 内联函数（inline）](#131-内联函数inline)
    - [1.3.2. 函数参数](#132-函数参数)
    - [1.3.3. 模板函数（建立一个通用函数）](#133-模板函数建立一个通用函数)
  - [1.4. class without poniter members](#14-class-without-poniter-members)
    - [1.4.1. 命名空间（namespace）](#141-命名空间namespace)
    - [1.4.2. 头文件](#142-头文件)
    - [1.4.3. 构造函数](#143-构造函数)
    - [1.4.4. 重载（overloading）](#144-重载overloading)
    - [1.4.5. const](#145-const)
    - [1.4.6. 参数传递与返回值传递](#146-参数传递与返回值传递)
    - [1.4.7. friend（友元）](#147-friend友元)
    - [1.4.8. 操作运算符重载（operator overloading） this](#148-操作运算符重载operator-overloading-this)
  - [1.5. class with poniter members(class 类中带有指针成员)](#15-class-with-poniter-membersclass-类中带有指针成员)
    - [1.5.1. 析构函数（destructor）](#151-析构函数destructor)
    - [1.5.2. 拷贝构造（copy construction）](#152-拷贝构造copy-construction)
    - [1.5.3. 拷贝赋值（copy assignment operator）](#153-拷贝赋值copy-assignment-operator)
  - [1.6. new和delete](#16-new和delete)
  - [1.7. 模板（template）](#17-模板template)
    - [1.7.1. class template](#171-class-template)
    - [1.7.2. function template](#172-function-template)
    - [1.7.3. vector(向量)](#173-vector向量)
  - [1.8. 面向对象编程（OOP）](#18-面向对象编程oop)
    - [1.8.1. 复合（composition）](#181-复合composition)
    - [1.8.2. 委托（delegation）](#182-委托delegation)
    - [1.8.3. 继承（Inheritance）](#183-继承inheritance)
  - [封装](#封装)

<!-- /TOC -->


# 1. C++基础
编程----写出大家风范。

## 1.1. 基本概念
- C++对函数的检查更严格
- C++支持bool类型：C++中使用bool，只占 1个字节；java中使用 `boolean`；使用 `boolalpha`显示True或False；
- C语言中，表达式的返回值是一个数值。C++中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。
- `endl` 与 `\n` 区别：
  - endl：换行和清除缓冲区到输出屏幕上
  - \n：仅仅只是换行
- float：有效数字是6~7位
- double：有效数字是15位
- char：8个bit，占一个字节空间
- 取模场景：
  - 取一个数的个位数
  - 多少天是一个月的第几天 
- `<<`左移运算符：右侧空位补0
- `>>` 右移运算符：左侧空位补符号位，符号位正数部0，符号位为负数补1
- switch语句后的表达式只能为整型或字符类型
- break语句：执行循环体后，调出循环。可用于switch结构或者循环结构
- continue：只能用于循环结构，调出循环
- 计算数组大小：对基本类型（不包括String类型）：`sizeof(array_var) / sizeof(array_type)`
  >   sizeof(nums) / sizeof(int) 
- 指针：
  - `int *ptr`  整型指针，结果是一个值
  - `int* ptr  int*`：指向整型的指针，结果是一个地址
  - 所有的指针都要初始化
  - `void* `指针存放一个内存地址，地址的内容是什么类型不能确定 


## 1.2. 引用（reference）
### 1.2.1. 普通引用
- 给对象起了一个别名，使用 `&` 符号表示
- 单独定义的引用时，必须要 `初始化`。
- 引用作为函数的参数声明时，`不` 需要进行初始化。
- 效率比指针高
- 直接传递对象，不是把复制对象
- 函数内部的引用参数值可能会改变，一般需要加const解决
- 不要返回局部变量的引用，全局变量和静态变量可以作为返回值的引用。 
- C++编译器在编译时使用一个常量指针作为引用的内部实现。因此，引用占用的内存空间大小与指针占用空间大小相同。
  > type& name <==> type* const name
- 从使用者的角度，引用类似是一个别名，没有自己的内存空间，这是因为C++为了实用性，隐藏了相关细节。实质上引用有自己的内存空间。
- `引用` 作为 `左值`时，返回的是变量的本身，是变量而不是值（value）。变量只能是全局变量或静态变量，不能是局部变量，否则会出现 `Segmentation fault`。
- 指针的引用 
  - 格式 `const int* &a`
  - 指针的引用做函数参数
  - 函数二级指针作为输出变量


### 1.2.2. 常量引用
- 让变量的引用拥有只读的属性。
  ```
  int x = 10;
  const int &y = x;   // 不能通过y去修改x的值 
  ```
- 初始化
  - 用变量初始化常引用。`int x = 10; const int &y = x;`
  - 用自变量初始化常引用。`const int &a = 100;` 
- 使用常量引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为当前分配空间的别名。

## 1.3. 函数
### 1.3.1. 内联函数（inline）
- 函数定义时，加 `inline` 关键字 `inline void func(){}`
- 内联函数与函数体的实现在一起，不需额外的声明。 
- C++编译器直接将函数体插入函数调用的地方。
- 限制
  - 函数体不能过大。
  - 函数声明必须在调用之前声明。
  - 不能对函数进行取值地址操作。 
  - 不能存在任何形式的循环语句（for、while）。
  - 内联函数省去了普通函数调用时的压栈、跳转、返回操作。


### 1.3.2. 函数参数
- 默认参数
  - 函数的参数有一个默认的值。
  - 函数带有参数列表，参数列表的右边必须有默认的值，左边可以不给默认参数赋值。
- 占位参数
 - 只有函数类型声明，没有函数变量声明。`int func(int a, int b, int)`


### 1.3.3. 模板函数（建立一个通用函数）
  - 函数定义时不指定具体的数据类型
  - 函数调用时，根据实际参数反推数据类型，即类型的参数化
  



## 1.4. class without poniter members

### 1.4.1. 命名空间（namespace）
- C中的命名空间
  - 只有一个全局的作用域，所有的全局标识符共用一个作用域。同名的标识符之间会发生冲突。
- C++的命名空间
  - 将全局的作用域分成不同的部分，不同命名空间的标识符可以同名而不会发生冲突。
  - 全局作用域也叫默认命名空间
  - 命名空间之间可以相互嵌套

- 语法
```
// 使用标准库中封装的内容。标准库中定义的所有名字都在命名空间 std 中
using namespace std
{
  .....
}
```
- `::` 作用域运算符
  ```
  std::out 从标准库中输出读取的内容，即编译器从操作符左侧名字的作用域中去寻找右侧的名字。
  ```
- 一般有三种方式去实现命名空间
  - 全部打开标准库中的内容。`using namespace std;`
  - 只打开标准库的部分内容。
    ```
    using std::cout;

    int main()
    {
      cout << ...;
      std::cin << ...;
      
      return 0;
    }
    ```
  - 在使用的时候根据需要打开
    ```
    int main()
    {
      std::cout << ...;
      std::cin  << ...;
     
      return 0;
    }


### 1.4.2. 头文件
- 头文件采用防御式声明 
    ```
    #ifndef __TEST_H
    #define __TEST_H

    #endif
    ```
- 什么时候用 `inline`
  - 函数在class类里面定义 


### 1.4.3. 构造函数
- 为什么要用构造函数？
  - 被用来创建类  
  - 初始化对象的数据
  - 类对象被创建时，编译器为对象(object)分配内存空间，并自动调用构造函数，完成成员的初始化 
- 构造函数的 `函数名称` 与 `类的名称` 一样
- **函数没有返回值**
- 函数参数有默认值。
  - 创建的对象有默认值时，应传入创建的对象默认值；
  - 创建的对象没有默认值时，应传入的默认值为 `0`；
- 构造函数是一个成员函数，有一个 `this pointer`
- 应在构造函数里面的第一行设置初始列 `initialize list`，即初始化。
  - 语法：`: re(r), im(i)` 将变量设置为：`re=r, im=i`
- 构造函数可以放在 `private` 中。在单例模式（singleton）中就采用这种用法。
- 构造函数分类
  - 无参构造：一般为栈内存空间，自动释放内存空间
  - 一般构造(重载构造)：一般为堆内存空间，需要使用delete释放内存空间；使用 `new` 关键字创建空间
  - 拷贝构造


### 1.4.4. 重载（overloading）
- 常常发生在构造函数中。
- 函数名称相同，函数参数不同（参数个数，参数类型）。
- 函数的返回值不是函数重载判断的标准。
- 编译器在编译时，根据函数的 `参数列表` 进行重命名。


### 1.4.5. const
- C语言中，`const` 是只读的变量，有自己的存储空间。
- C++中，`const` 可能分配存储空间，也可能不分配存储空间。
  - 当 `const` 作为全局变量，并在其它的文件中到调用时，会分配存储空间。
  - 采用 `&` 地址运算符去取 `const` 变量的地址时，会分配存储空间。
- 加 `const` 后，不会改变数据的内容，不加`const`，则会改变数据的内容，一般数据的内容定义在 `private`中。
- 在类中采用 `const`修饰函数，需要在类调用时必须加 `const`
  ```
  声明：
  double real() const
  {
      return re;
  }

  调用：
  const complex fx(1, 2);
  ```

- `const` 常量由 `编译器`处理的，提供作用域检查和类型检查。而 `宏定义（#define）` 仅仅只是单纯的文本替换，在 `预处理` 阶段处理的。


### 1.4.6. 参数传递与返回值传递
- pass by value 和 pass by reference
  - 传值是将整个的数据传递给调用者
  - 传引用本质是传指针。
    - 采用一个 `&` 符号表示。
    - 希望调用者对传递的数据不能进行修改，在数据前加 `const` 限制。
- 参数传递时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。`传引用` 的速度比 `传值` 速度快。
- 函数返回值传递时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。 
  
- 什么情况下不能使用引用传递（reference）？
  - 当一个函数参数的变量为局部变量时，不能使用传引用。因为变量在函数结束时，变量就被销毁了，不存在，若再传递引用，调用者则不能得到值，会出错。


### 1.4.7. friend（友元）
  - 在一个类中使用 friend，当前类中未定义的函数可以去拿当前类中的数据。
  - 同一个 class 中的各个 object 互为友元。
    ```
    函数定义：
    int func(const complex& param)
    {
        return value;
    }

    声明对象:
    complex c1;
    complex c2;
    c2.func(c2);      // 采用友元方式实现
    ```


### 1.4.8. 操作运算符重载（operator overloading） this
- 操作符重载有两种实现的方式
  - 非成员函数方式，即全局（域）的方式。函数名称没有 `class` 名称
  - 成员函数方式。
    - 函数的参数有一个隐藏的 `this` pointer，可以在函数里面去调用。


- 成员函数
  - 谁调用，`this` 就指向谁 
  - 一般在public中声明的函数。


- 类名后直接加括号，不创建一个对象，代表一个临时对象（temp object）。
    ```
    //声明类
    class complex
    {
        public:
            // 主要放置函数
            ........

        private:
            // 定义数据
            ........
    }

    // 调用临时对象
    complex();
    ```


## 1.5. class with poniter members(class 类中带有指针成员)
### 1.5.1. 析构函数（destructor）
  - 表示：在类名称之前加 `~`。例如：`string::~string()` 
  - 位置：在class类的之外去定义。
  - 作用：在类死亡之前的前一刻调用，用于清除类中的内容（比如：释放内存）


### 1.5.2. 拷贝构造（copy construction）
  - 浅拷贝：copy pointer
  - 深拷贝：copy content 


### 1.5.3. 拷贝赋值（copy assignment operator） 
  ```
  将s1拷贝赋值给s2，分3步：
  // 在拷贝之前需要进行自我赋值检测。即自己把值赋给自己，保证在执行第二步操作时，指针有指向的位置。
  if (this == str)
  {
    return *this
  }

  1、将s2自己清空
  2、分配 s2大小的内存空间存放s1
  3、执行拷贝动作
  ``` 


## 1.6. new和delete
- windows 下内存显示总是 `16` 的倍数，不是 16 的倍数，则填充为最靠近 16 的倍数的大小。 
- `new` 动态分配内存 
  - 先分配空间，再调用构造函数 
  - new创建一维动态数组
    - 格式1：`typeName* pointer_name = new typeName[num_elements];`  
    - 格式2：`typeName* pointer_name = new typeName `
  - 创建二维数组
      - 格式：`typeName (*ptr)[col_num] = new typeName[row_num][col_num];`
      - 例子：`int (*ptr)[2] = new int[4][2];`

- `delete` 释放内存，与new配对使用 
  - 先调用析构函数，再释放空间  
  - 注意
    - 不要尝试释放已经释放的内存块 
    - 不是用new分配的动态内存空间，不能用delete释放

- 注意：
  - 采用 `array new` 的方式创建一块内存空间，则一定要采用 ` array delete` 方式去释放内存，否则在涉及指针的可能会导致内存泄漏。泄漏的并不是整个分配的内存空间，而是分配的空间中数组没有被释放的部分。
  - 不配对地使用new和delete，将发生内存泄漏（memory leak），被分配的内存再也无法使用了，如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。

- 静态链编：数组是在编译时加入到程序中，必须在编写程序时指定数组的长度。
- 动态链编：程序在运行阶段是否需要创建数组，在程序运行时选择数组的长度


## 1.7. 模板（template）
### 1.7.1. class template
- `template<typename T>`


### 1.7.2. function template
- `template<class T>`
- 编译器会做 `引数推导`


### 1.7.3. vector(向量)
- 模板：`template <typename T> void Show(T arrNum[], int len);`
- 动态数组，在运行阶段执行。
- 操作接口
  - `size()`: 返回容器中元素的个数
  - `get(r)`:获取秩（索引）为r的元素
  - `put(r, e)`:用e替换秩为r元素的数值
  - `insert(r, e)`:向秩为r的元素处插入数值e，后面元素依次后移
  - `remove(r)`:初除秩为r癿元素，迒回诠元素中原存放癿对象
  - `disordered()`:判断所有元素是否已按升序序排列
  - `sort()`:调整各元素癿位置，使按照升序序排列
  - `deduplicate()`:删除重复元素   ---向量
  - `uniquify()`:删除重复元素 ---有序向量
  - `traverse()`:遍历向量幵统一处理所有元素，处理斱法由函数对象指定
  - `empty()`:判断容器是否为空
  - `at(index)`:返回索引为index的元素
  - `erase(p)`:删除p位置处的元素
  - `erase(beg, end)`:删除区间`[beg, end)`的数据
  - `pop_back()`:删除最后一个元素
  - `push_back()`:在容器末尾插入一个元素
  - `begin(), end()`:返回容器收尾元素的迭代器
  - `clear()`:移除容器中所有的元素
  - `swap()`:交换两个容器的内容


## 1.8. 面向对象编程（OOP）
- 静态对象（static object）：在作用域（scope）结束后，生命周期还存在，即没有结束，一直到整个程序结束了，它的生命周期也就结束了。
  - 静态的函数没有 `this` pointer，只能去处理静态的数据
    ```
    如何去调用？ 
    1、使用 object 调用。Account a.state(10);
    2、通过 class name 来调用。Account::state(10);
    ```
- 全局对象（global object）：整个程序结束了，它的生命周期也就结束了。
- 头文件名包含在尖括号 `<>` 中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号 `""` 中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）
- 类的声明和实现时分开的。
  - `.h` 文件只作类的声明
  - `.cpp` 文件进行类的实现 


### 1.8.1. 复合（composition）


### 1.8.2. 委托（delegation）
- 两个类之间通过指针相连


### 1.8.3. 继承（Inheritance）
- 三种继承：public、private、protect
- 内存角度探讨
  - 构造：由内而外。先调用base(父类)的默认构造函数，然后才执行自己。
  - 析造：由外而内。先执行自己，然后再调用 base(父类)的析构函数。

- 数据的继承：继承的是父类内存中的数据。
- 函数的继承：继承的是父类的调用权利。

- 继承与虚函数（virtual function）的结合
  - non-virtual: 不希望子类（derived）重写
  - virtual: 希望子类重写（override）父类，父类已有默认值
  - pure-virtual: 子类（derived）中必须重写(override)父类，父类没有默认值。

- 在使用框架结构去设计程序的时候，常常使用 `Template Method` 设计模式去实现。

## 封装
- 封装了成员数据和常用函数
- 封装了属性和方法。
- `public`  修饰类的成员变量和函数，既能在类的内部使用又能在类的外部使用
- `private` 修饰类的成员变量和函数，只能在类的内部使用，不能在类的外部使用
- `protect` 修饰类的成员变量和函数，只能在类的内部使用，不能在类的外部使用，可以用在继承中。





****
作业
- string
- 实现复合、继承、委托三种方式
- 面向对象实现判断点在圆外还是在圆内？

