<!--
 * @Author: JohnJeep
 * @Date: 2020-05-27 10:12:26
 * @LastEditTime: 2020-07-11 09:39:49
 * @LastEditors: Please set LastEditors
 * @Description: C++基础学习笔记
--> 

<!-- TOC -->

- [1. C++基础](#1-c基础)
  - [1.1. 基本概念](#11-基本概念)
  - [1.2. class类](#12-class类)
  - [1.3. 引用（reference）](#13-引用reference)
    - [1.3.1. 普通引用](#131-普通引用)
    - [1.3.2. 常量引用](#132-常量引用)
  - [1.4. 函数](#14-函数)
    - [1.4.1. 内联函数（inline）](#141-内联函数inline)
    - [1.4.2. 函数参数](#142-函数参数)
    - [1.4.3. 模板函数（建立一个通用函数）](#143-模板函数建立一个通用函数)
  - [1.5. 命名空间（namespace）](#15-命名空间namespace)
  - [1.6. 头文件](#16-头文件)
  - [1.7. 构造函数](#17-构造函数)
    - [1.7.1. 拷贝构造（copy construction）](#171-拷贝构造copy-construction)
  - [1.8. 析构函数（destructor）](#18-析构函数destructor)
  - [1.9. new和delete](#19-new和delete)
  - [1.10. 重载（overloading）](#110-重载overloading)
  - [1.11. 重写（overwrite）](#111-重写overwrite)
  - [1.12. const](#112-const)
  - [1.13. static](#113-static)
  - [1.14. 参数传递与返回值传递](#114-参数传递与返回值传递)
  - [1.15. friend（友元）](#115-friend友元)
  - [1.16. this](#116-this)
  - [1.17. 操作运算符重载（operator overloading）](#117-操作运算符重载operator-overloading)
  - [1.18. `.h`与 `.hpp` 文件区别](#118-h与-hpp-文件区别)

<!-- /TOC -->

# 1. C++基础
编程----写出大家风范。

## 1.1. 基本概念
- C语言中，表达式的返回值是一个数值。C++中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。
- `endl` 与 `\n` 区别：
  - endl：换行和清除缓冲区到输出屏幕上
  - \n：仅仅只是换行
- float：有效数字是6~7位
- double：有效数字是15位
- char：8个bit，占一个字节空间
- 取模场景：
  - 取一个数的个位数
  - 多少天是一个月的第几天 
- `<<`左移运算符：右侧空位补0
- `>>` 右移运算符：左侧空位补符号位，符号位正数部0，符号位为负数补1
- switch语句后的表达式只能为整型或字符类型
- break语句：执行循环体后，调出循环。可用于switch结构或者循环结构
- continue：只能用于循环结构，调出循环
- 计算数组大小：对基本类型（不包括String类型）：`sizeof(array_var) / sizeof(array_type)`
  >   sizeof(nums) / sizeof(int) 
- 指针：
  - `int *ptr`  整型指针，结果是一个值
  - `int *ptr  int*`：指向整型的指针，结果是一个地址
  - 所有的指针都要初始化
  - `void* `指针存放一个内存地址，地址的内容是什么类型不能确定 

## 1.2. class类
- class without pointer members：类中的成员不带有指针。
- class with pointer members：class类中的成员带有指针。


## 1.3. 引用（reference）
### 1.3.1. 普通引用
- 给对象起了一个别名，使用 `&` 符号表示
- 单独定义的引用时，必须要 `初始化`。
- 引用作为函数的参数声明时，`不` 需要进行初始化。
- 效率比指针高
- 直接传递对象，不是把复制对象
- 函数内部的引用参数值可能会改变，一般需要加const解决
- 不要返回局部变量的引用，全局变量和静态变量可以作为返回值的引用。 
- C++编译器在编译时使用一个常量指针作为引用的内部实现。因此，引用占用的内存空间大小与指针占用空间大小相同。
  > type& name <==> type* const name
- 从使用者的角度，引用类似是一个别名，没有自己的内存空间，这是因为C++为了实用性，隐藏了相关细节。实质上引用有自己的内存空间。
- `引用` 作为 `左值`时，返回的是变量的本身，是变量而不是值（value）。变量只能是全局变量或静态变量，不能是局部变量，否则会出现 `Segmentation fault`。
- 函数的返回值作为一个 `左值`时，应该返回的是一个引用`(reference)`。
- 指针的引用 
  - 格式 `const int* &a`
  - 指针的引用做函数参数
  - 函数二级指针作为输出变量


### 1.3.2. 常量引用
- 让变量的引用拥有只读的属性。
  ```
  int x = 10;
  const int &y = x;   // 不能通过y去修改x的值 
  ```
- 初始化
  - 用变量初始化常引用。`int x = 10; const int &y = x;`
  - 用自变量初始化常引用。`const int &a = 100;` 
- 使用常量引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为当前分配空间的别名。


## 1.4. 函数
- C++对函数的检查更严格
- C++支持bool类型：C++中的 `bool`，只占 1 个字节；java中使用 `boolean`；采用 `boolalpha`显示True或False；

### 1.4.1. 内联函数（inline）
- 函数定义时，加 `inline` 关键字，例如 `inline void func(){}`
- 内联函数的关键字 `inline` 与函数体的实现在一起，不需额外的声明。 
- 实现机制
  - C++编译器直接将函数体插入函数调用的地方。
- 什么时候可以用 `inline`？
  - 函数体不能过大。
  - 函数声明必须在调用之前声明。
  - 不能对函数进行取值地址操作。 
  - 不能存在任何形式的循环语句（for、while）。
  - 内联函数省去了普通函数调用时的压栈、跳转、返回操作。


### 1.4.2. 函数参数
- 默认参数
  - 函数的参数有一个默认的值。
  - 函数带有参数列表，参数列表的右边必须有默认的值，左边可以不给默认参数赋值。
- 占位参数
 - 只有函数类型声明，没有函数变量声明。`int func(int a, int b, int)`


### 1.4.3. 模板函数（建立一个通用函数）
  - 函数定义时不指定具体的数据类型
  - 函数调用时，根据实际参数反推数据类型，即类型的参数化
  

## 1.5. 命名空间（namespace）
- C中的命名空间
  - 只有一个全局的作用域，所有的全局标识符共用一个作用域。同名的标识符之间会发生冲突。
- C++的命名空间
  - 将全局的作用域分成不同的部分，不同命名空间的标识符可以同名而不会发生冲突。
  - 全局作用域也叫默认命名空间
  - 命名空间之间可以相互嵌套

- 语法
```
// 使用标准库中封装的内容。标准库中定义的所有名字都在命名空间 std 中
using namespace std
{
  .....
}
```
- `::` 作用域运算符
  ```
  std::out 从标准库中输出读取的内容，即编译器从操作符左侧名字的作用域中去寻找右侧的名字。
  ```
- 一般有三种方式去实现命名空间
  - 全部打开标准库中的内容。`using namespace std;`
  - 只打开标准库的部分内容。
    ```
    using std::cout;

    int main()
    {
      cout << ...;
      std::cin << ...;
      
      return 0;
    }
    ```
  - 在使用的时候根据需要打开
    ```
    int main()
    {
      std::cout << ...;
      std::cin  << ...;
     
      return 0;
    }


## 1.6. 头文件
- 头文件采用防御式声明 
    ```
    #ifndef __TEST_H
    #define __TEST_H
      ...
      
    #endif
    ```


## 1.7. 构造函数
- 为什么要用构造函数？
  - 被用来初始化类的对象。  
  - 类对象被创建时，编译器为对象(object)分配内存空间，并自动调用构造函数，完成成员的初始化 

- 构造函数特征 
  - 构造函数的 `函数名称` 与 `类的名称` 一样。
  - **函数没有返回值**
  - 函数参数值
    - 创建的对象有默认值时，应传入创建对象的默认值。
    - 创建的对象没有默认值时，编译器传入的默认值为 `0`

- 初始值列表 `initialize list`
  - `初始化列表` 是在对象创建成功之前完成的，而函数体内赋值是你的对象成员都已经创建好后再对成员进行赋值。
  - 语法
    ```
    //  将变量设置为 re=r, im=i
    : re(r), im(i)
    ```
  - 在带参数的构造函数里面第一行进行初始化。
  - 这种初始化并不是必须的，但是在以下几种情况时是必须进行初始化的
    - 成员是 `const` 类型。
    - 成员是`引用类型`。
    - 有一个成员是类型的对象（不是默认的构造函数）  
  - 初始化列表的顺序并不限定初始化的执行顺序，成员的初始化顺序是与类中定义的顺序保持一致。最好让构造函数初始值的顺序与成员声明的顺序保持一致。

- 构造函数注意点
  - 构造函数是一个 `成员函数`，函数内有一个 `this` 指针
  - 构造函数的访问属性可以放在 `private` 中。在单例模式（singleton）中就采用这种用法。
  - `构造函数` 与 `析构函数` 在类中声明了 ，必须要通过类的方法去实现，即声明了必须要用，否则编译时会报错。

- 类中默认的构造函数
  - 默认无参数构造：当类中没有定义构造函数时，C++编译器会默认提供一个无参数构造函数，构造函数的函数体为空。
  - 默认拷贝构造：当类中没有定义拷贝构造函数时，C++编译器会默认提供一个拷贝构造函数（浅拷贝），简单的进行成员变量的值拷贝操作。

- 构造函数分类
  - 无参构造：一般为栈内存空间，自动释放内存空间。调用时不用 `加括号`。
  - 带参数构造(重载了构造函数)
    - 一般为堆内存空间，需要使用delete释放内存空间；使用 `new` 关键字创建空间
    - 一般需要初始化构造的参数
    - 有默认值参数的构造函数，需要在类的声明中指定默认参数值，一般只能指定一次，在构造函数实现时不需要再给出默认值，否则会报错。
  - 拷贝构造
    ```
    // 声明一个类
    class String()
    {
      private:
        ...
      public:
        ...
    }
    // 实例化一个对象
    String st_one;

    // 拷贝构造
    String st_two = st_one;   // 方法一：等号(=)是拷贝一个对象不是赋值运算

    String st_three(st_one)   // 方法二：初始化拷贝构造

    函数的返回值是一个复杂的类型，会返回一个新的匿名对象。
    匿名对象什么时候留下？什么时候被析构？
      1、用匿名对象初始化一个同类型的对象，则匿名对象转化为有名字的对象。
      2、用匿名对象赋值给另外一个对象，则匿名对象被析构。
    ```

- 构造函数在继承中的用法
  > 构造函数与父类的其它成员(成员变量和成员方法)不同，它不能被子类继承。因此，在创建子类对象时，为了初始化从父类中继承来的成员变量，编译器需要调用其父类的构造函数。如果子类的构造函数没有显示地调用父类的构造函数，则默认调用父类的无参构造函数。 
  - 子类与父类均没有声明构造函数时，C++编译器会默认生成构造函数去调用。 
  - 子类继承父类的方法，默认会调用父类的无参数构造函数，再调用子类的无参或有参构造函数。
  - 当父类为有参构造函数时
    - 父类的有参构造函数有默认的值时，子类中不需要显式地调用父类的构造，C++编译器会默认的调用父类的有参构造函数。
    - 父类的有参构造函数没有默认的值时，子类中需要显式地调用父类的构造
      ```
      class Parent
      {
       private:
       public:
         Parent(int a, int b){};
      }
 
      class Child:public Parent
      {
      private:
      public:
        Child(int m, int n):Parent(a, b)     // 显示的调用父类的构造函数
      }
      ```
    - 父类中既有无参默认构造又有带参默认构造函数时，子类继承父类时，需要子类显示的指定到底该调用哪一个构造函数。


### 1.7.1. 拷贝构造（copy construction）
[c++拷贝构造函数详解](https://www.cnblogs.com/alantu2018/p/8459250.html)


- 拷贝构造函数是由普通构造函数和赋值操作符共同实现的。
- 拷贝构造函数必须以 `引用(reference)`的形式传递(参数为引用值)。
- 拷贝构造函数使程序更有效率，因为它不用再构造一个对象的时候改变构造函数的参数列表
- 当某对象是按值传递时（无论是类的对象作为函数参数，还是作为函数返回值），编译器都会先建立一个此对象的临时拷贝，而在建立该临时拷贝时就会调用类的拷贝构造函数。


- 浅拷贝
  - 当类的对象发生复制过程的时候，类的对象自己有资源（堆，或者是其它系统资源），但复制过程中并未复制资源，只是改变了指针的指向，这种称为浅拷贝。
  - 只是将类的成员值进行拷贝，类指针没有进行拷贝，两个指针同时指向一块内存空间。
  ```
  没有做任何的说明，C++编译默认使用的是浅拷贝。
  
  People obj_2 = obj_1;   将obj_1对象的内容拷贝到obj_2对象中，不是拷贝的指针。
  ```
  - 浅拷贝完成后，在释放资源的时候会产生资源归属不清的情况，导致一个指针指向已经被删除的内存空间，使程序运行出错。即销毁对象时，两个对象的析构函数将对同一个内存空间释放两次。
  

- 深拷贝
  - 当类的对象发生复制过程的时候，类的对象自己有资源（堆，或者是其它系统资源），但拷贝过程中复制了资源，这种将一个对象的资源完整的拷贝到另一个对象的过程，称为深拷贝。
  - 不仅拷贝了类的 `成员变量值`，还拷贝了类的指针，两个指针指向两块不同的内存空间。

- 什么时候用深拷贝和浅拷贝？
  - 类中没有自定义拷贝构造函数时，编译器会默认调用浅拷贝，完成成员的复制。
  - 当类的成员中没有指针时，浅拷贝是可行的。
  - 当类的成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，因此必须要用深拷贝。
  

- 拷贝赋值（copy assignment operator） 
  ```
  将对象s1拷贝赋值给对象s2，分3步：
  
  // 在拷贝之前需要进行自我赋值检测。即自己把值赋给自己，保证在执行第二步操作时，指针有指向的位置。
  if (this == str)
  {
    return *this
  }

  1、将s2自己清空
  2、分配 s2大小的内存空间存放s1
  3、执行拷贝动作
  ``` 


## 1.8. 析构函数（destructor）
  - 表示：在类名称之前加 `~`。例如：`string::~string()` 
  - 作用：类的对象离开作用域后释放对象使用的资源，在类死亡之前的前一刻调用，用于清除类中的资源（比如：释放内存）。
  - `一个类只能有一个析构函数，多个类有多个析构函数`，如果没有显式的定义，系统会自动生成一个默认的析构函数。
  - 析构函数不能 `重载`。每有一次构造函数的调用就会有一次析构函数的调用。

## 1.9. new和delete
- windows 下内存显示总是 `16` 的倍数，不是 16 的倍数，则填充为最靠近 16 的倍数的大小。 
- `new` 动态分配内存 
  - 先分配空间，再调用构造函数 
  - new创建一维动态数组
    ```
    // 数组类型
    typeName* pointer_name = new typeName[num_elements];
    例如：int *p = new int[10];

    // 普通类型
    typeName* pointer_name = new typeName 
    例如：int *p = new int;
    ```  
  - 创建二维数组
    ```
    格式：typeName (*ptr)[col_num] = new typeName[row_num][col_num];
    例子：int (*ptr)[2] = new int[4][2];
    ```
  - 创建对象
    ```
    class Airplane
    {
      ...
    }

    Airplane *ap = new Airplane;
    ```

- `delete` 释放内存，与new配对使用 
  - 先调用析构函数，再释放空间  
  - 注意
    - 不要尝试释放已经释放的内存块 
    - 不是用new分配的动态内存空间，不能用delete释放

- 注意：
  - 采用 `array new` 的方式创建一块内存空间，则一定要采用 ` array delete` 方式去释放内存，否则在涉及指针的时候可能会导致内存泄漏。泄漏的并不是整个分配的内存空间，而是分配的空间中数组没有被释放的部分。
  - 不配对地使用new和delete，将发生内存泄漏（memory leak），被分配的内存再也无法使用了，如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。


## 1.10. 重载（overloading）
- 必须在一个类中进行。C++中构造函数也可以重载。
- 函数名称相同，函数参数不同 `（参数个数，参数类型）`。
- 函数的 `返回值` 不是函数重载判断的标准。
- 编译器在编译时，根据函数的 `参数列表` 进行重命名。
- 子类无法重载父类的函数。
- 如果子类与父类的函数名称相同，则发生函数名称覆盖，不会发生函数重载。若想在子类和父类中分别调用具有相同名称的函数，则需要使用 `域分符号::`
  - 当子类中没有与父类相同参数的函数，只有名称相同的函数时，而子类去调用父类中重载的函数，则C++编译器会将子类中有相同函数名称的函数去覆盖掉父类中相同名称的函数，从而将当前子类调用父类的函数当做子类中一个新的重载函数，但是编译器发现子类中并没有该函数的重载，因此会报错。


## 1.11. 重写（overwrite） 
- 子类对父类同名函数的重新定义。
- 必须发生在子类与父类之间，并且父类与子类的函数具有完全相同的原型。
- 使用 `virtual` 关键字声明后，能够产生多态，没有使用 `virtual` 关键字，只能叫重定义，不叫虚函数重写。

- 重载与重写的区别
  - 作用域不同：重载是在同一区域，子类无法重载父类，父类同名函数的将被覆盖，重写是在父类与子类之间。
  - 重载是在编译期间根据参数列表决定，重写是在 `运行期间` 根据具体对象类型来决定调用的函数。


## 1.12. const
- C语言中，`const` 是只读的变量，有自己的存储空间。
- C++中，`const` 可能分配存储空间，也可能不分配存储空间。
  - 当 `const` 作为全局变量，并在其它的文件中到调用时，会分配存储空间。
  - 采用 `&` 地址运算符去取 `const` 变量的地址时，会分配存储空间。
- 加 `const` 后，不会改变数据的内容，不加`const`，则会改变数据的内容，一般数据的内容定义在 `private`中。
- 在类中采用 `const`修饰函数，需要在类调用时必须加 `const`
  ```
  声明：
  double real() const
  {
      return re;
  }

  调用：
  const complex fx(1, 2);
  ```
- `const` 常量由 `编译器`处理的，提供作用域检查和类型检查。而 `宏定义（#define）` 仅仅只是单纯的文本替换，在 `预处理` 阶段处理的。


## 1.13. static
- 一个类的成员变量为静态成员变量（即含有`static` 关键字）时，这个类中无论有多少个对象被创建，这些对象都共享这个 `static` 成员。
- 静态成员函数中不能使用非静态成员变量和非静态成员函数。
- C++中的成员函数和成员变量是分开存储的。

- 继承中使用 `static`，需要在类的外部进行初始化，并且C++编译器在外部初始化的同时还给变量分配内存空间，只有在使用时才分配内存空间，不调用不分配内存空间。

- 类模板中使用 `static`
  - 每个类模板中都有自己的类模板 `static` 数据成员副本。
  - 与非类模板的 `static` 数据成员一样，类模板中的 `static` 数据成员也需要进行 `定义` 和 `初始化`。


## 1.14. 参数传递与返回值传递
- pass by value 和 pass by reference
  - 传值是将整个的数据传递给调用者
  - 传引用本质是 `传指针`。
    - 采用一个 `&` 符号表示。
    - 希望调用者对传递的数据不能进行修改，在数据前加 `const` 限制。
- 参数传递时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。`传引用` 的速度比 `传值` 速度快。
- 函数返回 `值传递` 时：在能使用传reference的前提下，一般优先使用 `传引用` 而尽量少使用传值，并不是必须的。 


- 什么情况下不能使用 `引用传递（reference）`？
  - 当一个函数参数的变量为局部变量时，不能使用传引用。因为变量在函数结束时，变量就被销毁了，不存在，若再传递引用，调用者则不能得到值，会出错。


## 1.15. friend（友元）
  - 在一个类中使用 friend，当前类中未定义的函数可以去拿当前类中的数据。
  - 同一个 class 中的各个 object 互为友元。
    ```
    函数定义：
    int func(const complex& param)
    {
        return value;
    }

    声明对象:
    complex c1;
    complex c2;
    c2.func(c2);   // 采用友元方式实现，通过对象参数访问私有成员数据
    ```
  - 在类（class）的外部函数访问类的私有成员，需要将函数设置为类的 `friend` 属性。

- 友元类
  - 若B类是A类的友元类，则B类的所有成员函数都是A类的友元函数。
  - 通常是为设计一种数据操作或类之间传递消息的辅助类。

- 友元函数
  - 类中没有定义的函数，使用 `friend` 关键字可以在不同的类之间访问该函数。
  - 运算符重载 `<<` 和 `>>` 一般使用友元函数，其它的函数一般定义为 `类的成员函数`。
  - 在类模板中一般不要滥用友元函数，使用会很复杂，若将 `.h` 文件与 `.cpp` 文件分开实现，将会更加的复杂。


## 1.16. this
- 什么叫成员函数：在类（class）中声明的函数。
- 什么叫非成员函数：没有在类（class）中声明的函数，非成员函数也叫全局函数。
- 哪个对象调用非静态成员函数，`this` 就指向哪个对象。 
- 静态成员函数中不包含 `this` 指针，非静态成员函数中包含 `this` 指针
- 成员函数中 `const` 修饰的是谁？
  ```
  class TT
  {
  private:
    ......
  public:
    void func(int a, int b) const
    {}
  }

  // 由C++面向对象模型知，上面的函数等价于
  void func(TT *this, int a, int b) const
  {}
  
  // const修饰的是this指针指向的内存空间。
  ```

- 类名后直接加括号，不创建一个对象，代表一个临时对象（temp object）。
    ```
    //声明类
    class complex
    {
        public:
            // 主要放置函数
            ........

        private:
            // 定义数据
            ........
    }

    // 调用临时对象
    complex();
    ```


## 1.17. 操作运算符重载（operator overloading）
- 为什么要操作符重载？
  > 普通的运算规则不能满足复杂的数据类型，像 `类（class）`数据类型，需要编程人员自定义运算规则去实现。
- 操作运算符重载的本质是个 `函数`。

- 操作符重载有两种实现的方式
  - 非成员函数方式，即全局函数（全域）的方式。
    - 通常与 `friend` 友元函数结合在一起使用。
    - 应用场景：重载不同类之间的操作符。例如，重载 `<<` 和 `>>`，编程人员自定义的类与C++编译器中 `ostream` 或 `istream` 类中的数据进行操作符重载。
  - 成员函数方式。
    - 函数的参数有一个隐藏的 `this` 指针，可以在函数里面去调用。

- 分析重载的步骤？
  - 确定函数名称
  - 确定函数参数
  - 根据业务，确定函数的返回值类型（是返回引用还是返回值？）以及函数体的实现。  

- `=赋值` 操作符重载
  - `=` 只是将成员变量的值相应复制。由于对象内包含指针，将造成不良后果：指针的值被丢弃了，但指针指向的内容并未释放。 

## 1.18. `.h`与 `.hpp` 文件区别
- `.hpp` 本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数，也不用再发布lib与dll文件，因此非常适合用来编写公用的开源库。

- hpp的优点
  - 是Header Plus Plus的简写。（.h和.hpp就如同.c和.cpp似的）
  - 与.h类似，.hpp是C++程序头文件格式。
  - 是VCL专用的头文件,已预编译。
  - 是一般模板类的头文件。
  - 一般来说，.h里面只有声明，没有实现，而.hpp里声明实现都有，后者可以减少.cpp的数量。
  - .h里面可以有using namespace std，而.hpp里则无。
  - 不可包含全局对象和全局函数。

- 当hpp文件中存在全局对象或者全局函数，而该hpp被多个调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。