<!--
 * @Author: JohnJeep
 * @Date: 2022-03-30 22:59:03
 * @LastEditTime: 2022-03-31 00:27:22
 * @LastEditors: your name
-->


# 1 `.h`与 `.hpp` 文件区别

`.hpp` 本质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该.hpp文件即可，无需再将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj，采用hpp将大幅度减少调用project中的cpp文件数与编译次数，也不用再发布lib与dll文件，因此非常适合用来编写公用的开源库。

使用 `hpp` 的优点

- 是Header Plus Plus的简写。（.h和.hpp就如同.c和.cpp似的）
- 与.h类似，.hpp是C++程序头文件格式。
- 是VCL专用的头文件,已预编译。
- 是一般模板类的头文件。
- 一般来说，.h里面只有声明，没有实现，而.hpp里声明实现都有，后者可以减少.cpp的数量。
- .h里面可以有using namespace std，而.hpp里则无。
- 不可包含全局对象和全局函数。

当hpp文件中存在全局对象或者全局函数，而该hpp被多个调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。


# 2 ++i 与 i++ 效率问题

- `++i` 返回的是对象的引用，而 `i++` 返回的是对象的原值（但非左值）。
- `++i` 先自增，后返回原对象的对象，没有产生任何临时对象；而 `i++`，先保存原对象，然后自增，最后返回该原对象的临时对象，需要创建和销毁对象。


# 3 传值、传引用、传指针三者的区别

形参

- 在函数或方法中定义的参数就是形参。
- 函数没有被调用时，形参并不会占用内存的存储单元，只有当函数被调用时，形参才会被分配内存单元，在函数体执行完后，形参存储的内存单元被释放。

实参

- 实参可以是常量、变量和表达式，但必须要有确定的值。  
- 函数调用的时候，先给形参分配内存空间，然后将实参的值拷贝一份给形参，函数体调用结束后，形参分配的内存空间被释放，但是实参分配的内存空间还存在。

传值

- 可以传实参和形参。
- 比如函数定义为 `fun(int a)`，在调用的地方有`int x=6`， 使用`fun(x)`调用。这种方式在 `fun(int a)` 函数内部的对`a`的修改 `不能` 导致外部 `x` 的变化。
- 值传递时，程序会为形参分配内存空间，并将实参的值赋值给形参，函数体中形参的改变并不会影响实参的值，形参存储的是实参的副本。

传地址

- 传地址也叫指针传递。
- 函数定义为 `fun(int *a)`，形参为指针，调用的时候传递的是参数的地址，例如 `int x=6; fun(&x)`。 这种方式在 `fun(int a)`函数内部的对 `a` 的修改 `能` 导致外部 `x` 的变化。

传引用

- 用 `&` 符号定义的形参，在参数传递时相当于实参的一个别名，对形参的操作相当于直接对实参进行操作。
- 函数定义为 `fun(int& a)`，形参为引用，例如 `int x=6; fun(x)`。 在 `fun(int& a)` 函数内部的对变量 `a` 的修改 `能` 导致外部 `x` 的变化。
- 传引用时，程序不是将直接实参本身的值复制后传递给形参，而是将实参的地址值传递给形参，形参所引用地址上的变量与传递的实参相同，因此，函数体内形参的改变会直接改变实参的值。

