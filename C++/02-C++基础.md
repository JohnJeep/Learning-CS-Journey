<!--
 * @Author: JohnJeep
 * @Date: 2020-06-08 08:47:41
 * @LastEditTime: 2020-06-08 08:47:42
 * @LastEditors: Please set LastEditors
 * @Description: C++基础面向对象部分
 * @FilePath: \Learning-Computer\C++\02-C++基础.md
--> 

<!-- TOC -->

- [0.1. 封装](#01-封装)
- [0.2. 面向对象编程（OOP）](#02-面向对象编程oop)
- [0.3. 复合（composition）](#03-复合composition)
- [0.4. 委托（delegation）](#04-委托delegation)
- [0.5. 继承（Inheritance）](#05-继承inheritance)
  - [0.5.1. 类型兼容原则](#051-类型兼容原则)
  - [0.5.2. 继承中的构造与析构调用原则](#052-继承中的构造与析构调用原则)
  - [0.5.3. 继承中同名成员变量处理方法](#053-继承中同名成员变量处理方法)
  - [0.5.4. 继承与虚函数（virtual function）的结合](#054-继承与虚函数virtual-function的结合)
- [0.6. 多态](#06-多态)

<!-- /TOC -->

## 0.1. 封装
- 封装了成员数据和常用函数
- 封装了属性和方法。
- `public`  修饰类的成员变量和函数，既能在类的内部使用又能在类的外部使用
- `private` 修饰类的成员变量和函数，只能在类的内部使用，不能在类的外部使用
- `protect` 修饰类的成员变量和函数，只能在 `类的内部` 使用，不能在类的外部使用，可以在继承的子类中使用。    


## 0.2. 面向对象编程（OOP）
- 静态对象（static object）：在作用域（scope）结束后，生命周期还存在，即没有结束，一直到整个程序结束了，它的生命周期也就结束了。
  - 静态的函数没有 `this` pointer，只能去处理静态的数据
    ```
    如何去调用？ 
    1、使用 object 调用。Account a.state(10);
    2、通过 class name 来调用。Account::state(10);
    ```
- 全局对象（global object）：整个程序结束了，它的生命周期也就结束了。
- 头文件名包含在尖括号 `<>` 中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号 `""` 中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）

- 类的声明和实现时分开的。
  - `.h` 文件只作类的声明
  - `.cpp` 文件进行类的实现 


## 0.3. 复合（composition）


## 0.4. 委托（delegation）
- 两个类之间通过指针相连


## 0.5. 继承（Inheritance）
- 三种继承：public、private、protect
- 数据的继承：子类继承的是父类内存中的数据。
- 函数的继承：子类继承的是父类的调用权利。
- 如何看继承中的访问控制权限
  - 看类的调用语句，是在类的内部还是在类的外部？
  - 看子类如何从父类中继承？
  - 看父类的访问级别？ 
- `public继承`    父类成员在子类中保持原有的访问级别。
- `private继承`   父类成员在子类中的访问级别都变为 `private`
- `protected继承` 
  - 父类中 `public` 成员属性会变为 `protected`
  - 父类中 `private` 成员属性仍然为 `private`
  - 父类中 `protected` 成员属性仍然为 `protected`

- C++中支持多继承的方式


### 0.5.1. 类型兼容原则
- 子类是特殊的父类。
- 基类（父类）的指针或引用直接指向子类的对象。
  - 指针做函数参数
    ```
    class Parent
    {}

    class Child
    {}

    Parent *p1 = NUll;
    Child c1;
    p = &c1;     // 父类的指针直接指向子类的对象
    ```
  - 引用做函数参数
- 子类对象直接`初始化` 父类对象。
- 子类对象直接 `赋值` 给父类对象。
- 子类对象可以 `当做父类对象使用`。


### 0.5.2. 继承中的构造与析构调用原则
- 内存角度探讨调用原则
  - 构造：由内而外。先调用base(父类)的默认构造函数，然后才执行自己。
  - 析造：由外而内。先执行自己，然后再调用 base(父类)的析构函数。


### 0.5.3. 继承中同名成员变量处理方法
- 子类与父类中的成员变量和成员函数有相同的名称时，采用作用域的方式调用。
```
class Parent
{
public:
    int m;
    void shoe();
}

class child
{
public:
    int m;
    void shoe();
}

Parent p1;
Child c1;

// 调用
p1.Parent::m = 100;
c1.Child::m = 200;
p1.Parent::shoe();
c1.Child::shoe();
```

### 0.5.4. 继承与虚函数（virtual function）的结合
- 为什么会有虚继承
  - 解决多个继承可能产生的二义性。 


- non-virtual: 不希望子类（derived）重写
- virtual: 希望子类重写（override）父类，父类已有默认值
- pure-virtual: 子类（derived）中必须重写(override)父类，父类没有默认值。

- 在使用框架结构去设计程序的时候，常常使用 `Template Method` 设计模式去实现。


## 0.6. 多态








