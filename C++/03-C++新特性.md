<!--
 * @Author: JohnJeep
 * @Date: 2021-01-10 18:21:43
 * @LastEditTime: 2021-01-11 14:13:52
 * @LastEditors: Please set LastEditors
 * @Description: 解释C++相关的新特性
-->

<!-- TOC -->

- [1. C++11新特性](#1-c11新特性)
  - [1.1. Template表达式内的空格](#11-template表达式内的空格)
  - [1.2. Initializer lists(初值列)](#12-initializer-lists初值列)
  - [1.3. nullptr](#13-nullptr)
  - [1.4. for 循环](#14-for-循环)
  - [1.5. Lambda表达式](#15-lambda表达式)
  - [1.6. decltype](#16-decltype)
  - [1.7. explicit](#17-explicit)
  - [1.8. auto](#18-auto)
  - [1.9. noexcept](#19-noexcept)
  - [1.10. constexpr](#110-constexpr)
  - [1.11. enable_shared_from_this](#111-enable_shared_from_this)
    - [1.11.1. 什么是 `enable_shared_from_this`?](#1111-什么是-enable_shared_from_this)
    - [1.11.2. 为什么要用 `enable_shared_from_this`？](#1112-为什么要用-enable_shared_from_this)
    - [1.11.3. 什么时候用？](#1113-什么时候用)
    - [1.11.4. 如何安全地将 this 指针返回给调用者?](#1114-如何安全地将-this-指针返回给调用者)
    - [1.11.5. 标准库中的源码](#1115-标准库中的源码)
    - [1.11.6. 具体的代码示例](#1116-具体的代码示例)
    - [1.11.7. 使用注意事项](#1117-使用注意事项)
    - [1.11.8. 参考](#1118-参考)
  - [1.12. override(覆写、重写)](#112-override覆写重写)
  - [1.13. final](#113-final)
  - [1.14. New Function Declaration Syntax(新的函数声明语法)](#114-new-function-declaration-syntax新的函数声明语法)
  - [1.15. Scoped Enumerations(带作用域的枚举)](#115-scoped-enumerations带作用域的枚举)
  - [1.16. New Template Features](#116-new-template-features)
    - [1.16.1. variadic templates(参数数量不定的模板)](#1161-variadic-templates参数数量不定的模板)
    - [1.16.2. Alias Templates (Template Typedef)](#1162-alias-templates-template-typedef)
    - [1.16.3. Function template](#1163-function-template)
  - [1.17. Move Semantics and Rvalue References](#117-move-semantics-and-rvalue-references)
  - [1.18. =delete =default](#118-delete-default)

<!-- /TOC -->

# 1. C++11新特性

## 1.1. Template表达式内的空格
在C++11之后，对一些语法做了一些优化(Important Minor Syntax Cleanups)。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。
```cpp
vector<list<int> > ;  // C+11之前版本，必须要加一个空格，否则编译器会报错
vector<list<int>> ;   // C++11之后，不用加空格，语法得到了优化
```


## 1.2. Initializer lists(初值列)
- C++11 引入了初值列和一致性初始化（Uniform Initialization）。
- `初始值列` 赋值是在对象创建成功之前完成的，而 `函数体内赋值` 是你的对象成员都已经创建好后再对成员进行赋值。
- 在带参构造函数的函数体外面，第一行进行初始化。
- 语法
  ```C++
  //  将成员变量设置为 re=r, im=i
  : re(r), im(i)
  ```
- 这种初始化并不是必须的，但是在以下几种情况时是必须进行初始化的
  - 成员是 `const` 类型。
  - 成员是`引用类型`。
  - 有一个成员是类型的对象（不是默认的构造函数）  
- 初始化列表的顺序并不限定初始化的执行顺序，成员的初始化顺序是与类中定义的顺序保持一致。最好让构造函数初始值的顺序与成员声明的顺序保持一致。


## 1.3. nullptr
- 从C++11开始让你使用 `nullptr` 关键字去替代老版本中 `0或 NULL`的值，`nullptr` 表示一个指针指向的值是没有值的。这个特性可以避免当一个 `null` 指针被当做一个整数解释时，程序产生的错误。
 
- `nullptr` 的类型是 `std::nullptr_t`, 位于标准库的 `<stddef.h>` 头文件中，其中，`std::nullptr_t` 被当做基础类型。

- **标准库中源码实现**
```cpp
#if defined(__cplusplus) && __cplusplus >= 201103L
#ifndef _GXX_NULLPTR_T
#define _GXX_NULLPTR_T
  typedef decltype(nullptr) nullptr_t;
#endif
#endif /* C++11.  */
```



## 1.4. for 循环
- 引入了一种崭新的 `for` 循环：逐一迭代给定的某个区间、数组、集合内的每一个元素。
  ```C++
  for (auto i : {1, 3, 5, 7})   // 注意: {} 是一个容器
  {
      cout << i << endl;
  }
  ```

  <img src="./figures/range-base-for.png">

## 1.5. Lambda表达式
支持Lambda表达式：`[](){}`




## 1.6. decltype
- 是C++11 增加的一个关键字，作为类型推导，操作过程是在编译时进行的。 
- 应用
  - 常常与 `typdef/using` 关键字结合起来使用。
  - 可以处理匿名的类型。比如：`union`, `struct `结构中出现的匿名数据，可以使用这个来解决。
  - 泛型模板中使用，增加模板使用的范围。 
    ```C++
    template<typename T1, typename T2>
    void sum(T1& t1, T2& t2, decltype(t1 + t2)& s) {
      s = t1 + t2;
    }
    ```
  - **最重要的一个作用：推导函数的返回类型(used to declare return types)。**


## 1.7. explicit
- 被 `explicit` 关键字修饰的类构造函数，不能进行自动地隐式类型转换，只能显式地进行类型转换。
- 当类的声明和定义分别在两个文件中时，`explicit` 只能写在在声明(`declaration`)中，不能写在定义(`definition`)中。
- 大部分情况下 `explicit` 关键字使用在构造函数中，还有少部分是用在模板中。
  > 被声明为explicit的构造函数通常比其non-explici兄弟更受欢迎，因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。我鼓励你遵循相同的政策。




## 1.8. auto
- C++11中新增的一个关键字，让编译器通过初始值去分析所属类的类型。`auto` 关键字会完成类型自动推导(Automatic Type Deduction with auto)：根据初始值自动推导变量的类型，因此，在使用这个关键字之前，必须需要将变量初始化。
- `auto` 一般会忽略掉顶层的 const，但底层的const会保留下来。从变量声明的初始化表达式处获得变量的类型。
  ```C++
  const int ci = i;
  const auto f = ci;  // ci的推演类型是int，f是const int
  ``` 


## 1.9. noexcept
- C++11 引入了该关键字 `noexcept`。该关键字告诉编译器，指定的某个函数不会抛出异常。通常有两种不同的方式来使用这个关键字。第一种方式，简单地将 `noexcept` 关键字放在函数声明的后面，这样该函数便会被标记为不会抛出异常。
  ```cpp  
  void add(int) noexcept;   // 表明add() 函数不会抛出异常
  ```

- 第二种方式：为 `noexcept` 关键字额外提供一个常量表达式作为其参数，若这个常量表达式的值为 “true”，那么函数就会被标记为不会抛出异常，反之亦然。
  ```cpp
  constexpr bool suppressExcept = true;
  void excpt_func() noexcept (suppressExcept);
  ```

<font color=red>
注意：
</font>

- 若当前函数抛出来的异常没有被立即处理，则一直通过 throw 关键往上抛，直到被标准库中的 std::terminal() 捕获，再去处理，其中 std::terminal() 内部默认调用的是 std::abort()。
- C++中的异常处理是在程序运行时检测，而不是编译时检测的。为了实现运行时检测，编译器会创建额外的代码，然而这会妨碍程序优化。
- 函数指针的声明和定义中可以指定 `noexcept`
- `typedef或类型的别名` 中不能使用 `noexcept`
- 成员函数中，`noexcept` 需要跟在 `const或引用` 限定符之后，但是跟在 `final、override或虚函数=0` 这些限定符之前。
- 移动构造函数(move constructor)：在对象进行 `copy` 时，直接拷贝对象所保有的一些资源。比如，已经在原对象中分配的堆内存、文件描述符，以及 IO 流等。
- 移动分配函数(move assignment)
- 析构函数(destructor)。在新版本的编译器中，析构函数是默认加上关键字 `noexcept`的。


参考
  - [C++中的移动构造与noexcept](https://www.yhspy.com/2019/11/22/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E4%B8%8E-noexcept/) 


## 1.10. constexpr
- 常量表达式(const expression)：表示值不会改变，并且在编译过程中就能得到计算的结果的表达式。
- 为什么要使用constexpr？
  > 提高程序的执行效率，允许一些计算发生在编译时，而不是在运行的时候，因而采用常量表达式。`constexpr` 关键字在 C++11 中引入，而在 C++14 中得到改善，它表示允许将变量声明为 `constexpr` 类型，让编译器来验证变量的值是否是一个常数表达式。
- const与constexpr的区别：
  - const变量的初始化可以延迟到程序运行时 
  - constexpr变量的初始化必须在编译时进行
  - constexpr指针：限定符constexpr仅对指针有效，与指针所指向的对象无关。
    ```C++
    const int* p = nullpter;      // p是一个指向整型常量的指针
    constexpr int* q = nullptr;   // q是一个指向整数的常量指针 
    ```

- constexpr函数
  - 函数体中必须只有一条 `return` 返回语句。 `constexpr int func() {return 100;}`
  - 在编译时，constexpr函数被隐式的指定为内联函数。
  - 内联函数和constexpr函数一般定义在头文件中。

## 1.11. enable_shared_from_this
### 1.11.1. 什么是 `enable_shared_from_this`?
  下面摘自 cpp reference 中概述
  > C++11开始时支持 `enable_shared_from_this`，它一个模板类，定义在头文件 `<memory>`，其原型为： ` template< class T > class enable_shared_from_this;`
  
  > std::enable_shared_from_this 能让其一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。
  
  > 若一个类 T 继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数： shared_from_this 。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。

### 1.11.2. 为什么要用 `enable_shared_from_this`？
- 需要在类对象的内部中获得一个指向当前对象的 shared_ptr 对象。
- 如果在一个程序中，对象内存的生命周期全部由智能指针来管理。在这种情况下，要在一个类的成员函数中，对外部返回this指针就成了一个很棘手的问题。


### 1.11.3. 什么时候用？
- 当一个类被 `share_ptr` 管理，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的 `share_ptr`。


### 1.11.4. 如何安全地将 this 指针返回给调用者?
- 一般来说，我们不能直接将this指针返回。如果函数将 this 指针返回到外部某个变量保存，然后这个对象自身已经析构了，但外部变量并不知道，此时如果外部变量再使用这个指针，就会使得程序崩溃。


### 1.11.5. 标准库中的源码
```cpp
  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }

#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
#define __cpp_lib_enable_shared_from_this 201603
      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }
#endif

    private:
      template<typename _Tp1>
	void
	_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
	{ _M_weak_this._M_assign(__p, __n); }

      // Found by ADL when this is an associated class.
      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
				     const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
	friend class __shared_ptr;

      mutable weak_ptr<_Tp>  _M_weak_this;
    };
```
- enable_shared_from_this类中的成员函数
  - (constructor)：构造一个 enable_shared_from_this 对象，是一个受保护的成员函数，成员属性为 `protected`。
  - (destructor)：销毁一个 enable_shared_from_this 对象，是一个受保护的成员函数，成员属性为 `protected`。
  - operator=：返回到 this 的引用，是一个受保护成员函数，成员属性为 `protected`。
  - shared_from_this：返回共享 `*this` 指针所有权的 shared_ptr，是一个 `public` 属性的成员函数。
  - weak_from_this(C++17)：返回共享 `*this` 所指针有权的 weak_ptr，是一个`public` 属性的成员函数。
 
### 1.11.6. 具体的代码示例

```cpp
#include <iostream>
#include <stdlib.h>
#include <memory>
using namespace std;

// 比较推荐的写法
struct Good : std::enable_shared_from_this<Good> // note: public inheritance
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};

// 错误的用法：用不安全的表达式试图获得 this 的 shared_ptr 对象
struct Bad
{
    std::shared_ptr<Bad> getptr() {
        return std::shared_ptr<Bad>(this);
    }
    ~Bad() { std::cout << "Bad::~Bad() called\n"; }
};
 
int main()
{
    // 正确的用法: 两个 shared_ptr 共享同一个对象
    std::shared_ptr<Good> gp1 = std::make_shared<Good>();
    std::shared_ptr<Good> gp2 = gp1->getptr();
    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';
 
    // 错误的用法: 调用 shared_from_this 但其没有被 std::shared_ptr 占有 
    try {
        Good not_so_good;
        std::shared_ptr<Good> gp1 = not_so_good.getptr();
    } 
    catch(std::bad_weak_ptr& e) {
        // 在 C++17 之前，编译器不能捕获 enable_shared_from_this 抛出的std::bad_weak_ptr 异常
        // 这是在C++17之后才有的特性
        std::cout << e.what() << '\n';    
    }
 
    // 错误的用法，每个 shared_ptr 都认为自己是对象的唯一拥有者
    // 调用错误的用法，会导致两次析构 Bad的对象，第二次析构时，指针指向的空间已经被析构，
    // 会导致程序出错
    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();
    std::shared_ptr<Bad> bp2 = bp1->getptr();
    std::cout << "bp2.use_count() = " << bp2.use_count() << '\n';

    return 0;
}  
```

### 1.11.7. 使用注意事项
 - enable_shared_from_this 的常见实现为：其内部保存着一个对 this 的弱引用（例如 std::weak_ptr )。 std::shared_ptr 的构造函数检测无歧义且可访问的 (C++17 起) enable_shared_from_this 基类，并且若内部存储的弱引用没有被以存在的 std::shared_ptr 占有，则 (C++17 起)赋值新建的 std::shared_ptr 为内部存储的弱引用。为另一个 std::shared_ptr 所管理的对象构造一个 std::shared_ptr ，将不会考虑内部存储的弱引用，从而将导致未定义行为(undefined behavior)。
  
- 只允许在先前已被std::shared_ptr 管理的对象上调用 shared_from_this 。否则调用行为未定义 (C++17 前)抛出 std::bad_weak_ptr 异常（通过 shared_ptr 从默认构造的 weak_this 的构造函数） (自C++17 起)。

- enable_shared_from_this 提供安全的替用方案，以替代 std::shared_ptr<T>(this) 这样的表达式（这种不安全的表达式可能会导致 this 被多个互不知晓的所有者析构）。


### 1.11.8. 参考
- [cpp reference解释其用法](https://zh.cppreference.com/w/cpp/memory/enable_shared_from_this) 
- [enable_shared_from_this用法分析](https://bbs.huaweicloud.com/blogs/136194)
- [enable_shared_from_this类的作用和实现](https://www.shuzhiduo.com/A/l1dyNmW9ze/)
- [C++11标准库的一个工具类enable_shared_from_this<T>的作用及原理分析](https://www.cnblogs.com/jo3yzhu/p/11358400.html)



## 1.12. override(覆写、重写)
- 什么是override？
  - override 是C++11引进的一个说明符，翻译为 `覆盖` 的意思。C++11 中的 override 关键字，可以显式的在派生类（子类）中声明，看哪些成员函数需要被重写。

- override有什么用?
  - 一般在继承中，涉及到虚函数时，需要在子类中重新改写函数的内容，去实现父类的方法，这时 `override` 关键字就派上用场了。


- 注意事项
  - 在派生类的成员函数中使用override时，如果基类中无此函数或基类中的函数并不是虚函数，编译器会给出相关错误信息。 

![](./figures/override.png)

## 1.13. final
final 是C++11引进的一个说明符，有两种使用方式。

第一种：用在 `class` 类名之后，表示当前的类是一个类的最终继承者，不能再被额外的类继承了。若还有子类继承自用 `final` 关键字修饰的父类，编译器则会报错。

第二种：虚函数中用于修饰函数，若父类中有用 `final` 关键字修饰的虚函数，则表明该虚函数不能再被其子类重写了，它是一个最终的虚函数，否则编译器会报错。

![](figures/final.png)



## 1.14. New Function Declaration Syntax(新的函数声明语法)


## 1.15. Scoped Enumerations(带作用域的枚举)



## 1.16. New Template Features
### 1.16.1. variadic templates(参数数量不定的模板)
variadic templates(参数数量不定的模板)是C++新增的一个非常重要的特性。

<img src="./figures/1-variadic-templates.png">

代码部分
```cpp
#include <iostream>
#include <bitset>

using namespace std;

/**
 * @description: 当包 ... 中 的个数等于0时就会执行下面这个空的函数 
 * @param {*}
 * @return {*}
 */
void my_print()
{
}

template<typename T, typename... Types>
void my_print(const T& firstAgs, const Types&... args)
{
    cout << firstAgs << endl;
    my_print(args...);
}

int main(int argc, char *argv[])
{
    my_print(100, "hello", bitset<16>(377), 50);

    return 0;
}
```


<img src="./figures/2-variadic-templates.png">
<img src="./figures/3-variadic-templates.png">

使用这个的好处是帮助我们解决递归。递归的过程就是把不定参数的个数一一分解出来。


### 1.16.2. Alias Templates (Template Typedef)
一、Alias Templates 是一个别名模板。

简单用法
```cpp
// declaration
template<typename T>
using Vec = std::Vector<T, MyAlloc<T>>;

// call 
Vec<int> coll;
```

上面的代码等价于 
```cpp
std::vector<int, MyAlloc<int>> coll;
```

![](./figures/0-alias-template.png)


<font color=red>
alias template 不可能用作 偏特化 或 全特化。
</font>

从上面的代码看，`using` 使用的效果与 `#define` 或 `typedef` 的用法似乎是一样的，其实并不是一样的，反而使用 `#define` 或 `typedef`不能实现 `alias template` 所达到的效果。


![](./figures/1-alias-template.png)
![](./figures/2-alias-template.png)
![](./figures/3-alias-template.png)




二、**Type Alias**

Type Alias 是一个类型别名。

第一种用法与 `typedef` 的用法是一样的。

```cpp
typedef void(*func)(int, int);
using func = void(*)(int, int);  // 两者实现的用法是等同的

void example(int, int) {}
func f = example;
```

第二种用法：type alias 用在 `member typedef name(成员类型名字)`。
```cpp
template<typename T>
struct Container {
  using value_type = T;  // 等同于 typedef T value_type;
};

// 泛型编程中使用
template<typename Cntr>
void f2(const Cntr& ct)
{
  typename Cntr::value_type n;
}
```

三、**哪些地方会用到 using 关键字？**

- 第一种：namespace 中： `using namespace std;`

- 第二种：为类成员做声明（using-declarations for class members）
```cpp
protected:
  using _Base::_M_allocate;
  using _Base::_M_deallocate;
```

- 第三中：从C++11起引入了 `type alias` 和 `alias template`。
```cpp
using func = void(*)(int, int);  

template<typename T>
struct Container {
  using value_type = T;  // 等同于 typedef T value_type;
};

template <class CharT> using mystring = 
std::basic_string<CharT, std::char_traits<CharT>>;
```



### 1.16.3. Function template

## 1.17. Move Semantics and Rvalue References

## 1.18. =delete =default
五个地方能用到
- constructor
- copy constructor
- asignment copy
- 右值引用
- 拷贝赋值中的右值引用

```cpp
class Pro
{
public:
  Pro(int a, int b) 
    : m_a(a), m_b(b)
    {}
  Pro(const pro&)=delete;
  Pro(Pro&&)=default;
  Pro& operator=(const Pro&)=default;
  Pro& operator=(const Pro&&)=delete;
  virtual ~Pro();

private:
  int m_a, m_b;
};

```

