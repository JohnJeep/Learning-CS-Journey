<!--
 * @Author: JohnJeep
 * @Date: 2020-06-15 08:48:16
 * @LastEditTime: 2020-06-16 16:17:56
 * @LastEditors: Please set LastEditors
 * @Description: C++提高部分
 * @FilePath: /C++/03_C++提高.md
--> 

<!-- TOC -->

- [0.1. 函数模板](#01-函数模板)
- [0.2. 类模板](#02-类模板)
- [0.2.1. vector(向量)](#021-vector向量)

<!-- /TOC -->

## 0.1. 函数模板
- 语法
  ```
  // 声明
  template <typename T>
  void func(T a, T b)

  func<int>(x, y);      // 显示调用
  func(x, y);           // 调用时自动类型推导
  ```

- 两种方式调用
  - 显示类型调用
  - 自动类型推导

- 函数模板与函数重载
  - 函数模板的调用严格的按照类型进行匹配，不会进行类型的自动转换。
  - 普通函数的调用可以进行隐式的类型转换。
  - 调用规则
    - 函数模板与普通函数都符合调用时，C++编译器优先考虑普通函数
    - 函数模板可以像普通函数一样被重载。
    - 若函数模板可以产生一个更好的匹配，那么选择模板
    - 通过空模板 `<>` 实参数列表的语法限定编译器只通过模板匹配。

- 函数模板调用的机制
  - 编译器并不是把函数模板处理成能够匹配任意类型的函数，而是从函数模板中的具体类型产生不同的函数。
  - 编译器会对函数模板进行两次的编译。第一次在声明的地方对模板进行编译，第二次在调用的地方对将参数替换后的代码进行编译。


## 0.2. 类模板
- 为什么要使用类模板？
  - 让算法和数据类型进行各自的分离。 

- 单个类中的类模板
  - 模板类型参数化  
- 继承中的类模板
  - 从模板类派生普通的类时，需要具体化模板类（即指定类的参数类型），C++编译器需要知道父类的数据类型具体是怎样的。 
  - 从模板类派生模板类时


## 0.2.1. vector(向量)
- 模板：`template <typename T> void Show(T arrNum[], int len);`
- 动态数组，在运行阶段执行。
- 操作接口
  - `size()`: 返回容器中元素的个数
  - `get(r)`:获取秩（索引）为r的元素
  - `put(r, e)`:用e替换秩为r元素的数值
  - `insert(r, e)`:向秩为r的元素处插入数值e，后面元素依次后移
  - `remove(r)`:初除秩为r癿元素，迒回诠元素中原存放癿对象
  - `disordered()`:判断所有元素是否已按升序序排列
  - `sort()`:调整各元素癿位置，使按照升序序排列
  - `deduplicate()`:删除重复元素   ---向量
  - `uniquify()`:删除重复元素 ---有序向量
  - `traverse()`:遍历向量幵统一处理所有元素，处理斱法由函数对象指定
  - `empty()`:判断容器是否为空
  - `at(index)`:返回索引为index的元素
  - `erase(p)`:删除p位置处的元素
  - `erase(beg, end)`:删除区间`[beg, end)`的数据
  - `pop_back()`:删除最后一个元素
  - `push_back()`:在容器末尾插入一个元素
  - `begin(), end()`:返回容器收尾元素的迭代器
  - `clear()`:移除容器中所有的元素
  - `swap()`:交换两个容器的内容










