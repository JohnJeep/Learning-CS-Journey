<!--
 * @Author: JohnJeep
 * @Date: 2020-06-15 08:48:16
 * @LastEditTime: 2020-07-13 10:48:27
 * @LastEditors: Please set LastEditors
 * @Description: C++提高部分
 * @FilePath: /C++/03_C++提高.md
--> 

<!-- TOC -->

- [0.1. 函数模板](#01-函数模板)
- [0.2. 类模板](#02-类模板)
- [0.3. vector(向量)](#03-vector向量)
- [0.4. 类型转换](#04-类型转换)
- [0.5. 异常处理](#05-异常处理)
- [0.6. 输入输出流](#06-输入输出流)

<!-- /TOC -->

## 0.1. 函数模板
- 语法
  ```
  // 声明
  template <typename T>
  void func(T a, T b)

  func<int>(x, y);      // 显示调用
  func(x, y);           // 调用时自动类型推导
  ```

- 两种方式调用
  - 显示类型调用
  - 自动类型推导

- 函数模板与函数重载
  - 函数模板的调用严格按照类型进行匹配，不会进行类型的自动转换。
  - `普通函数` 的调用可以进行 `隐式` 的类型转换。
  - 调用规则
    - 函数模板与普通函数都符合调用时，C++编译器优先考虑普通函数
    - 函数模板可以像普通函数一样被重载。
    - 若函数模板可以产生一个更好的匹配，那么选择模板
    - 通过空模板 `<>` 实参数列表的语法限定编译器只通过模板匹配。

- 函数模板调用的机制
  - 编译器并不是把函数模板处理成能够匹配任意类型的函数，而是根据函数模板中的具体类型产生不同的函数。
  - 编译器会对 `函数模板进行两次编译`。`第一次在声明`的地方对模板进行编译，`第二次在调用` 的地方对将参数替换后的代码进行编译。

- 函数模板当函数参数与函数指针当函数参数类似。 



## 0.2. 类模板
- 为什么要使用类模板？
  - 让 `算法` 和 `数据类型` 进行各自的分离。 

- 单个类中的类模板
  - 模板类型参数化  
- 继承中的类模板
  - 从模板类派生普通的类时，需要具体化模板类（即指定类的参数类型），C++编译器需要知道父类的数据类型具体是怎样的。 
  - 类模板可以派生 `类模板`


## 0.3. vector(向量)
- 动态数组实现机制：
  > 先为数组开辟较小的空间，然后往数组里面添加数据，当数据的数目超过数组的容量时，再重新分配一块更大的空间（STL中 `vector` 每次扩容时，新的容量都是前一次的两倍），再把之前的数据复制到新的数组中，再把之前的内存释放。
  - 注意：使用动态数组时，尽量减少改变数组容量大小的次数，可以减少时间性能的消耗。


- 模板：`template <typename T> void Show(T arrNum[], int len);`
- 动态数组，在运行阶段执行。
- 操作接口
  - `size()`: 返回容器中元素的个数
  - `get(r)`:获取秩（索引）为r的元素
  - `put(r, e)`:用e替换秩为r元素的数值
  - `insert(r, e)`:向秩为r的元素处插入数值e，后面元素依次后移
  - `remove(r)`:初除秩为 `r` 的元素，返回全元素中原存放的对象
  - `disordered()`:判断所有元素是否已按升序序排列
  - `sort()`:调整各元素癿位置，使按照升序序排列
  - `deduplicate()`:删除重复元素   ---向量
  - `uniquify()`:删除重复元素 ---有序向量
  - `traverse()`:遍历向量幵统一处理所有元素，处理斱法由函数对象指定
  - `empty()`:判断容器是否为空
  - `at(index)`:返回索引为index的元素
  - `erase(p)`:删除p位置处的元素
  - `erase(beg, end)`:删除区间`[beg, end)`的数据
  - `pop_back()`:删除最后一个元素
  - `push_back()`:在容器末尾插入一个元素
  - `begin(), end()`:返回容器收尾元素的迭代器
  - `clear()`:移除容器中所有的元素
  - `swap()`:交换两个容器的内容

- 向容器中插入元素时，内部的元素必须能够执行 `拷贝（必须提供拷贝构造）` 操作。


## 0.4. 类型转换
- 4种类型转换
  - `static_cast` 静态类型转换。
    - 格式
      ```
      static_cast<>()，
      例如：
      double a1 = 12.0;
      int a2 = static_cast<int>(a1);  
      ```
    - 编译时，编译器会做类型转换。
    - C语言中能使用隐式转换的类型均可以用 `static_cast` 类型转换
  - `reinterpret_cast<>()` 重新解释类型
  - `dynamic_cast<>()` 动态类型转换（父类与子类之间的多态类型转换）
  - `const_cast<>()` const类型转换，去除类型的只读属性。


## 0.5. 异常处理
- 异常严格的按照类型进行匹配，不会进行隐式的类型转换。
- C++的异常处理机制使 `异常的触发` 与 `异常的处理` 不必在同一个函数中，很好的实现了软件的分层机制。
- 异常是一种 `跨越函数` 的机制。

- 栈解旋：类中的抛出异常会执行析构函数。

- 异常变量的生命周期
  - 异常接收时的变量是元素，且为 `定义类的类型` 时，则执行的是拷贝构造。
  - 异常接收时的变量为 `类的引用` 时，使用 throw 时的那个对象。
  - 指针和引用或元素可以同时执行 `catch` 捕获，但引用和元素不能同时执行 `catch` 捕获。




## 0.6. 输入输出流




