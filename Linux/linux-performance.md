<!-- TOC -->

- [1. 性能优化](#1-性能优化)
  - [1.1. 怎样做性能优化？](#11-怎样做性能优化)
  - [1.2. 如何去分析](#12-如何去分析)
    - [1.2.1. 工具](#121-工具)
    - [1.2.2. 代码编写](#122-代码编写)
  - [1.3. 优化到多少？](#13-优化到多少)
  - [1.4. 其它](#14-其它)
- [2. CPU Performance](#2-cpu-performance)
- [3. Memory Performance](#3-memory-performance)
- [4. I/O Performance](#4-io-performance)
- [5. Network Performance](#5-network-performance)
- [6. 参考](#6-参考)

<!-- /TOC -->


# 1. 性能优化

## 1.1. 怎样做性能优化？

在做性能优化之前，需要了解性能**优化指标**。从应用负载的视角来看，有两个核心指标：**吞吐量和延时**，这两个指标直接影响了产品终端的用户体验。从系统资源的角度看，有**资源利用率、饱和度**等指标。

性能问题的本质，就是系统资源已经达到瓶颈，但请求的处理却还不够快，无法支撑更多的请求。而性能分析，就是找出应用或系统的瓶颈，并设法去避免或者缓解它们，从而更高效地利用系统资源处理更多的请求。



从运行时性能的开销和编译时性能的开销角度思考

消除运行期的开销？

## 1.2. 如何去分析

如何去思考去分析性能，该从哪些方面入手？

1. 当前应用程序或系统有哪些指标可以衡量性能？
2. 怎么样去设置应用程序或系统的性能指标？
3. 使用什么样的性能工具来观察指标？
4. 导致这些指标变化的因素是什么？
5. 怎样进行性能基准测试？
6. 怎样进行性能分析定位瓶颈？
7. 性能监控和告警是怎样的？

学习的黄金准则

1. 勤思考
2. 多反思
3. 善总结
4. 多问为什么



### 1.2.1. 工具

**性能工具选择的黄金准则：一个正确的选择胜过千百次的努力。** 选用合适的性能工具，可以大大简化整个性能优化的过程。

性能分析可以用哪些工具来衡量？

- gprof

  gprof 是 GNU 工具链之一，编译的时候，它在每个函数的出入口加入了 profiling 的代码，运行时统计程序在用户态的执行信息，可以得到每个函数的调用次数，执行时间，调用关系等信息，简单易懂。适合于查找用户级程序的性能瓶颈，然而对于很多耗时在内核态执行的程序，gprof 不适合。

- Oprofile

  Oprofile 是一个开源的 profiling 分析工具，它使用硬件调试寄存器来统计信息，进行 profiling 的开销比较小，而且可以对内核进行 profiling。它统计的信息非常多，可以得到 cache 的缺失率，memory 的访存信息，分支预测错误率等等，这些信息 gprof 得不到，但是对于函数调用次数，它无能为力。

- gperftools

  Google 开发的一款性能分析工具，提供整个程序的热点分布图，找到性能瓶颈，然后可以针对性的进行性能优化。

下图是常见的性能分析工具，来自性能领域的大师布伦丹·格雷格（Brendan Gregg）绘制，这个图是 Linux 性能分析最重要的参考资料之一，它告诉你，在 Linux 不同子系统出现性能问题后，应该用什么样的工具来观测和分析。

<img src="pictures/linux_observability_tools.png" style="zoom: 33%;" >

- mpstat：多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。

  ```sh
  参数项
  	-P: 输出哪个处理器的数据，后面跟 CPU 的数字号码或者是 ON 或 ALL；ON 表示输出统计每个在运行的处理器；ALL 表示输出统计所有的处理器
  
  // 监控所有 CPU，每隔5秒输出一组数据
  [root@CentOS7 ~]# mpstat -P ALL 5
  Linux 3.10.0-1160.49.1.el7.x86_64 (CentOS7)     12/15/2021      _x86_64_        (2 CPU)
  10:55:54 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
  10:55:59 PM  all   50.10    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.90
  10:55:59 PM    0    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
  10:55:59 PM    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
  ```
  
- pidstat：进程性能分析工具，监视当前被 Linux 内核管理的单个任务。用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

  ```sh
  参数项
  	-u: 输出 CPU 的利用率。
  	
  // 每隔 5 秒输出一组数据
  [root@CentOS7 ~]# pidstat -u 5 1
  Linux 3.10.0-1160.49.1.el7.x86_64 (CentOS7)     12/15/2021      _x86_64_        (2 CPU)
  10:57:36 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
  10:57:41 PM     0         3    0.00    0.20    0.00    0.20     0  kworker/0:0
  10:57:41 PM     0       745    0.00    0.20    0.00    0.20     0  vmtoolsd
  10:57:41 PM     0      6791  100.00    0.00    0.00  100.00     1  stress
  10:57:41 PM     0      6914    0.00    0.20    0.00    0.20     0  pidstat
  
  Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command
  Average:        0         3    0.00    0.20    0.00    0.20     -  kworker/0:0
  Average:        0       745    0.00    0.20    0.00    0.20     -  vmtoolsd
  Average:        0      6791  100.00    0.00    0.00  100.00     -  stress
  Average:        0      6914    0.00    0.20    0.00    0.20     -  pidstat
  
  ```

  

- stress：linux 下的压力测试小工具，可以用来模拟 CPU、IO、内存、磁盘等资源耗尽的问题，但这也仅仅只是用来模拟进行简单的资源耗尽问题，用它模拟产生的结果和业务真实场景差别还是很大的，真实业务场景下不建议使用。

  ```sh
  参数项
  	-t: 等同于 --timeout N，在 N 秒后超时
  	-c: 等同于 --cpu N，产生 N 个 CPU 工作
  	-i: 等同于 --io N，产生 N 个 IO 工作
  	
  // 模拟 CPU1 使用率为 100% 的情况
  [root@CentOS7 ~]# stress --cpu 1 --timeout 600
  stress: info: [6790] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd
  ```

  

 





### 1.2.2. 代码编写



## 1.3. 优化到多少？

## 1.4. 其它

```cpp
打印行和文件：stream(__FILE__, __LINE__)
```

判断是运行时变量还是编译时变量？

​	使用 static_assert()

应用：

​	替换宏（为什么要替换宏？）

​	宏运行在什么时候？（编译？运行？）



# 2. CPU Performance

load average（平均负载）：单位时间内，系统处于可运行状态（runnable state）或不可中断状态（uninterruptable state）的平均进程数，与 CPU 使用率并没有直接关系。

可运行状态的进程：正在使用 CPU 或正在等待 CPU 的进程。也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

不可中断状态的进程：正处于内核态关键流程中的进程，并且这些流程是不可打断的。比如最常见的是正在等待磁盘（disk），也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

正确区分平均负载和 CPU 使用率

CPU 使用率指单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如下面的情况：

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；
- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。

# 3. Memory Performance



# 4. I/O Performance



# 5. Network Performance



# 6. 参考

[Linux Performance](http://www.brendangregg.com/linuxperf.html)