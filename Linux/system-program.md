<!--
 * @Author: JohnJeep
 * @Date: 2020-05-23 23:12:17
 * @LastEditTime: 2020-06-08 22:57:32
 * @LastEditors: Please set LastEditors
 * @Description: 系统函数的使用
--> 
<!-- TOC -->

- [1. System program](#1-system-program)
  - [1.1. 概念](#11-概念)
  - [1.2. 函数](#12-函数)
  - [1.3. 环境变量](#13-环境变量)
  - [1.4. fork函数](#14-fork函数)
  - [1.5. exec函数家族](#15-exec函数家族)
  - [1.6. wait函数](#16-wait函数)
  - [1.7. 进程间通信（IPC）](#17-进程间通信ipc)
    - [1.7.1. 管道](#171-管道)
    - [共享映射区(mmap)](#共享映射区mmap)
    - [1.7.2. 信号](#172-信号)

<!-- /TOC -->

# 1. System program
## 1.1. 概念
- 文件函数包括三部分内容
  - `file descriptor`  文件描述符
  - `file pointer(fp)` 文件指针
  - `file buffer`     文件数据缓冲区 
- 全部变量 `errno` 在Linux中存放位置 `/usr/include`
- 可以使用 `perror()` 打印错误的信息
- 文件的实际权限 = 用户给定的权限和本地的掩码取反做位与（&）操作


## 1.2. 函数
- `open()` 函数
  - 创建：`O_CREAT` 或采用 `截断为0的方式创建 O_TRUNC`
  - 读写：`O_RDWR`
  - 只读：`O_RDONLY`
  - 只写：`O_WRONLY`
  - 文件是否存在：`O_EXCL`
- `read()/write()` 函数
  - `-1` 读/写文件失败
  - `0`  文件读完了或文件写成完了
  - `>0` 读/写文件的字节数
- `lseek()` 函数 
  - 获取文件的长度
  - 移动文件指针
  - 文件拓展（只能向文件的中间或尾部扩展，不能向前端扩展）
- `stat()` 查看文件的所有状态信息。进行追踪或穿透，显示追踪到的文件或软连接指定的文件信息。
- `lstat()` 查看文件的状态信息。不进行追踪或穿透，直接显示当前文件或软连接的信息。
- `access()` 测试指定文件是否拥有某种权限。 
- `chmod()` 改变文件的权限
- `truncate()` 将指定文件的大小由指定参数 `length` 长度确定，
  - `length` 长度大于当前文件，文件将被拓展
  - `length` 长度小于当前文件，文件截取，截取值为 `length` 值
- `readlink()` 读一个软链接的值
- `unlink()` 
  - 删除一个硬链接数
  - 可以读取临时文件的内容。先创建文件，向文件写，然后读文件中写的内容并将读出的数据写到另外的一个文件中。


- `opendir()` 打开一个目录
- `readdir()` 读一个目录
- `closedir()` 关闭一个目录


- `dup()` 或 `dup2()` 复制文件描述符
  ```
  int dup(int fd);  //复制fd对应的文件表指针，返回下一个可用的文件描述符
  int dup2(int fd1, int fd2); //将fd2对应的文件表指针修改为fd1对应的文件表指针
  ```


- `fcntl` 改变已经打开文件的属性，即获取或设置文件的状态标记。
  - `F_GETFL` 获取文件状态参数
  - `F_SETFL` 设置文件状态参数
   

## 1.3. 环境变量
- 常见的环境变量
  - `PATH ` 指定可执行文件搜索路径
  - `SHELL` 指定当前所使用的命令解析器
  - `TERM ` 当前终端类型
  - `LANG ` 指定语言环境
  - `HOME ` 用户主目录


- 常见的环境变量函数 
  - `getenv()` 获取环境变量值
  - `setenv()` 设置环境变量值
	  - 3个参数
			- `1`  覆盖原值
			- `0`  不覆盖
			- `-1` 出错
  - `unsetenv()` 删除环境变量



## 1.4. fork函数
- 创建一个子进程。一个进程调用 `fork()` 函数，变为两个进程，各自的进程都有一个返回值。父进程返回值为子进程的 `PID`（返回值大于0），子进程的返回值为 `0`，进程创建成功。
- 父子进程之间遵循原则：`读时共享写时复制`。例如：一个全局变量，子进程只读时，则父子进程共享变量；若子进程对全局变量写操作时，则不共享全局变量。
- 父子进程共享
  - 共享文件描述符。
  - 共享 `mmap` 建立的映射区。
- 执行 `fork` 操作之后，是父进程先执行还是子进程先执行，是不确定的，取决于系统内的调度算法。
- 子进程与父进程异同点
  - 相同
    - 全局变量 
    - .data
    - .text
    - 栈、堆
    - 环境变量
    - 用户 ID
    - 宿主目录
    - 进程工作目录
    - 信号处理方式
  - 不同
    - 进程控制块(当前进程的父进程ID)
    - PID
    - fork返回值
    - 定时器
    - 未决信号集
    - 进程运行时间 


- 可能用到的函数
  - `getpid()`  获取子进程PID号
  - `getppid()` 获取父进程PID号
  - `getuid()`  获取当前进程实际用户ID号
  - `geteuid()` 获取当前进程有效用户ID号
  - `getgid()`  获取当前进程实际用户组ID号
  - `getegid()` 获取当前进程有效用户组ID号


## 1.5. exec函数家族
- 执行exec()家族的函数后，将当前进程的内存空间数据替换为要执行函数的内存空间数据。
- exec()家族函数只有失败时才返回，返回值为 -1，程序执行成功时，含食宿不会返回。

```
  l (list)			   命令行参数列表
  p (path)			   搜素file时使用path变量
  v (vector)			 使用命令行参数数组
  e (environment)	使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量
```
- `execlp` 加载一个进程，通过环境变量加载。
- `execl` 加载一个进程，通过路径 + 程序名称来加载。
- `execle` 加载一个进程，通过路径 + 程序名称来加载，使用自定义环境变量env。
- `execv` 加载一个进程，使用命令行参数数组。
- `execvp` 加载一个进程，使用自定义环境变量env
- `execvpe` 加载一个进程，使用命令行参数数组，并加上自定义环境变量env。

<img src="./pictures/exec函数家族.png" >


## 1.6. wait函数
- 什么是孤儿进程？
  > 父进程先与子进程死亡，子进程就成为了孤儿进程，此时子进程的父进程的变为 `init` 进程，`init` 进程也称为init进程领养孤儿进程。
- 什么是僵尸进程
  > 子进程结束了，父进程没有回收子进程的内存空间，而子进程的进程控制块（PCB）还存留于操作系统的内核之中，此时的子进程称为僵尸进程（zombie）。

- `wait()` 函数作用
  - 阻塞等待子进程退出
  - 回收子进程的PCB内存空间资源
  - 获取子进程死亡的原因 
```
// 子进程退出的几种常见的宏

if (WIFEXITED(wstatus))         // 进程正常结束
{
    printf("exited, status=%d\n", WEXITSTATUS(wstatus));
} 
else if (WIFSIGNALED(wstatus))  // 进程异常终止
{
    printf("killed by signal %d\n", WTERMSIG(wstatus));
}
else if (WIFSTOPPED(wstatus))   // 进程处于暂停状态
{
    printf("stopped by signal %d\n", WSTOPSIG(wstatus));
} 
else if (WIFCONTINUED(wstatus)) 
{
    printf("continued\n");
}
```
- 一个 `waitpid()` 或`wait()` 函数只能回收一个僵尸进程。回收多个僵尸进程需要循环调用 `waitpid()` 或`wait()` 函数。


- `waitpid()` 函数
  - 函数原型 `pid_t waitpid(pid_t pid, int *wstatus, int options);`
  - 参数
    - `pid` 指定特定的进程PID，
      - 当 `pid=-1` 时，传入的是任意进程的PID
      - 当 `pid=0` 时，回收当前进程组内（group）的所有子进程；
      - 当 `pid=-进程组id` 时，回收指定进程组内的任意子进程。
    - `*wstatus` 子进程退出的状态
    - `options` 可以将进程设置为阻塞态（设置为 0）或运行态（设置为 WNOHAGN）
  - 函数返回值
    - 正常运行：pid
    - 失败：-1
    - 当 `options=WNOHAGN`时，子进程为非阻塞状态且子进程尚未结束时，返回值为 0

  - 函数作用：指定特定的进程PID 进行僵尸进程的回收。子进程的状态可以设置为不阻塞，使用宏 `WNOHAGN`


## 1.7. 进程间通信（IPC）
- 四种方式
  - 管道（最简单）
  - 信号（开销最小）
  - 共享映射区（无血缘关系）
  - 本地套接字（最稳定） 

- Linux中七种文件类型
  - 非伪文件：占用磁盘的存储空间
    - `-` 普通文件
    - `d(directory)` 目录
    - `l(link)` 链接
  
  - 伪文件：不占用磁盘的存储空间
    - `s(socket)` 套接字
    - `b(block) ` 块设备
    - `c(char)  `字符设备
    - `p(pipe)  `管道


### 1.7.1. 管道
- 本质：是一个伪文件，内核创建的缓冲区
- 由两个文件描述符引用，一个表示读端，一个表示写端。
  - `fd[0]`---------------管道的 read 端
  - `fd[1]`---------------管道的 write 端
- pipe 匿名管道：用于非血缘关系之间的进程通信
- 原理
  - 通过环形队列，借助内核缓冲区（4k大小）来实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。 
- 局限性
  - 数据不能自己读写
  - 数据一旦被读走，管道中就没有了，不能反复读取。
  - 管道采用半双工通信方式，数据只能在一个方向上流动。
  - 只能在有 `公共祖先` 的进程间使用管道。

- 管道中数据的读与写
  - 人为的规定：子进程从管道中 `read`，父进程从管道中 `write`。 
  - 读管道
    - 管道中有数据
      - `read()` 返回实际读到的字节数。
    - 管道中无数据
      - 管道 `写端` 被全部关闭: `read()` 返回皇子为 0
      - 管道 `写端` 没有被全部关闭: `read()` 阻塞等待。
  - 写管道 
    - 管道读端全部关闭
      -  进程异常终止。可用 `SIGPIPE` 来捕捉信号。 
    - 管道读端没有全部关闭
      - 管道已满，write阻塞。
      - 管道未满，write将数据写入，并返回实际写入的字节数。
   

- FIFO 有名管道


### 共享映射区(mmap)
- 当标志位flags等于 `MAP_SHARED` 时，创建映射区的权限要小于等于打开文件的权限。
- 当标志位flags等于 `MAP_PRIVATE` 时，对映射区的权限没有要求，因为 mmap中的权限是对内存的限制。
- 创建映射区的过程中隐含的有对映射区的 `读操作权限`。
- 映射的文件大小为 `0` 时，不能再创建映射区。因此，用于映射的文件必须要有实际的大小。
- 打开或创建的文件偏移量必须为 `4k的正数倍`。因为MMU创建的页大小为 4K。
- mmap 使用的过程中常常出现 `总线错误`，通常是由于共享文件存储空间大小导致的。
- `munmap` 函数传入的地址一定是 `mmap` 函数的返回地址。
- 映射区的返回值一定需要检查，防止出错。

文件映射到磁盘的内存区域，可以简单的把映射的区域看做一个的类似的数组，即一个指针指向数组的首地址。


- 父子间进程通信
  - 共享打开的文件
  - 当标志位 `flags=MAP_SHARED` 时，共享建立的映射区 。当 `flags=MAP_PRIVATE` 时，父子进程的内核映射区相互独立的，各占一个映射区。

- 匿名映射
  - 采用宏 `MAP_ANONYMOUS` 的方式，不需要再使用文件的方法去操作 mmap
  - 注意：只适用于类Linux操作系统中，对其它的操作系统（freeBSD）不适用。 

- 通用的方法
  - 通过 `/dev/zero` 目录中系统自带的伪文件 `zero`，去操作 mmap，实现内存映射。


- 非血缘关系之间的进程通信，即不同的文件之间通信。
  - 创建映射区的文件只有一个
  - 可以多端读和多端写 
  


### 1.7.2. 信号
- `man 7 signal` 查看信号的帮助文档

- 进程控制块(PCB)信息
  - 进程pid
  - 进程状态
  - 工作目录
  - 用户id
  - 组id
  - 文件描述符表
  - 信号相关的信息，主要指阻塞信号集和未决信号集。

- `信号`：只能携带固定大小量的信息。

- 产生信号的机制
  - 通过软件的方式实现的，有一定的延迟性（对CPU而言），对用户来说，延时很短，不易察觉。
  - 每个进程收到的所有信号，都是由内核负责发送，内核进行处理。

- 产生信号的几种方式
  - 按键产生，如：`Ctrl+c`、`Ctrl+z`、`Ctrl+\`
  - 系统调用产生，如：`kill`、`raise`、`abort`
  - 软件条件产生，如：定时器 `alarm`
  - 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)
  - 命令产生，如：`kill` 命令

- 信号的处理方式
  - 执行默认动作 
  - 忽略(丢弃) ，并不是不处理信号，而是将信号处理后再进行忽略或丢弃。
  - 捕捉(调用户处理函数)
<img src="./pictures/信号处理过程.png">

- 阻塞信号集(信号屏蔽字)： 
  - 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)
- 未决信号集
  - 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 
  - 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。 
<img src="./pictures/未决信号集与阻塞信号集.png">


- 信号的四要素
  - 信号的名字
  - 信号的编号
  - 事件
  - 默认处理动作
