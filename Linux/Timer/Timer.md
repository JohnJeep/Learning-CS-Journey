# 高性能定时器

## 结构

定时器通常至少包含两个成员：

- 超时时间（相对时间或绝对时间）。
- 任务回调函数。

有时候还包含回调函数被执行时所需要传入的参数，以及是否重启定时器等信息。



时间轮（Time Wheel）定时器是一种常见的定时器实现方式，它的核心思想是使用一个环形的数组，每个元素都代表一段时间（通常是1毫秒）的时间段。每个时间段内维护一个任务列表，任务按照超时时间加入对应的时间段内。定时器每过一个时间段，时间轮就会转动一位，从而维护待执行的任务列表。

多级时间轮定时器是时间轮定时器的升级版，它使用多个时间轮构成一个层次结构，每个时间轮的精度逐步提高，使得实现更加高效。

具体来讲，一个多级时间轮定时器可以包含多个时间轮，每个时间轮的长度是前一级时间轮的倍数，每个时间轮的精度比前一级时间轮高。最底层的时间轮精度最低，代表的时间段最短，通常是1毫秒。每个时间轮维护一个任务列表，任务按照超时时间加入对应的时间段内。当一个时间轮的最后一个时间段超时后，它会通知上一级时间轮，上一级时间轮的指针会顺时针转动一个位置，对应的任务列表也会被重新分配到下一级时间轮中。最终，当最高层的时间轮转动时，所有待执行的任务都会被处理。

为了保证定时器的效率，可以使用哈希表维护任务列表，可以快速定位到指定的时间段并将任务加入列表中。同时，在时间轮转动时，可以使用类似于桶排序的方式将任务重新分配到下一级时间轮中，以保证时间轮的效率。





## 如何设计高效的定时器

实现多级时间轮的高效定时器需要考虑以下几个方面：

1. 时间轮只存储过期时间在当前时间槽到下一级时间轮之间的任务，减少了遍历时间轮的时间。
2. 每个时间轮的时间间隔是上一级时间轮的整数倍。这样可以方便地将任务传递到下一级时间轮，减少了遍历时间轮的时间。
3. 使用链表来存储任务，可以更快地删除任务。



## 案例

- 腾讯开源的 [libco](https://github.com/Tencent/libco) 库：是微信后台大规模使用的c/c++协程库: **时间轮**的方式。
- 开源 [Asio](https://think-async.com/Asio/) 库：红黑树最小堆算法。
- nginx：红黑树最小堆算法。
- linux 内核：Hierarchy 时间轮算法。

#  Reference

- 深入Linux C/C++ Timer定时器的实现核心原理: https://www.cnblogs.com/sunsky303/p/14154190.html
- Linux内核时钟系统和定时器实现: http://walkerdu.com/2016/07/25/linux-kernel-timer
- Reinventing the timer wheel: https://lwn.net/Articles/646950/
- Github Linux 内核高精度 httimer 实现: https://github.com/torvalds/linux/blob/master/kernel/time/hrtimer.c
- A new approach to kernel timers: https://lwn.net/Articles/152436/
- 《Linux-UNIX系统编程手册-上下册》
- 《the linux programming interface》
- 《Linux高性能服务器编程·游双》



